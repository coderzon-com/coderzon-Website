"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/block-tools/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@portabletext/block-tools/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockContentFeatures: () => (/* binding */ getBlockContentFeatures),\n/* harmony export */   htmlToBlocks: () => (/* binding */ htmlToBlocks),\n/* harmony export */   normalizeBlock: () => (/* binding */ normalizeBlock),\n/* harmony export */   randomKey: () => (/* binding */ randomKey)\n/* harmony export */ });\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n\n\n\n\n\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\";\n}\nconst objectToString = Object.prototype.toString;\nfunction resolveJsType(val) {\n  switch (objectToString.call(val)) {\n    case \"[object Function]\":\n      return \"function\";\n    case \"[object Date]\":\n      return \"date\";\n    case \"[object RegExp]\":\n      return \"regexp\";\n    case \"[object Arguments]\":\n      return \"arguments\";\n    case \"[object Array]\":\n      return \"array\";\n    case \"[object String]\":\n      return \"string\";\n  }\n  return val === null ? \"null\" : val === void 0 ? \"undefined\" : val && typeof val == \"object\" && \"nodeType\" in val && val.nodeType === 1 ? \"element\" : val === Object(val) ? \"object\" : typeof val;\n}\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };\nnew Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nconst PRESERVE_WHITESPACE_TAGS = [\"pre\", \"textarea\", \"code\"], BLOCK_DEFAULT_STYLE = \"normal\", DEFAULT_BLOCK = Object.freeze({\n  _type: \"block\",\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE\n}), DEFAULT_SPAN = Object.freeze({\n  _type: \"span\",\n  marks: []\n}), HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: { ...DEFAULT_BLOCK, style: \"blockquote\" }\n}, HTML_SPAN_TAGS = {\n  span: { object: \"text\" }\n}, HTML_LIST_CONTAINER_TAGS = {\n  ol: { object: null },\n  ul: { object: null }\n}, HTML_HEADER_TAGS = {\n  h1: { ...DEFAULT_BLOCK, style: \"h1\" },\n  h2: { ...DEFAULT_BLOCK, style: \"h2\" },\n  h3: { ...DEFAULT_BLOCK, style: \"h3\" },\n  h4: { ...DEFAULT_BLOCK, style: \"h4\" },\n  h5: { ...DEFAULT_BLOCK, style: \"h5\" },\n  h6: { ...DEFAULT_BLOCK, style: \"h6\" }\n}, HTML_MISC_TAGS = {\n  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }\n}, HTML_DECORATOR_TAGS = {\n  b: \"strong\",\n  strong: \"strong\",\n  i: \"em\",\n  em: \"em\",\n  u: \"underline\",\n  s: \"strike-through\",\n  strike: \"strike-through\",\n  del: \"strike-through\",\n  code: \"code\",\n  sup: \"sup\",\n  sub: \"sub\",\n  ins: \"ins\",\n  mark: \"mark\",\n  small: \"small\"\n}, HTML_LIST_ITEM_TAGS = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: \"bullet\"\n  }\n}, ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS\n};\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(ELEMENT_MAP).filter((tag) => \"style\" in tag).map((tag) => tag.style)\n);\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(HTML_DECORATOR_TAGS)\n);\nfunction blockContentFeatures(blockContentType) {\n  if (!blockContentType)\n    throw new Error(\"Parameter 'blockContentType' required\");\n  const blockType = blockContentType.of.find(findBlockType);\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockSchemaType)(blockType))\n    throw new Error(\"'block' type is not defined in this schema (required).\");\n  const ofType = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockChildrenObjectField)?.type?.of;\n  if (!ofType)\n    throw new Error(\"No `of` declaration found for blocks `children` field\");\n  const spanType = ofType.find(\n    (member) => member.name === \"span\"\n  );\n  if (!spanType)\n    throw new Error(\n      \"No `span` type found in `block` schema type `children` definition\"\n    );\n  const inlineObjectTypes = ofType.filter(\n    (inlineType) => inlineType.name !== \"span\" && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(inlineType)\n  ), blockObjectTypes = blockContentType.of.filter(\n    (memberType) => memberType.name !== blockType.name && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(memberType)\n  );\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes\n    }\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockStyleObjectField);\n  if (!styleField)\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\"\n    );\n  const textStyles = getTitledListValuesFromEnumListOptions(\n    styleField.type.options\n  );\n  if (textStyles.length === 0)\n    throw new Error(\n      \"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    );\n  return textStyles;\n}\nfunction resolveEnabledAnnotationTypes(spanType) {\n  return spanType.annotations.map((annotation) => ({\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon\n  }));\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockListObjectField);\n  if (!listField)\n    throw new Error(\n      \"A field with name 'list' is not defined in the block type (required).\"\n    );\n  const listItems = getTitledListValuesFromEnumListOptions(\n    listField.type.options\n  );\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction getTitledListValuesFromEnumListOptions(options) {\n  const list = options ? options.list : void 0;\n  return Array.isArray(list) ? list.map(\n    (item) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isTitledListValue)(item) ? item : { title: item, value: item }\n  ) : [];\n}\nconst _XPathResult = {\n  BOOLEAN_TYPE: 3,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6\n};\nvar preprocessGDocs = (_html, doc, options) => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || \"preserve\";\n  let gDocsRootOrSiblingNode = doc.evaluate(\n    '//*[@id and contains(@id, \"docs-internal-guid\")]',\n    doc,\n    null,\n    _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n    null\n  ).iterateNext();\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === \"b\";\n    switch (isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode) {\n      case \"normalize\":\n        normalizeWhitespace(gDocsRootOrSiblingNode);\n        break;\n      case \"remove\":\n        removeAllWhitespace(gDocsRootOrSiblingNode);\n        break;\n    }\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i);\n      elm?.setAttribute(\"data-is-google-docs\", \"true\"), (elm?.parentElement === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm?.setAttribute(\"data-is-root-node\", \"true\"), tagName(elm)), tagName(elm) === \"li\" && elm.firstChild && tagName(elm?.firstChild) === \"img\" && elm.removeChild(elm.firstChild);\n    }\n    return isWrappedRootTag && doc.body.firstElementChild?.replaceWith(\n      ...Array.from(gDocsRootOrSiblingNode.childNodes)\n    ), doc;\n  }\n  return doc;\n};\nconst unwantedWordDocumentPaths = [\n  \"/html/text()\",\n  \"/html/head/text()\",\n  \"/html/body/text()\",\n  \"/html/body/ul/text()\",\n  \"/html/body/ol/text()\",\n  \"//comment()\",\n  \"//style\",\n  \"//xml\",\n  \"//script\",\n  \"//meta\",\n  \"//link\"\n];\nvar preprocessHTML = (_html, doc) => {\n  const bodyTextNodes = doc.evaluate(\n    \"/html/body/text()\",\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i), text = node.textContent || \"\";\n    if (text.replace(/[^\\S\\n]+$/g, \"\")) {\n      const newNode = doc.createElement(\"span\");\n      newNode.appendChild(doc.createTextNode(text)), node.parentNode?.replaceChild(newNode, node);\n    } else\n      node.parentNode?.removeChild(node);\n  }\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted && unwanted.parentNode?.removeChild(unwanted);\n  }\n  return doc;\n}, preprocessNotion = (html, doc) => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;\n  if (html.match(NOTION_REGEX)) {\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--)\n      childNodes.snapshotItem(i)?.setAttribute(\"data-is-notion\", \"true\");\n    return doc;\n  }\n  return doc;\n}, preprocessWhitespace = (_2, doc) => {\n  function processNode(node) {\n    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(\n      node.parentElement?.tagName.toLowerCase() || \"\"\n    ))\n      node.textContent = node.textContent?.replace(/\\s\\s+/g, \" \").replace(/[\\r\\n]+/g, \" \") || \"\";\n    else\n      for (let i = 0; i < node.childNodes.length; i++)\n        processNode(node.childNodes[i]);\n  }\n  return processNode(doc.body), doc;\n};\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/, unwantedPaths = [\n  \"//o:p\",\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\"\n], mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\"\n], elementMap = {\n  MsoTocHeading: [\"h3\"],\n  MsoTitle: [\"h1\"],\n  MsoToaHeading: [\"h2\"],\n  MsoSubtitle: [\"h5\"],\n  MsoSubtleEmphasis: [\"span\", \"em\"],\n  MsoIntenseEmphasis: [\"span\", \"em\", \"strong\"]\n  // Remove cruft\n};\nfunction isWordHtml(html) {\n  return WORD_HTML_REGEX.test(html);\n}\nvar preprocessWord = (html, doc) => {\n  if (!isWordHtml(html))\n    return doc;\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join(\"|\"),\n    doc,\n    (prefix) => prefix === \"o\" ? \"urn:schemas-microsoft-com:office:office\" : null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted?.parentNode && unwanted.parentNode.removeChild(unwanted);\n  }\n  const mappedElements = doc.evaluate(\n    mappedPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || \"\");\n    if (!tags)\n      continue;\n    const parentElement = doc.createElement(tags[0]);\n    let parent = parentElement, child = parentElement;\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag), parent.appendChild(child), parent = child;\n    }), child.appendChild(text), mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);\n  }\n  return doc;\n}, preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML\n];\nfunction createRuleOptions(blockContentType) {\n  const features = blockContentFeatures(blockContentType), enabledBlockStyles = features.styles.map(\n    (item) => item.value || item.title\n  ), enabledSpanDecorators = features.decorators.map(\n    (item) => item.value || item.title\n  ), enabledBlockAnnotations = features.annotations.map(\n    (item) => item.value || item.title || \"\"\n  ), enabledListTypes = features.lists.map(\n    (item) => item.value || item.title || \"\"\n  );\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n    enabledListTypes\n  };\n}\nfunction tagName(el) {\n  if (el && \"tagName\" in el)\n    return el.tagName.toLowerCase();\n}\nfunction preprocess(html, parseHtml, options) {\n  const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));\n  return preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options);\n  }), doc;\n}\nfunction normalizeHtmlBeforePreprocess(html) {\n  return html.trim();\n}\nfunction defaultParseHtml() {\n  if (resolveJsType(DOMParser) === \"undefined\")\n    throw new Error(\n      \"The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.\"\n    );\n  return (html) => new DOMParser().parseFromString(html, \"text/html\");\n}\nfunction flattenNestedBlocks(blocks2) {\n  let depth = 0;\n  const flattened = [], traverse = (nodes) => {\n    const toRemove = [];\n    nodes.forEach((node) => {\n      depth === 0 && flattened.push(node), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(node) && (depth > 0 && (toRemove.push(node), flattened.push(node)), depth++, traverse(node.children)), node._type === \"__block\" && (toRemove.push(node), flattened.push(node.block));\n    }), toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1);\n    }), depth--;\n  };\n  return traverse(blocks2), flattened;\n}\nfunction nextSpan(block, index) {\n  const next = block.children[index + 1];\n  return next && next._type === \"span\" ? next : null;\n}\nfunction prevSpan(block, index) {\n  const prev = block.children[index - 1];\n  return prev && prev._type === \"span\" ? prev : null;\n}\nfunction isWhiteSpaceChar(text) {\n  return [\"\\xA0\", \" \"].includes(text);\n}\nfunction trimWhitespace(blocks2) {\n  return blocks2.forEach((block) => {\n    (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(block) && block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child))\n        return;\n      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);\n      index === 0 && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), child.text || block.children.splice(index, 1), prevChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += \" \", block.children.splice(index, 1)) : nextChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));\n    });\n  }), blocks2;\n}\nfunction ensureRootIsBlocks(blocks2) {\n  return blocks2.reduce((memo, node, i, original) => {\n    if (node._type === \"block\")\n      return memo.push(node), memo;\n    if (node._type === \"__block\")\n      return memo.push(node.block), memo;\n    const lastBlock = memo[memo.length - 1];\n    if (i > 0 && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(original[i - 1]) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(lastBlock))\n      return lastBlock.children.push(node), memo;\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node]\n    };\n    return memo.push(block), memo;\n  }, []);\n}\nfunction isNodeList(node) {\n  return Object.prototype.toString.call(node) === \"[object NodeList]\";\n}\nfunction isMinimalSpan(node) {\n  return node._type === \"span\";\n}\nfunction isMinimalBlock(node) {\n  return node._type === \"block\";\n}\nfunction isPlaceholderDecorator(node) {\n  return node._type === \"__decorator\";\n}\nfunction isPlaceholderAnnotation(node) {\n  return node._type === \"__annotation\";\n}\nfunction isElement(node) {\n  return node.nodeType === 1;\n}\nfunction normalizeWhitespace(rootNode) {\n  let emptyBlockCount = 0, lastParent = null;\n  const nodesToRemove = [];\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child), emptyBlockCount = 0;\n      continue;\n    }\n    const elm = child;\n    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);\n  }\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction removeAllWhitespace(rootNode) {\n  const nodesToRemove = [];\n  function collectNodesToRemove(currentNode) {\n    if (isElement(currentNode)) {\n      const elm = currentNode;\n      if (tagName(elm) === \"br\" && (tagName(elm.nextElementSibling) === \"p\" || tagName(elm.previousElementSibling) === \"p\")) {\n        nodesToRemove.push(elm);\n        return;\n      }\n      if ((tagName(elm) === \"p\" || tagName(elm) === \"br\") && elm?.firstChild?.textContent?.trim() === \"\") {\n        nodesToRemove.push(elm);\n        return;\n      }\n      for (let child = elm.firstChild; child; child = child.nextSibling)\n        collectNodesToRemove(child);\n    }\n  }\n  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction isWhitespaceBlock(elm) {\n  return [\"p\", \"br\"].includes(tagName(elm) || \"\") && !elm.textContent?.trim();\n}\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);\nfunction isEmphasis$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style\\s*:\\s*italic/.test(style || \"\");\n}\nfunction isStrong$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight\\s*:\\s*700/.test(style || \"\");\n}\nfunction isUnderline$1(el) {\n  if (!isElement(el) || tagName(el.parentNode) === \"a\")\n    return !1;\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*underline/.test(style || \"\");\n}\nfunction isStrikethrough(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || \"\");\n}\nfunction isGoogleDocs(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-google-docs\");\n}\nfunction isRootNode(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-root-node\");\n}\nfunction getListItemStyle$1(el) {\n  const parentTag = tagName(el.parentNode);\n  if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)))\n    return tagName(el.parentNode) === \"ul\" ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel$1(el) {\n  let level = 0;\n  if (tagName(el) === \"li\") {\n    let parentNode = el.parentNode;\n    for (; parentNode; ) {\n      const parentTag = tagName(parentNode);\n      parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;\n    }\n  } else\n    level = 1;\n  return level;\n}\nconst blocks = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS\n};\nfunction getBlockStyle(el, enabledBlockStyles) {\n  const childTag = tagName(el.firstChild), block = childTag && blocks[childTag];\n  return block && enabledBlockStyles.includes(block.style) ? block.style : BLOCK_DEFAULT_STYLE;\n}\nfunction createGDocsRules(_blockContentType, options) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong$1(el) && span.marks.push(\"strong\"), isUnderline$1(el) && span.marks.push(\"underline\"), isStrikethrough(el) && span.marks.push(\"strike-through\"), isEmphasis$1(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"li\" && isGoogleDocs(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle$1(el),\n            level: getListItemLevel$1(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || [])\n          };\n      }\n    },\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el.classList.contains(\"apple-interchange-newline\"))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el?.parentNode?.textContent === \"\")\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && isRootNode(el))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n      }\n    }\n  ];\n}\nfunction keyGenerator() {\n  return randomKey(12);\n}\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(rnds8), rnds8;\n}\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i)\n  byteToHex[i] = (i + 256).toString(16).slice(1);\nfunction randomKey(length) {\n  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], \"\").slice(0, length);\n}\nconst whitespaceTextNodeRule = {\n  deserialize(node) {\n    return node.nodeName === \"#text\" && isWhitespaceTextNode(node) ? {\n      ...DEFAULT_SPAN,\n      marks: [],\n      text: (node.textContent ?? \"\").replace(/\\s\\s+/g, \" \")\n    } : void 0;\n  }\n};\nfunction isWhitespaceTextNode(node) {\n  return (node.nodeType === 3 && (node.textContent || \"\").replace(/[\\r\\n]/g, \" \").replace(/\\s\\s+/g, \" \") === \" \" && node.nextSibling && node.nextSibling.nodeType !== 3 && node.previousSibling && node.previousSibling.nodeType !== 3 || node.textContent !== \" \") && tagName(node.parentNode) !== \"body\";\n}\nfunction resolveListItem(listNodeTagName, enabledListTypes) {\n  if (listNodeTagName === \"ul\" && enabledListTypes.includes(\"bullet\"))\n    return \"bullet\";\n  if (listNodeTagName === \"ol\" && enabledListTypes.includes(\"number\"))\n    return \"number\";\n}\nfunction createHTMLRules(_blockContentType, options) {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== \"pre\")\n          return;\n        const isCodeEnabled = options.enabledBlockStyles.includes(\"code\");\n        return {\n          _type: \"block\",\n          style: \"normal\",\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? [\"code\"] : [],\n              text: el.textContent || \"\"\n            }\n          ]\n        };\n      }\n    },\n    // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"blockquote\")\n          return;\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        };\n        delete blocks2.blockquote;\n        const nonBlockquoteBlocks = Object.keys(blocks2), children = [];\n        return el.childNodes.forEach((node, index) => {\n          if (el.ownerDocument)\n            if (node.nodeType === 1 && nonBlockquoteBlocks.includes(\n              node.localName.toLowerCase()\n            )) {\n              const span = el.ownerDocument.createElement(\"span\"), previousChild = children[children.length - 1];\n              previousChild && previousChild.nodeType === 3 && previousChild.textContent?.trim() && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), node.childNodes.forEach((cn) => {\n                span.appendChild(cn.cloneNode(!0));\n              }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), children.push(span);\n            } else\n              children.push(node);\n        }), {\n          _type: \"block\",\n          style: \"blockquote\",\n          markDefs: [],\n          children: next(children)\n        };\n      }\n    },\n    // Block elements\n    {\n      deserialize(el, next) {\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        }, tag = tagName(el);\n        let block = tag ? blocks2[tag] : void 0;\n        if (block)\n          return el.parentNode && tagName(el.parentNode) === \"li\" ? next(el.childNodes) : (options.enabledBlockStyles.includes(block.style) || (block = DEFAULT_BLOCK), {\n            ...block,\n            children: next(el.childNodes)\n          });\n      }\n    },\n    // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_SPAN_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Ignore div tags\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"div\")\n          return next(el.childNodes);\n      }\n    },\n    // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_LIST_CONTAINER_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\")\n          return {\n            ...DEFAULT_SPAN,\n            text: `\n`\n          };\n      }\n    },\n    // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el), listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = tagName(el.parentNode) || \"\";\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag])\n          return;\n        const enabledListItem = resolveListItem(\n          parentTag,\n          options.enabledListTypes\n        );\n        return enabledListItem ? (listItem.listItem = enabledListItem, {\n          ...listItem,\n          children: next(el.childNodes)\n        }) : block({ _type: \"block\", children: next(el.childNodes) });\n      }\n    },\n    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || \"\"];\n        if (!(!decorator || !options.enabledSpanDecorators.includes(decorator)))\n          return {\n            _type: \"__decorator\",\n            name: decorator,\n            children: next(el.childNodes)\n          };\n      }\n    },\n    // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"a\")\n          return;\n        const linkEnabled = options.enabledBlockAnnotations.includes(\"link\"), href = isElement(el) && el.getAttribute(\"href\");\n        if (!href)\n          return next(el.childNodes);\n        let markDef;\n        return linkEnabled ? (markDef = {\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n          _type: \"link\",\n          href\n        }, {\n          _type: \"__annotation\",\n          markDef,\n          children: next(el.childNodes)\n        }) : el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes);\n      }\n    }\n  ];\n}\nfunction isEmphasis(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style:italic/.test(style || \"\");\n}\nfunction isStrong(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight:700/.test(style || \"\") || /font-weight:600/.test(style || \"\");\n}\nfunction isUnderline(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration:underline/.test(style || \"\");\n}\nfunction isNotion(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-notion\");\n}\nfunction createNotionRules(_blockContentType) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong(el) && span.marks.push(\"strong\"), isUnderline(el) && span.marks.push(\"underline\"), isEmphasis(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    }\n  ];\n}\nfunction getListItemStyle(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (style && style.match(/lfo\\d+/))\n    return style.match(\"lfo1\") ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (!style)\n    return;\n  const levelMatch = style.match(/level\\d+/);\n  if (!levelMatch)\n    return;\n  const [level] = levelMatch[0].match(/\\d/) || [];\n  return (level ? Number.parseInt(level, 10) : 1) || 1;\n}\nfunction isWordListElement(el) {\n  return isElement(el) && el.className ? el.className === \"MsoListParagraphCxSpFirst\" || el.className === \"MsoListParagraphCxSpMiddle\" || el.className === \"MsoListParagraphCxSpLast\" : !1;\n}\nfunction createWordRules() {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"p\" && isWordListElement(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes)\n          };\n      }\n    }\n  ];\n}\nfunction createRules(blockContentType, options) {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options)\n  ];\n}\nclass HtmlDeserializer {\n  blockContentType;\n  rules;\n  parseHtml;\n  _markDefs = [];\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType, options = {}) {\n    const { rules = [], unstable_whitespaceOnPasteMode = \"preserve\" } = options;\n    if (!blockContentType)\n      throw new Error(\"Parameter 'blockContentType' is required\");\n    const standardRules = createRules(blockContentType, {\n      ...createRuleOptions(blockContentType),\n      keyGenerator: options.keyGenerator\n    });\n    this.rules = [...rules, ...standardRules];\n    const parseHtml = options.parseHtml || defaultParseHtml();\n    this.blockContentType = blockContentType, this.parseHtml = (html) => preprocess(html, parseHtml, { unstable_whitespaceOnPasteMode }).body;\n  }\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html) => {\n    this._markDefs = [];\n    const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = trimWhitespace(\n      flattenNestedBlocks(\n        ensureRootIsBlocks(this.deserializeElements(children))\n      )\n    );\n    this._markDefs.length > 0 && blocks2.filter(\n      (block) => block._type === \"block\"\n    ).forEach((block) => {\n      block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(\n        this._markDefs.filter((def) => lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__(\n          block.children.map((child) => child.marks || [])\n        ).includes(def._key))\n      );\n    });\n    const type = this.blockContentType.of.find(findBlockType);\n    return type ? blocks2.map((block) => (block._type === \"block\" && (block._type = type.name), block)) : blocks2;\n  };\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements = []) => {\n    let nodes = [];\n    return elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element));\n    }), nodes;\n  };\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element) => {\n    const next = (elements) => {\n      if (isNodeList(elements))\n        return this.deserializeElements(Array.from(elements));\n      if (Array.isArray(elements))\n        return this.deserializeElements(elements);\n      if (elements)\n        return this.deserializeElement(elements);\n    }, block = (props) => ({\n      _type: \"__block\",\n      block: props\n    });\n    let node;\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i];\n      if (!rule.deserialize)\n        continue;\n      const ret = rule.deserialize(element, next, block), type = resolveJsType(ret);\n      if (type !== \"array\" && type !== \"object\" && type !== \"null\" && type !== \"undefined\")\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`\n        );\n      if (ret !== void 0) {\n        {\n          if (ret === null)\n            throw new Error(\"Deserializer rule returned `null`\");\n          Array.isArray(ret) ? node = ret : isPlaceholderDecorator(ret) ? node = this.deserializeDecorator(ret) : isPlaceholderAnnotation(ret) ? node = this.deserializeAnnotation(ret) : node = ret;\n        }\n        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && \"listItem\" in ret) {\n          let parent = element.parentNode?.parentNode;\n          for (; parent && tagName(parent) === \"li\"; )\n            parent = parent.parentNode?.parentNode, ret.level = ret.level ? ret.level + 1 : 1;\n        }\n        ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === \"blockquote\" && ret.children.forEach((child, index) => {\n          isMinimalSpan(child) && child.text === \"\\r\" && (child.text = `\n`, (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));\n        });\n        break;\n      }\n    }\n    return node || next(element.childNodes) || [];\n  };\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator) => {\n    const { name } = decorator, applyDecorator = (node) => {\n      if (isPlaceholderDecorator(node))\n        return this.deserializeDecorator(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyDecorator);\n      }\n      return node;\n    };\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation) => {\n    const { markDef } = annotation;\n    this._markDefs.push(markDef);\n    const applyAnnotation = (node) => {\n      if (isPlaceholderAnnotation(node))\n        return this.deserializeAnnotation(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyAnnotation);\n      }\n      return node;\n    };\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n}\nfunction normalizeBlock(node, options = {}) {\n  if (node._type !== (options.blockTypeName || \"block\"))\n    return \"_key\" in node ? node : {\n      ...node,\n      _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()\n    };\n  const block = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node\n  }, lastChild = block.children[block.children.length - 1];\n  if (!lastChild)\n    return block.children = [\n      {\n        _type: \"span\",\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: \"\",\n        marks: []\n      }\n    ], block;\n  const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;\n  return block.children = block.children.reduce(\n    (acc, child) => {\n      const previousChild = acc[acc.length - 1];\n      return previousChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(previousChild) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === \"\" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);\n    },\n    []\n  ).map((child) => {\n    if (!child)\n      throw new Error(\"missing child\");\n    return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark) => {\n      const isAllowed = allowedDecorators.includes(mark), isUsed = block.markDefs?.some((def) => def._key === mark);\n      return isAllowed || isUsed;\n    })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;\n  }), block.markDefs = (block.markDefs || []).filter(\n    (markDef) => usedMarkDefs.includes(markDef._key)\n  ), block;\n}\nfunction htmlToBlocks(html, blockContentType, options = {}) {\n  return new HtmlDeserializer(blockContentType, options).deserialize(html).map((block) => normalizeBlock(block, { keyGenerator: options.keyGenerator }));\n}\nfunction getBlockContentFeatures(blockContentType) {\n  return blockContentFeatures(blockContentType);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9ibG9jay10b29scy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzJLO0FBQzNLO0FBQ047QUFDa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpS0FBaUssUUFBUTtBQUNuTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQyxFQUFFLGdCQUFnQixZQUFZLHNCQUFzQixFQUFFLEVBQUUsR0FBRztBQUN2RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQjtBQUNoQixDQUFDO0FBQ0QsVUFBVTtBQUNWLENBQUM7QUFDRCxRQUFRLGNBQWM7QUFDdEIsUUFBUTtBQUNSLENBQUM7QUFDRCxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRO0FBQ1IsQ0FBQztBQUNELFFBQVE7QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQWlCO0FBQ3hCO0FBQ0EsdUNBQXVDLHFFQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpRUFBa0I7QUFDcEU7QUFDQSwwREFBMEQsaUVBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrRUFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlDQUFpQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRUFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0VBQWlCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNFQUF1QjtBQUNsRSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwwbkJBQTBuQiw4Q0FBTyx5SUFBeUksOENBQU8sd0ZBQXdGLGVBQWU7QUFDeDNCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRUFBdUIscUJBQXFCLHNFQUF1QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpRUFBZTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZLCtDQUErQztBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBd0QsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLDBEQUEwRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1R0FBdUcsZ0NBQWdDO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhDQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBa0IsV0FBVyxpRUFBa0IsbUJBQW1CLDhDQUFPO0FBQ3ZHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixpRUFBa0I7QUFDMUc7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGtIQUFrSCxvQ0FBb0M7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFudGVjLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvYmxvY2stdG9vbHMvbGliL2luZGV4LmpzP2ZiOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZsYXR0ZW4gZnJvbSBcImxvZGFzaC9mbGF0dGVuLmpzXCI7XG5pbXBvcnQgeyBpc0Jsb2NrU2NoZW1hVHlwZSwgaXNCbG9ja0NoaWxkcmVuT2JqZWN0RmllbGQsIGlzT2JqZWN0U2NoZW1hVHlwZSwgaXNCbG9ja0xpc3RPYmplY3RGaWVsZCwgaXNCbG9ja1N0eWxlT2JqZWN0RmllbGQsIGlzVGl0bGVkTGlzdFZhbHVlLCBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCBpc0VxdWFsIGZyb20gXCJsb2Rhc2gvaXNFcXVhbC5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgZ2V0UmFuZG9tVmFsdWVzIGZyb20gXCJnZXQtcmFuZG9tLXZhbHVlcy1lc21cIjtcbmZ1bmN0aW9uIGZpbmRCbG9ja1R5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZS50eXBlID8gZmluZEJsb2NrVHlwZSh0eXBlLnR5cGUpIDogdHlwZS5uYW1lID09PSBcImJsb2NrXCI7XG59XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiByZXNvbHZlSnNUeXBlKHZhbCkge1xuICBzd2l0Y2ggKG9iamVjdFRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIGNhc2UgXCJbb2JqZWN0IEZ1bmN0aW9uXVwiOlxuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICBjYXNlIFwiW29iamVjdCBEYXRlXVwiOlxuICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjpcbiAgICAgIHJldHVybiBcInJlZ2V4cFwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IEFyZ3VtZW50c11cIjpcbiAgICAgIHJldHVybiBcImFyZ3VtZW50c1wiO1xuICAgIGNhc2UgXCJbb2JqZWN0IEFycmF5XVwiOlxuICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuICByZXR1cm4gdmFsID09PSBudWxsID8gXCJudWxsXCIgOiB2YWwgPT09IHZvaWQgMCA/IFwidW5kZWZpbmVkXCIgOiB2YWwgJiYgdHlwZW9mIHZhbCA9PSBcIm9iamVjdFwiICYmIFwibm9kZVR5cGVcIiBpbiB2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxID8gXCJlbGVtZW50XCIgOiB2YWwgPT09IE9iamVjdCh2YWwpID8gXCJvYmplY3RcIiA6IHR5cGVvZiB2YWw7XG59XG52YXIgcyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogODI5MCwgNDogODI5MSwgNTogODI4OCwgNjogNjUyNzksIDc6IDgyODksIDg6IDExOTE1NSwgOTogMTE5MTU2LCBhOiAxMTkxNTcsIGI6IDExOTE1OCwgYzogMTE5MTU5LCBkOiAxMTkxNjAsIGU6IDExOTE2MSwgZjogMTE5MTYyIH0sIGMgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDY1Mjc5IH07XG5uZXcgQXJyYXkoNCkuZmlsbChTdHJpbmcuZnJvbUNvZGVQb2ludChjWzBdKSkuam9pbihcIlwiKTtcbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocykubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpO1xudmFyIFMgPSBgJHtPYmplY3QudmFsdWVzKHMpLm1hcCgodCkgPT4gYFxcXFx1eyR7dC50b1N0cmluZygxNil9fWApLmpvaW4oXCJcIil9YCwgZiA9IG5ldyBSZWdFeHAoYFske1N9XXs0LH1gLCBcImd1XCIpO1xuZnVuY3Rpb24gXyh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4geyBjbGVhbmVkOiB0LnJlcGxhY2UoZiwgXCJcIiksIGVuY29kZWQ6ICgoZSA9IHQubWF0Y2goZikpID09IG51bGwgPyB2b2lkIDAgOiBlWzBdKSB8fCBcIlwiIH07XG59XG5mdW5jdGlvbiBPKHQpIHtcbiAgcmV0dXJuIHQgJiYgSlNPTi5wYXJzZShfKEpTT04uc3RyaW5naWZ5KHQpKS5jbGVhbmVkKTtcbn1cbmNvbnN0IFBSRVNFUlZFX1dISVRFU1BBQ0VfVEFHUyA9IFtcInByZVwiLCBcInRleHRhcmVhXCIsIFwiY29kZVwiXSwgQkxPQ0tfREVGQVVMVF9TVFlMRSA9IFwibm9ybWFsXCIsIERFRkFVTFRfQkxPQ0sgPSBPYmplY3QuZnJlZXplKHtcbiAgX3R5cGU6IFwiYmxvY2tcIixcbiAgbWFya0RlZnM6IFtdLFxuICBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRVxufSksIERFRkFVTFRfU1BBTiA9IE9iamVjdC5mcmVlemUoe1xuICBfdHlwZTogXCJzcGFuXCIsXG4gIG1hcmtzOiBbXVxufSksIEhUTUxfQkxPQ0tfVEFHUyA9IHtcbiAgcDogREVGQVVMVF9CTE9DSyxcbiAgYmxvY2txdW90ZTogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJibG9ja3F1b3RlXCIgfVxufSwgSFRNTF9TUEFOX1RBR1MgPSB7XG4gIHNwYW46IHsgb2JqZWN0OiBcInRleHRcIiB9XG59LCBIVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MgPSB7XG4gIG9sOiB7IG9iamVjdDogbnVsbCB9LFxuICB1bDogeyBvYmplY3Q6IG51bGwgfVxufSwgSFRNTF9IRUFERVJfVEFHUyA9IHtcbiAgaDE6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDFcIiB9LFxuICBoMjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoMlwiIH0sXG4gIGgzOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImgzXCIgfSxcbiAgaDQ6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDRcIiB9LFxuICBoNTogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoNVwiIH0sXG4gIGg2OiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImg2XCIgfVxufSwgSFRNTF9NSVNDX1RBR1MgPSB7XG4gIGJyOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBCTE9DS19ERUZBVUxUX1NUWUxFIH1cbn0sIEhUTUxfREVDT1JBVE9SX1RBR1MgPSB7XG4gIGI6IFwic3Ryb25nXCIsXG4gIHN0cm9uZzogXCJzdHJvbmdcIixcbiAgaTogXCJlbVwiLFxuICBlbTogXCJlbVwiLFxuICB1OiBcInVuZGVybGluZVwiLFxuICBzOiBcInN0cmlrZS10aHJvdWdoXCIsXG4gIHN0cmlrZTogXCJzdHJpa2UtdGhyb3VnaFwiLFxuICBkZWw6IFwic3RyaWtlLXRocm91Z2hcIixcbiAgY29kZTogXCJjb2RlXCIsXG4gIHN1cDogXCJzdXBcIixcbiAgc3ViOiBcInN1YlwiLFxuICBpbnM6IFwiaW5zXCIsXG4gIG1hcms6IFwibWFya1wiLFxuICBzbWFsbDogXCJzbWFsbFwiXG59LCBIVE1MX0xJU1RfSVRFTV9UQUdTID0ge1xuICBsaToge1xuICAgIC4uLkRFRkFVTFRfQkxPQ0ssXG4gICAgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEUsXG4gICAgbGV2ZWw6IDEsXG4gICAgbGlzdEl0ZW06IFwiYnVsbGV0XCJcbiAgfVxufSwgRUxFTUVOVF9NQVAgPSB7XG4gIC4uLkhUTUxfQkxPQ0tfVEFHUyxcbiAgLi4uSFRNTF9TUEFOX1RBR1MsXG4gIC4uLkhUTUxfTElTVF9DT05UQUlORVJfVEFHUyxcbiAgLi4uSFRNTF9MSVNUX0lURU1fVEFHUyxcbiAgLi4uSFRNTF9IRUFERVJfVEFHUyxcbiAgLi4uSFRNTF9NSVNDX1RBR1Ncbn07XG51bmlxKFxuICBPYmplY3QudmFsdWVzKEVMRU1FTlRfTUFQKS5maWx0ZXIoKHRhZykgPT4gXCJzdHlsZVwiIGluIHRhZykubWFwKCh0YWcpID0+IHRhZy5zdHlsZSlcbik7XG51bmlxKFxuICBPYmplY3QudmFsdWVzKEhUTUxfREVDT1JBVE9SX1RBR1MpXG4pO1xuZnVuY3Rpb24gYmxvY2tDb250ZW50RmVhdHVyZXMoYmxvY2tDb250ZW50VHlwZSkge1xuICBpZiAoIWJsb2NrQ29udGVudFR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyICdibG9ja0NvbnRlbnRUeXBlJyByZXF1aXJlZFwiKTtcbiAgY29uc3QgYmxvY2tUeXBlID0gYmxvY2tDb250ZW50VHlwZS5vZi5maW5kKGZpbmRCbG9ja1R5cGUpO1xuICBpZiAoIWlzQmxvY2tTY2hlbWFUeXBlKGJsb2NrVHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiJ2Jsb2NrJyB0eXBlIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgc2NoZW1hIChyZXF1aXJlZCkuXCIpO1xuICBjb25zdCBvZlR5cGUgPSBibG9ja1R5cGUuZmllbGRzLmZpbmQoaXNCbG9ja0NoaWxkcmVuT2JqZWN0RmllbGQpPy50eXBlPy5vZjtcbiAgaWYgKCFvZlR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYG9mYCBkZWNsYXJhdGlvbiBmb3VuZCBmb3IgYmxvY2tzIGBjaGlsZHJlbmAgZmllbGRcIik7XG4gIGNvbnN0IHNwYW5UeXBlID0gb2ZUeXBlLmZpbmQoXG4gICAgKG1lbWJlcikgPT4gbWVtYmVyLm5hbWUgPT09IFwic3BhblwiXG4gICk7XG4gIGlmICghc3BhblR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJObyBgc3BhbmAgdHlwZSBmb3VuZCBpbiBgYmxvY2tgIHNjaGVtYSB0eXBlIGBjaGlsZHJlbmAgZGVmaW5pdGlvblwiXG4gICAgKTtcbiAgY29uc3QgaW5saW5lT2JqZWN0VHlwZXMgPSBvZlR5cGUuZmlsdGVyKFxuICAgIChpbmxpbmVUeXBlKSA9PiBpbmxpbmVUeXBlLm5hbWUgIT09IFwic3BhblwiICYmIGlzT2JqZWN0U2NoZW1hVHlwZShpbmxpbmVUeXBlKVxuICApLCBibG9ja09iamVjdFR5cGVzID0gYmxvY2tDb250ZW50VHlwZS5vZi5maWx0ZXIoXG4gICAgKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSAhPT0gYmxvY2tUeXBlLm5hbWUgJiYgaXNPYmplY3RTY2hlbWFUeXBlKG1lbWJlclR5cGUpXG4gICk7XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpLFxuICAgIGRlY29yYXRvcnM6IHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSksXG4gICAgYW5ub3RhdGlvbnM6IHJlc29sdmVFbmFibGVkQW5ub3RhdGlvblR5cGVzKHNwYW5UeXBlKSxcbiAgICBsaXN0czogcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSxcbiAgICB0eXBlczoge1xuICAgICAgYmxvY2s6IGJsb2NrQ29udGVudFR5cGUsXG4gICAgICBzcGFuOiBzcGFuVHlwZSxcbiAgICAgIGlubGluZU9iamVjdHM6IGlubGluZU9iamVjdFR5cGVzLFxuICAgICAgYmxvY2tPYmplY3RzOiBibG9ja09iamVjdFR5cGVzXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IHN0eWxlRmllbGQgPSBibG9ja1R5cGUuZmllbGRzLmZpbmQoaXNCbG9ja1N0eWxlT2JqZWN0RmllbGQpO1xuICBpZiAoIXN0eWxlRmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBIGZpZWxkIHdpdGggbmFtZSAnc3R5bGUnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBibG9jayB0eXBlIChyZXF1aXJlZCkuXCJcbiAgICApO1xuICBjb25zdCB0ZXh0U3R5bGVzID0gZ2V0VGl0bGVkTGlzdFZhbHVlc0Zyb21FbnVtTGlzdE9wdGlvbnMoXG4gICAgc3R5bGVGaWVsZC50eXBlLm9wdGlvbnNcbiAgKTtcbiAgaWYgKHRleHRTdHlsZXMubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIHN0eWxlIGZpZWxkcyBuZWVkIGF0IGxlYXN0IG9uZSBzdHlsZSBkZWZpbmVkLiBJLmU6IHt0aXRsZTogJ05vcm1hbCcsIHZhbHVlOiAnbm9ybWFsJ30uXCJcbiAgICApO1xuICByZXR1cm4gdGV4dFN0eWxlcztcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkQW5ub3RhdGlvblR5cGVzKHNwYW5UeXBlKSB7XG4gIHJldHVybiBzcGFuVHlwZS5hbm5vdGF0aW9ucy5tYXAoKGFubm90YXRpb24pID0+ICh7XG4gICAgdGl0bGU6IGFubm90YXRpb24udGl0bGUsXG4gICAgdHlwZTogYW5ub3RhdGlvbixcbiAgICB2YWx1ZTogYW5ub3RhdGlvbi5uYW1lLFxuICAgIGljb246IGFubm90YXRpb24uaWNvblxuICB9KSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpIHtcbiAgcmV0dXJuIHNwYW5UeXBlLmRlY29yYXRvcnM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpIHtcbiAgY29uc3QgbGlzdEZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcy5maW5kKGlzQmxvY2tMaXN0T2JqZWN0RmllbGQpO1xuICBpZiAoIWxpc3RGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkEgZmllbGQgd2l0aCBuYW1lICdsaXN0JyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiXG4gICAgKTtcbiAgY29uc3QgbGlzdEl0ZW1zID0gZ2V0VGl0bGVkTGlzdFZhbHVlc0Zyb21FbnVtTGlzdE9wdGlvbnMoXG4gICAgbGlzdEZpZWxkLnR5cGUub3B0aW9uc1xuICApO1xuICBpZiAoIWxpc3RJdGVtcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGlzdCBmaWVsZCBuZWVkIGF0IGxlYXN0IHRvIGJlIGFuIGVtcHR5IGFycmF5XCIpO1xuICByZXR1cm4gbGlzdEl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0VGl0bGVkTGlzdFZhbHVlc0Zyb21FbnVtTGlzdE9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBsaXN0ID0gb3B0aW9ucyA/IG9wdGlvbnMubGlzdCA6IHZvaWQgMDtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0Lm1hcChcbiAgICAoaXRlbSkgPT4gaXNUaXRsZWRMaXN0VmFsdWUoaXRlbSkgPyBpdGVtIDogeyB0aXRsZTogaXRlbSwgdmFsdWU6IGl0ZW0gfVxuICApIDogW107XG59XG5jb25zdCBfWFBhdGhSZXN1bHQgPSB7XG4gIEJPT0xFQU5fVFlQRTogMyxcbiAgT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEU6IDUsXG4gIFVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU6IDZcbn07XG52YXIgcHJlcHJvY2Vzc0dEb2NzID0gKF9odG1sLCBkb2MsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgd2hpdGVzcGFjZU9uUGFzdGVNb2RlID0gb3B0aW9ucz8udW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlIHx8IFwicHJlc2VydmVcIjtcbiAgbGV0IGdEb2NzUm9vdE9yU2libGluZ05vZGUgPSBkb2MuZXZhbHVhdGUoXG4gICAgJy8vKltAaWQgYW5kIGNvbnRhaW5zKEBpZCwgXCJkb2NzLWludGVybmFsLWd1aWRcIildJyxcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsXG4gICAgbnVsbFxuICApLml0ZXJhdGVOZXh0KCk7XG4gIGlmIChnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKSB7XG4gICAgY29uc3QgaXNXcmFwcGVkUm9vdFRhZyA9IHRhZ05hbWUoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSkgPT09IFwiYlwiO1xuICAgIHN3aXRjaCAoaXNXcmFwcGVkUm9vdFRhZyB8fCAoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSA9IGRvYy5ib2R5KSwgd2hpdGVzcGFjZU9uUGFzdGVNb2RlKSB7XG4gICAgICBjYXNlIFwibm9ybWFsaXplXCI6XG4gICAgICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2UoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICByZW1vdmVBbGxXaGl0ZXNwYWNlKGdEb2NzUm9vdE9yU2libGluZ05vZGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICAgIFwiLy8qXCIsXG4gICAgICBkb2MsXG4gICAgICBudWxsLFxuICAgICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gY2hpbGROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlbG0gPSBjaGlsZE5vZGVzLnNuYXBzaG90SXRlbShpKTtcbiAgICAgIGVsbT8uc2V0QXR0cmlidXRlKFwiZGF0YS1pcy1nb29nbGUtZG9jc1wiLCBcInRydWVcIiksIChlbG0/LnBhcmVudEVsZW1lbnQgPT09IGdEb2NzUm9vdE9yU2libGluZ05vZGUgfHwgIWlzV3JhcHBlZFJvb3RUYWcgJiYgZWxtLnBhcmVudEVsZW1lbnQgPT09IGRvYy5ib2R5KSAmJiAoZWxtPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLXJvb3Qtbm9kZVwiLCBcInRydWVcIiksIHRhZ05hbWUoZWxtKSksIHRhZ05hbWUoZWxtKSA9PT0gXCJsaVwiICYmIGVsbS5maXJzdENoaWxkICYmIHRhZ05hbWUoZWxtPy5maXJzdENoaWxkKSA9PT0gXCJpbWdcIiAmJiBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gaXNXcmFwcGVkUm9vdFRhZyAmJiBkb2MuYm9keS5maXJzdEVsZW1lbnRDaGlsZD8ucmVwbGFjZVdpdGgoXG4gICAgICAuLi5BcnJheS5mcm9tKGdEb2NzUm9vdE9yU2libGluZ05vZGUuY2hpbGROb2RlcylcbiAgICApLCBkb2M7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn07XG5jb25zdCB1bndhbnRlZFdvcmREb2N1bWVudFBhdGhzID0gW1xuICBcIi9odG1sL3RleHQoKVwiLFxuICBcIi9odG1sL2hlYWQvdGV4dCgpXCIsXG4gIFwiL2h0bWwvYm9keS90ZXh0KClcIixcbiAgXCIvaHRtbC9ib2R5L3VsL3RleHQoKVwiLFxuICBcIi9odG1sL2JvZHkvb2wvdGV4dCgpXCIsXG4gIFwiLy9jb21tZW50KClcIixcbiAgXCIvL3N0eWxlXCIsXG4gIFwiLy94bWxcIixcbiAgXCIvL3NjcmlwdFwiLFxuICBcIi8vbWV0YVwiLFxuICBcIi8vbGlua1wiXG5dO1xudmFyIHByZXByb2Nlc3NIVE1MID0gKF9odG1sLCBkb2MpID0+IHtcbiAgY29uc3QgYm9keVRleHROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICBcIi9odG1sL2JvZHkvdGV4dCgpXCIsXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gYm9keVRleHROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgbm9kZSA9IGJvZHlUZXh0Tm9kZXMuc25hcHNob3RJdGVtKGkpLCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCBcIlwiO1xuICAgIGlmICh0ZXh0LnJlcGxhY2UoL1teXFxTXFxuXSskL2csIFwiXCIpKSB7XG4gICAgICBjb25zdCBuZXdOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCkpLCBub2RlLnBhcmVudE5vZGU/LnJlcGxhY2VDaGlsZChuZXdOb2RlLCBub2RlKTtcbiAgICB9IGVsc2VcbiAgICAgIG5vZGUucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbiAgY29uc3QgdW53YW50ZWROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICB1bndhbnRlZFdvcmREb2N1bWVudFBhdGhzLmpvaW4oXCJ8XCIpLFxuICAgIGRvYyxcbiAgICBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgIG51bGxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IHVud2FudGVkTm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHVud2FudGVkID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk7XG4gICAgdW53YW50ZWQgJiYgdW53YW50ZWQucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodW53YW50ZWQpO1xuICB9XG4gIHJldHVybiBkb2M7XG59LCBwcmVwcm9jZXNzTm90aW9uID0gKGh0bWwsIGRvYykgPT4ge1xuICBjb25zdCBOT1RJT05fUkVHRVggPSAvPCEtLSBub3Rpb252YzouKj8tLT4vZztcbiAgaWYgKGh0bWwubWF0Y2goTk9USU9OX1JFR0VYKSkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgICBcIi8vKlwiLFxuICAgICAgZG9jLFxuICAgICAgbnVsbCxcbiAgICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkTm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGNoaWxkTm9kZXMuc25hcHNob3RJdGVtKGkpPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLW5vdGlvblwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICByZXR1cm4gZG9jO1xufSwgcHJlcHJvY2Vzc1doaXRlc3BhY2UgPSAoXzIsIGRvYykgPT4ge1xuICBmdW5jdGlvbiBwcm9jZXNzTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IF9YUGF0aFJlc3VsdC5CT09MRUFOX1RZUEUgJiYgIVBSRVNFUlZFX1dISVRFU1BBQ0VfVEFHUy5pbmNsdWRlcyhcbiAgICAgIG5vZGUucGFyZW50RWxlbWVudD8udGFnTmFtZS50b0xvd2VyQ2FzZSgpIHx8IFwiXCJcbiAgICApKVxuICAgICAgbm9kZS50ZXh0Q29udGVudCA9IG5vZGUudGV4dENvbnRlbnQ/LnJlcGxhY2UoL1xcc1xccysvZywgXCIgXCIpLnJlcGxhY2UoL1tcXHJcXG5dKy9nLCBcIiBcIikgfHwgXCJcIjtcbiAgICBlbHNlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcHJvY2Vzc05vZGUobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcHJvY2Vzc05vZGUoZG9jLmJvZHkpLCBkb2M7XG59O1xuY29uc3QgV09SRF9IVE1MX1JFR0VYID0gLyhjbGFzcz1cIj9Nc298c3R5bGU9KD86XCJ8JylbXlwiXSo/XFxibXNvLXx3OldvcmREb2N1bWVudHw8bzpcXHcrPnw8XFwvZm9udD4pLywgdW53YW50ZWRQYXRocyA9IFtcbiAgXCIvL286cFwiLFxuICBcIi8vc3BhbltAc3R5bGU9J21zby1saXN0Oklnbm9yZSddXCIsXG4gIFwiLy9zcGFuW0BzdHlsZT0nbXNvLWxpc3Q6IElnbm9yZSddXCJcbl0sIG1hcHBlZFBhdGhzID0gW1xuICBcIi8vcFtAY2xhc3M9J01zb1RvY0hlYWRpbmcnXVwiLFxuICBcIi8vcFtAY2xhc3M9J01zb1RpdGxlJ11cIixcbiAgXCIvL3BbQGNsYXNzPSdNc29Ub2FIZWFkaW5nJ11cIixcbiAgXCIvL3BbQGNsYXNzPSdNc29TdWJ0aXRsZSddXCIsXG4gIFwiLy9zcGFuW0BjbGFzcz0nTXNvU3VidGxlRW1waGFzaXMnXVwiLFxuICBcIi8vc3BhbltAY2xhc3M9J01zb0ludGVuc2VFbXBoYXNpcyddXCJcbl0sIGVsZW1lbnRNYXAgPSB7XG4gIE1zb1RvY0hlYWRpbmc6IFtcImgzXCJdLFxuICBNc29UaXRsZTogW1wiaDFcIl0sXG4gIE1zb1RvYUhlYWRpbmc6IFtcImgyXCJdLFxuICBNc29TdWJ0aXRsZTogW1wiaDVcIl0sXG4gIE1zb1N1YnRsZUVtcGhhc2lzOiBbXCJzcGFuXCIsIFwiZW1cIl0sXG4gIE1zb0ludGVuc2VFbXBoYXNpczogW1wic3BhblwiLCBcImVtXCIsIFwic3Ryb25nXCJdXG4gIC8vIFJlbW92ZSBjcnVmdFxufTtcbmZ1bmN0aW9uIGlzV29yZEh0bWwoaHRtbCkge1xuICByZXR1cm4gV09SRF9IVE1MX1JFR0VYLnRlc3QoaHRtbCk7XG59XG52YXIgcHJlcHJvY2Vzc1dvcmQgPSAoaHRtbCwgZG9jKSA9PiB7XG4gIGlmICghaXNXb3JkSHRtbChodG1sKSlcbiAgICByZXR1cm4gZG9jO1xuICBjb25zdCB1bndhbnRlZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgIHVud2FudGVkUGF0aHMuam9pbihcInxcIiksXG4gICAgZG9jLFxuICAgIChwcmVmaXgpID0+IHByZWZpeCA9PT0gXCJvXCIgPyBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZVwiIDogbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB1bndhbnRlZCA9IHVud2FudGVkTm9kZXMuc25hcHNob3RJdGVtKGkpO1xuICAgIHVud2FudGVkPy5wYXJlbnROb2RlICYmIHVud2FudGVkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodW53YW50ZWQpO1xuICB9XG4gIGNvbnN0IG1hcHBlZEVsZW1lbnRzID0gZG9jLmV2YWx1YXRlKFxuICAgIG1hcHBlZFBhdGhzLmpvaW4oXCJ8XCIpLFxuICAgIGRvYyxcbiAgICBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgIG51bGxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IG1hcHBlZEVsZW1lbnRzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBtYXBwZWRFbG0gPSBtYXBwZWRFbGVtZW50cy5zbmFwc2hvdEl0ZW0oaSksIHRhZ3MgPSBlbGVtZW50TWFwW21hcHBlZEVsbS5jbGFzc05hbWVdLCB0ZXh0ID0gZG9jLmNyZWF0ZVRleHROb2RlKG1hcHBlZEVsbS50ZXh0Q29udGVudCB8fCBcIlwiKTtcbiAgICBpZiAoIXRhZ3MpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnc1swXSk7XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudEVsZW1lbnQsIGNoaWxkID0gcGFyZW50RWxlbWVudDtcbiAgICB0YWdzLnNsaWNlKDEpLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgY2hpbGQgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpLCBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpLCBwYXJlbnQgPSBjaGlsZDtcbiAgICB9KSwgY2hpbGQuYXBwZW5kQ2hpbGQodGV4dCksIG1hcHBlZEVsbT8ucGFyZW50Tm9kZT8ucmVwbGFjZUNoaWxkKHBhcmVudEVsZW1lbnQsIG1hcHBlZEVsbSk7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn0sIHByZXByb2Nlc3NvcnMgPSBbXG4gIHByZXByb2Nlc3NXaGl0ZXNwYWNlLFxuICBwcmVwcm9jZXNzTm90aW9uLFxuICBwcmVwcm9jZXNzV29yZCxcbiAgcHJlcHJvY2Vzc0dEb2NzLFxuICBwcmVwcm9jZXNzSFRNTFxuXTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bGVPcHRpb25zKGJsb2NrQ29udGVudFR5cGUpIHtcbiAgY29uc3QgZmVhdHVyZXMgPSBibG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKSwgZW5hYmxlZEJsb2NrU3R5bGVzID0gZmVhdHVyZXMuc3R5bGVzLm1hcChcbiAgICAoaXRlbSkgPT4gaXRlbS52YWx1ZSB8fCBpdGVtLnRpdGxlXG4gICksIGVuYWJsZWRTcGFuRGVjb3JhdG9ycyA9IGZlYXR1cmVzLmRlY29yYXRvcnMubWFwKFxuICAgIChpdGVtKSA9PiBpdGVtLnZhbHVlIHx8IGl0ZW0udGl0bGVcbiAgKSwgZW5hYmxlZEJsb2NrQW5ub3RhdGlvbnMgPSBmZWF0dXJlcy5hbm5vdGF0aW9ucy5tYXAoXG4gICAgKGl0ZW0pID0+IGl0ZW0udmFsdWUgfHwgaXRlbS50aXRsZSB8fCBcIlwiXG4gICksIGVuYWJsZWRMaXN0VHlwZXMgPSBmZWF0dXJlcy5saXN0cy5tYXAoXG4gICAgKGl0ZW0pID0+IGl0ZW0udmFsdWUgfHwgaXRlbS50aXRsZSB8fCBcIlwiXG4gICk7XG4gIHJldHVybiB7XG4gICAgZW5hYmxlZEJsb2NrU3R5bGVzLFxuICAgIGVuYWJsZWRTcGFuRGVjb3JhdG9ycyxcbiAgICBlbmFibGVkQmxvY2tBbm5vdGF0aW9ucyxcbiAgICBlbmFibGVkTGlzdFR5cGVzXG4gIH07XG59XG5mdW5jdGlvbiB0YWdOYW1lKGVsKSB7XG4gIGlmIChlbCAmJiBcInRhZ05hbWVcIiBpbiBlbClcbiAgICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcHJlcHJvY2VzcyhodG1sLCBwYXJzZUh0bWwsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2xlYW5IVE1MID0gTyhodG1sKSwgZG9jID0gcGFyc2VIdG1sKG5vcm1hbGl6ZUh0bWxCZWZvcmVQcmVwcm9jZXNzKGNsZWFuSFRNTCkpO1xuICByZXR1cm4gcHJlcHJvY2Vzc29ycy5mb3JFYWNoKChwcm9jZXNzb3IpID0+IHtcbiAgICBwcm9jZXNzb3IoY2xlYW5IVE1MLCBkb2MsIG9wdGlvbnMpO1xuICB9KSwgZG9jO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSHRtbEJlZm9yZVByZXByb2Nlc3MoaHRtbCkge1xuICByZXR1cm4gaHRtbC50cmltKCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UGFyc2VIdG1sKCkge1xuICBpZiAocmVzb2x2ZUpzVHlwZShET01QYXJzZXIpID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIG5hdGl2ZSBgRE9NUGFyc2VyYCBnbG9iYWwgd2hpY2ggdGhlIGBIdG1sYCBkZXNlcmlhbGl6ZXIgdXNlcyBieSBkZWZhdWx0IGlzIG5vdCBwcmVzZW50IGluIHRoaXMgZW52aXJvbm1lbnQuIFlvdSBtdXN0IHN1cHBseSB0aGUgYG9wdGlvbnMucGFyc2VIdG1sYCBmdW5jdGlvbiBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgcmV0dXJuIChodG1sKSA9PiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsIFwidGV4dC9odG1sXCIpO1xufVxuZnVuY3Rpb24gZmxhdHRlbk5lc3RlZEJsb2NrcyhibG9ja3MyKSB7XG4gIGxldCBkZXB0aCA9IDA7XG4gIGNvbnN0IGZsYXR0ZW5lZCA9IFtdLCB0cmF2ZXJzZSA9IChub2RlcykgPT4ge1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gW107XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgZGVwdGggPT09IDAgJiYgZmxhdHRlbmVkLnB1c2gobm9kZSksIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5vZGUpICYmIChkZXB0aCA+IDAgJiYgKHRvUmVtb3ZlLnB1c2gobm9kZSksIGZsYXR0ZW5lZC5wdXNoKG5vZGUpKSwgZGVwdGgrKywgdHJhdmVyc2Uobm9kZS5jaGlsZHJlbikpLCBub2RlLl90eXBlID09PSBcIl9fYmxvY2tcIiAmJiAodG9SZW1vdmUucHVzaChub2RlKSwgZmxhdHRlbmVkLnB1c2gobm9kZS5ibG9jaykpO1xuICAgIH0pLCB0b1JlbW92ZS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2Rlcy5zcGxpY2Uobm9kZXMuaW5kZXhPZihub2RlKSwgMSk7XG4gICAgfSksIGRlcHRoLS07XG4gIH07XG4gIHJldHVybiB0cmF2ZXJzZShibG9ja3MyKSwgZmxhdHRlbmVkO1xufVxuZnVuY3Rpb24gbmV4dFNwYW4oYmxvY2ssIGluZGV4KSB7XG4gIGNvbnN0IG5leHQgPSBibG9jay5jaGlsZHJlbltpbmRleCArIDFdO1xuICByZXR1cm4gbmV4dCAmJiBuZXh0Ll90eXBlID09PSBcInNwYW5cIiA/IG5leHQgOiBudWxsO1xufVxuZnVuY3Rpb24gcHJldlNwYW4oYmxvY2ssIGluZGV4KSB7XG4gIGNvbnN0IHByZXYgPSBibG9jay5jaGlsZHJlbltpbmRleCAtIDFdO1xuICByZXR1cm4gcHJldiAmJiBwcmV2Ll90eXBlID09PSBcInNwYW5cIiA/IHByZXYgOiBudWxsO1xufVxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlQ2hhcih0ZXh0KSB7XG4gIHJldHVybiBbXCJcXHhBMFwiLCBcIiBcIl0uaW5jbHVkZXModGV4dCk7XG59XG5mdW5jdGlvbiB0cmltV2hpdGVzcGFjZShibG9ja3MyKSB7XG4gIHJldHVybiBibG9ja3MyLmZvckVhY2goKGJsb2NrKSA9PiB7XG4gICAgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc01pbmltYWxTcGFuKGNoaWxkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dFNwYW4oYmxvY2ssIGluZGV4KSwgcHJldkNoaWxkID0gcHJldlNwYW4oYmxvY2ssIGluZGV4KTtcbiAgICAgIGluZGV4ID09PSAwICYmIChjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9eW15cXFNcXG5dKy9nLCBcIlwiKSksIGluZGV4ID09PSBibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxICYmIChjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9bXlxcU1xcbl0rJC9nLCBcIlwiKSksIC9cXHMvLnRlc3QoY2hpbGQudGV4dC5zbGljZShNYXRoLm1heCgwLCBjaGlsZC50ZXh0Lmxlbmd0aCAtIDEpKSkgJiYgbmV4dENoaWxkICYmIGlzTWluaW1hbFNwYW4obmV4dENoaWxkKSAmJiAvXFxzLy50ZXN0KG5leHRDaGlsZC50ZXh0LnNsaWNlKDAsIDEpKSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvW15cXFNcXG5dKyQvZywgXCJcIikpLCAvXFxzLy50ZXN0KGNoaWxkLnRleHQuc2xpY2UoMCwgMSkpICYmIHByZXZDaGlsZCAmJiBpc01pbmltYWxTcGFuKHByZXZDaGlsZCkgJiYgL1xccy8udGVzdChwcmV2Q2hpbGQudGV4dC5zbGljZShNYXRoLm1heCgwLCBwcmV2Q2hpbGQudGV4dC5sZW5ndGggLSAxKSkpICYmIChjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9eW15cXFNcXG5dKy9nLCBcIlwiKSksIGNoaWxkLnRleHQgfHwgYmxvY2suY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKSwgcHJldkNoaWxkICYmIGlzRXF1YWwocHJldkNoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgJiYgaXNXaGl0ZVNwYWNlQ2hhcihjaGlsZC50ZXh0KSA/IChwcmV2Q2hpbGQudGV4dCArPSBcIiBcIiwgYmxvY2suY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKSkgOiBuZXh0Q2hpbGQgJiYgaXNFcXVhbChuZXh0Q2hpbGQubWFya3MsIGNoaWxkLm1hcmtzKSAmJiBpc1doaXRlU3BhY2VDaGFyKGNoaWxkLnRleHQpICYmIChuZXh0Q2hpbGQudGV4dCA9IGAgJHtuZXh0Q2hpbGQudGV4dH1gLCBibG9jay5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpKTtcbiAgICB9KTtcbiAgfSksIGJsb2NrczI7XG59XG5mdW5jdGlvbiBlbnN1cmVSb290SXNCbG9ja3MoYmxvY2tzMikge1xuICByZXR1cm4gYmxvY2tzMi5yZWR1Y2UoKG1lbW8sIG5vZGUsIGksIG9yaWdpbmFsKSA9PiB7XG4gICAgaWYgKG5vZGUuX3R5cGUgPT09IFwiYmxvY2tcIilcbiAgICAgIHJldHVybiBtZW1vLnB1c2gobm9kZSksIG1lbW87XG4gICAgaWYgKG5vZGUuX3R5cGUgPT09IFwiX19ibG9ja1wiKVxuICAgICAgcmV0dXJuIG1lbW8ucHVzaChub2RlLmJsb2NrKSwgbWVtbztcbiAgICBjb25zdCBsYXN0QmxvY2sgPSBtZW1vW21lbW8ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGkgPiAwICYmICFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhvcmlnaW5hbFtpIC0gMV0pICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGxhc3RCbG9jaykpXG4gICAgICByZXR1cm4gbGFzdEJsb2NrLmNoaWxkcmVuLnB1c2gobm9kZSksIG1lbW87XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgY2hpbGRyZW46IFtub2RlXVxuICAgIH07XG4gICAgcmV0dXJuIG1lbW8ucHVzaChibG9jayksIG1lbW87XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3Qobm9kZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5vZGUpID09PSBcIltvYmplY3QgTm9kZUxpc3RdXCI7XG59XG5mdW5jdGlvbiBpc01pbmltYWxTcGFuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiO1xufVxuZnVuY3Rpb24gaXNNaW5pbWFsQmxvY2sobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJibG9ja1wiO1xufVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlckRlY29yYXRvcihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcIl9fZGVjb3JhdG9yXCI7XG59XG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyQW5ub3RhdGlvbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcIl9fYW5ub3RhdGlvblwiO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG59XG5mdW5jdGlvbiBub3JtYWxpemVXaGl0ZXNwYWNlKHJvb3ROb2RlKSB7XG4gIGxldCBlbXB0eUJsb2NrQ291bnQgPSAwLCBsYXN0UGFyZW50ID0gbnVsbDtcbiAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IFtdO1xuICBmb3IgKGxldCBjaGlsZCA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgaWYgKCFpc0VsZW1lbnQoY2hpbGQpKSB7XG4gICAgICBub3JtYWxpemVXaGl0ZXNwYWNlKGNoaWxkKSwgZW1wdHlCbG9ja0NvdW50ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlbG0gPSBjaGlsZDtcbiAgICBpc1doaXRlc3BhY2VCbG9jayhlbG0pID8gKGxhc3RQYXJlbnQgJiYgZWxtLnBhcmVudEVsZW1lbnQgPT09IGxhc3RQYXJlbnQgPyAoZW1wdHlCbG9ja0NvdW50KyssIGVtcHR5QmxvY2tDb3VudCA+IDEgJiYgbm9kZXNUb1JlbW92ZS5wdXNoKGVsbSkpIDogZW1wdHlCbG9ja0NvdW50ID0gMSwgbGFzdFBhcmVudCA9IGVsbS5wYXJlbnRFbGVtZW50KSA6IChub3JtYWxpemVXaGl0ZXNwYWNlKGNoaWxkKSwgZW1wdHlCbG9ja0NvdW50ID0gMCk7XG4gIH1cbiAgbm9kZXNUb1JlbW92ZS5mb3JFYWNoKChub2RlKSA9PiBub2RlLnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUFsbFdoaXRlc3BhY2Uocm9vdE5vZGUpIHtcbiAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IFtdO1xuICBmdW5jdGlvbiBjb2xsZWN0Tm9kZXNUb1JlbW92ZShjdXJyZW50Tm9kZSkge1xuICAgIGlmIChpc0VsZW1lbnQoY3VycmVudE5vZGUpKSB7XG4gICAgICBjb25zdCBlbG0gPSBjdXJyZW50Tm9kZTtcbiAgICAgIGlmICh0YWdOYW1lKGVsbSkgPT09IFwiYnJcIiAmJiAodGFnTmFtZShlbG0ubmV4dEVsZW1lbnRTaWJsaW5nKSA9PT0gXCJwXCIgfHwgdGFnTmFtZShlbG0ucHJldmlvdXNFbGVtZW50U2libGluZykgPT09IFwicFwiKSkge1xuICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2goZWxtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCh0YWdOYW1lKGVsbSkgPT09IFwicFwiIHx8IHRhZ05hbWUoZWxtKSA9PT0gXCJiclwiKSAmJiBlbG0/LmZpcnN0Q2hpbGQ/LnRleHRDb250ZW50Py50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKGVsbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGNoaWxkID0gZWxtLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKVxuICAgICAgICBjb2xsZWN0Tm9kZXNUb1JlbW92ZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGNvbGxlY3ROb2Rlc1RvUmVtb3ZlKHJvb3ROb2RlKSwgbm9kZXNUb1JlbW92ZS5mb3JFYWNoKChub2RlKSA9PiBub2RlLnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZUJsb2NrKGVsbSkge1xuICByZXR1cm4gW1wicFwiLCBcImJyXCJdLmluY2x1ZGVzKHRhZ05hbWUoZWxtKSB8fCBcIlwiKSAmJiAhZWxtLnRleHRDb250ZW50Py50cmltKCk7XG59XG5jb25zdCBMSVNUX0NPTlRBSU5FUl9UQUdTID0gT2JqZWN0LmtleXMoSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTKTtcbmZ1bmN0aW9uIGlzRW1waGFzaXMkMShlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvZm9udC1zdHlsZVxccyo6XFxzKml0YWxpYy8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU3Ryb25nJDEoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtd2VpZ2h0XFxzKjpcXHMqNzAwLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNVbmRlcmxpbmUkMShlbCkge1xuICBpZiAoIWlzRWxlbWVudChlbCkgfHwgdGFnTmFtZShlbC5wYXJlbnROb2RlKSA9PT0gXCJhXCIpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvdGV4dC1kZWNvcmF0aW9uXFxzKjpcXHMqdW5kZXJsaW5lLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJpa2V0aHJvdWdoKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC90ZXh0LWRlY29yYXRpb25cXHMqOlxccyooPzouKmxpbmUtdGhyb3VnaC4qOykvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc0dvb2dsZURvY3MoZWwpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbCkgJiYgISFlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLWdvb2dsZS1kb2NzXCIpO1xufVxuZnVuY3Rpb24gaXNSb290Tm9kZShlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiAhIWVsLmdldEF0dHJpYnV0ZShcImRhdGEtaXMtcm9vdC1ub2RlXCIpO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1TdHlsZSQxKGVsKSB7XG4gIGNvbnN0IHBhcmVudFRhZyA9IHRhZ05hbWUoZWwucGFyZW50Tm9kZSk7XG4gIGlmICghKHBhcmVudFRhZyAmJiAhTElTVF9DT05UQUlORVJfVEFHUy5pbmNsdWRlcyhwYXJlbnRUYWcpKSlcbiAgICByZXR1cm4gdGFnTmFtZShlbC5wYXJlbnROb2RlKSA9PT0gXCJ1bFwiID8gXCJidWxsZXRcIiA6IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUxldmVsJDEoZWwpIHtcbiAgbGV0IGxldmVsID0gMDtcbiAgaWYgKHRhZ05hbWUoZWwpID09PSBcImxpXCIpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgZm9yICg7IHBhcmVudE5vZGU7ICkge1xuICAgICAgY29uc3QgcGFyZW50VGFnID0gdGFnTmFtZShwYXJlbnROb2RlKTtcbiAgICAgIHBhcmVudFRhZyAmJiBMSVNUX0NPTlRBSU5FUl9UQUdTLmluY2x1ZGVzKHBhcmVudFRhZykgJiYgbGV2ZWwrKywgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIGxldmVsID0gMTtcbiAgcmV0dXJuIGxldmVsO1xufVxuY29uc3QgYmxvY2tzID0ge1xuICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gIC4uLkhUTUxfSEVBREVSX1RBR1Ncbn07XG5mdW5jdGlvbiBnZXRCbG9ja1N0eWxlKGVsLCBlbmFibGVkQmxvY2tTdHlsZXMpIHtcbiAgY29uc3QgY2hpbGRUYWcgPSB0YWdOYW1lKGVsLmZpcnN0Q2hpbGQpLCBibG9jayA9IGNoaWxkVGFnICYmIGJsb2Nrc1tjaGlsZFRhZ107XG4gIHJldHVybiBibG9jayAmJiBlbmFibGVkQmxvY2tTdHlsZXMuaW5jbHVkZXMoYmxvY2suc3R5bGUpID8gYmxvY2suc3R5bGUgOiBCTE9DS19ERUZBVUxUX1NUWUxFO1xufVxuZnVuY3Rpb24gY3JlYXRlR0RvY3NSdWxlcyhfYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoZWwpICYmIHRhZ05hbWUoZWwpID09PSBcInNwYW5cIiAmJiBpc0dvb2dsZURvY3MoZWwpKSB7XG4gICAgICAgICAgY29uc3Qgc3BhbiA9IHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIG1hcmtzOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IGVsLnRleHRDb250ZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaXNTdHJvbmckMShlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwic3Ryb25nXCIpLCBpc1VuZGVybGluZSQxKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJ1bmRlcmxpbmVcIiksIGlzU3RyaWtldGhyb3VnaChlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwic3RyaWtlLXRocm91Z2hcIiksIGlzRW1waGFzaXMkMShlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwiZW1cIiksIHNwYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJsaVwiICYmIGlzR29vZ2xlRG9jcyhlbCkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfQkxPQ0ssXG4gICAgICAgICAgICBsaXN0SXRlbTogZ2V0TGlzdEl0ZW1TdHlsZSQxKGVsKSxcbiAgICAgICAgICAgIGxldmVsOiBnZXRMaXN0SXRlbUxldmVsJDEoZWwpLFxuICAgICAgICAgICAgc3R5bGU6IGdldEJsb2NrU3R5bGUoZWwsIG9wdGlvbnMuZW5hYmxlZEJsb2NrU3R5bGVzKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmZpcnN0Q2hpbGQ/LmNoaWxkTm9kZXMgfHwgW10pXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiICYmIGlzR29vZ2xlRG9jcyhlbCkgJiYgaXNFbGVtZW50KGVsKSAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcHBsZS1pbnRlcmNoYW5nZS1uZXdsaW5lXCIpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImJyXCIgJiYgaXNHb29nbGVEb2NzKGVsKSAmJiBpc0VsZW1lbnQoZWwpICYmIGVsPy5wYXJlbnROb2RlPy50ZXh0Q29udGVudCA9PT0gXCJcIilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiICYmIGlzR29vZ2xlRG9jcyhlbCkgJiYgaXNFbGVtZW50KGVsKSAmJiBpc1Jvb3ROb2RlKGVsKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24ga2V5R2VuZXJhdG9yKCkge1xuICByZXR1cm4gcmFuZG9tS2V5KDEyKTtcbn1cbmZ1bmN0aW9uIHdoYXR3Z1JORyhsZW5ndGggPSAxNikge1xuICBjb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpLCBybmRzODtcbn1cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSlcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAyNTYpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbmZ1bmN0aW9uIHJhbmRvbUtleShsZW5ndGgpIHtcbiAgcmV0dXJuIHdoYXR3Z1JORyhsZW5ndGgpLnJlZHVjZSgoc3RyLCBuKSA9PiBzdHIgKyBieXRlVG9IZXhbbl0sIFwiXCIpLnNsaWNlKDAsIGxlbmd0aCk7XG59XG5jb25zdCB3aGl0ZXNwYWNlVGV4dE5vZGVSdWxlID0ge1xuICBkZXNlcmlhbGl6ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiI3RleHRcIiAmJiBpc1doaXRlc3BhY2VUZXh0Tm9kZShub2RlKSA/IHtcbiAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgIG1hcmtzOiBbXSxcbiAgICAgIHRleHQ6IChub2RlLnRleHRDb250ZW50ID8/IFwiXCIpLnJlcGxhY2UoL1xcc1xccysvZywgXCIgXCIpXG4gICAgfSA6IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZVRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSAzICYmIChub2RlLnRleHRDb250ZW50IHx8IFwiXCIpLnJlcGxhY2UoL1tcXHJcXG5dL2csIFwiIFwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKSA9PT0gXCIgXCIgJiYgbm9kZS5uZXh0U2libGluZyAmJiBub2RlLm5leHRTaWJsaW5nLm5vZGVUeXBlICE9PSAzICYmIG5vZGUucHJldmlvdXNTaWJsaW5nICYmIG5vZGUucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlICE9PSAzIHx8IG5vZGUudGV4dENvbnRlbnQgIT09IFwiIFwiKSAmJiB0YWdOYW1lKG5vZGUucGFyZW50Tm9kZSkgIT09IFwiYm9keVwiO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUxpc3RJdGVtKGxpc3ROb2RlVGFnTmFtZSwgZW5hYmxlZExpc3RUeXBlcykge1xuICBpZiAobGlzdE5vZGVUYWdOYW1lID09PSBcInVsXCIgJiYgZW5hYmxlZExpc3RUeXBlcy5pbmNsdWRlcyhcImJ1bGxldFwiKSlcbiAgICByZXR1cm4gXCJidWxsZXRcIjtcbiAgaWYgKGxpc3ROb2RlVGFnTmFtZSA9PT0gXCJvbFwiICYmIGVuYWJsZWRMaXN0VHlwZXMuaW5jbHVkZXMoXCJudW1iZXJcIikpXG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVIVE1MUnVsZXMoX2Jsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB3aGl0ZXNwYWNlVGV4dE5vZGVSdWxlLFxuICAgIHtcbiAgICAgIC8vIFByZSBlbGVtZW50XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgIT09IFwicHJlXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc0NvZGVFbmFibGVkID0gb3B0aW9ucy5lbmFibGVkQmxvY2tTdHlsZXMuaW5jbHVkZXMoXCJjb2RlXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF90eXBlOiBcImJsb2NrXCIsXG4gICAgICAgICAgc3R5bGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgICAgbWFya3M6IGlzQ29kZUVuYWJsZWQgPyBbXCJjb2RlXCJdIDogW10sXG4gICAgICAgICAgICAgIHRleHQ6IGVsLnRleHRDb250ZW50IHx8IFwiXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBCbG9ja3F1b3RlIGVsZW1lbnRcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgIT09IFwiYmxvY2txdW90ZVwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYmxvY2tzMiA9IHtcbiAgICAgICAgICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gICAgICAgICAgLi4uSFRNTF9IRUFERVJfVEFHU1xuICAgICAgICB9O1xuICAgICAgICBkZWxldGUgYmxvY2tzMi5ibG9ja3F1b3RlO1xuICAgICAgICBjb25zdCBub25CbG9ja3F1b3RlQmxvY2tzID0gT2JqZWN0LmtleXMoYmxvY2tzMiksIGNoaWxkcmVuID0gW107XG4gICAgICAgIHJldHVybiBlbC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGVsLm93bmVyRG9jdW1lbnQpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub25CbG9ja3F1b3RlQmxvY2tzLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBlbC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLCBwcmV2aW91c0NoaWxkID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIHByZXZpb3VzQ2hpbGQgJiYgcHJldmlvdXNDaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBwcmV2aW91c0NoaWxkLnRleHRDb250ZW50Py50cmltKCkgJiYgc3Bhbi5hcHBlbmRDaGlsZChlbC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxyXCIpKSwgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNuKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChjbi5jbG9uZU5vZGUoITApKTtcbiAgICAgICAgICAgICAgfSksIGluZGV4ICE9PSBlbC5jaGlsZE5vZGVzLmxlbmd0aCAmJiBzcGFuLmFwcGVuZENoaWxkKGVsLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXHJcIikpLCBjaGlsZHJlbi5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgX3R5cGU6IFwiYmxvY2tcIixcbiAgICAgICAgICBzdHlsZTogXCJibG9ja3F1b3RlXCIsXG4gICAgICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGNoaWxkcmVuKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQmxvY2sgZWxlbWVudHNcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBjb25zdCBibG9ja3MyID0ge1xuICAgICAgICAgIC4uLkhUTUxfQkxPQ0tfVEFHUyxcbiAgICAgICAgICAuLi5IVE1MX0hFQURFUl9UQUdTXG4gICAgICAgIH0sIHRhZyA9IHRhZ05hbWUoZWwpO1xuICAgICAgICBsZXQgYmxvY2sgPSB0YWcgPyBibG9ja3MyW3RhZ10gOiB2b2lkIDA7XG4gICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICByZXR1cm4gZWwucGFyZW50Tm9kZSAmJiB0YWdOYW1lKGVsLnBhcmVudE5vZGUpID09PSBcImxpXCIgPyBuZXh0KGVsLmNoaWxkTm9kZXMpIDogKG9wdGlvbnMuZW5hYmxlZEJsb2NrU3R5bGVzLmluY2x1ZGVzKGJsb2NrLnN0eWxlKSB8fCAoYmxvY2sgPSBERUZBVUxUX0JMT0NLKSwge1xuICAgICAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSWdub3JlIHNwYW4gdGFnc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ05hbWUoZWwpO1xuICAgICAgICBpZiAoISghdGFnIHx8ICEodGFnIGluIEhUTUxfU1BBTl9UQUdTKSkpXG4gICAgICAgICAgcmV0dXJuIG5leHQoZWwuY2hpbGROb2Rlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBJZ25vcmUgZGl2IHRhZ3NcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiZGl2XCIpXG4gICAgICAgICAgcmV0dXJuIG5leHQoZWwuY2hpbGROb2Rlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBJZ25vcmUgbGlzdCBjb250YWluZXJzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTmFtZShlbCk7XG4gICAgICAgIGlmICghKCF0YWcgfHwgISh0YWcgaW4gSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTKSkpXG4gICAgICAgICAgcmV0dXJuIG5leHQoZWwuY2hpbGROb2Rlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWFsIHdpdGggYnInc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICB0ZXh0OiBgXG5gXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlYWwgd2l0aCBsaXN0IGl0ZW1zXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQsIGJsb2NrKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ05hbWUoZWwpLCBsaXN0SXRlbSA9IHRhZyA/IEhUTUxfTElTVF9JVEVNX1RBR1NbdGFnXSA6IHZvaWQgMCwgcGFyZW50VGFnID0gdGFnTmFtZShlbC5wYXJlbnROb2RlKSB8fCBcIlwiO1xuICAgICAgICBpZiAoIWxpc3RJdGVtIHx8ICFlbC5wYXJlbnROb2RlIHx8ICFIVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1NbcGFyZW50VGFnXSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGVuYWJsZWRMaXN0SXRlbSA9IHJlc29sdmVMaXN0SXRlbShcbiAgICAgICAgICBwYXJlbnRUYWcsXG4gICAgICAgICAgb3B0aW9ucy5lbmFibGVkTGlzdFR5cGVzXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbmFibGVkTGlzdEl0ZW0gPyAobGlzdEl0ZW0ubGlzdEl0ZW0gPSBlbmFibGVkTGlzdEl0ZW0sIHtcbiAgICAgICAgICAuLi5saXN0SXRlbSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICB9KSA6IGJsb2NrKHsgX3R5cGU6IFwiYmxvY2tcIiwgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcykgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWFsIHdpdGggZGVjb3JhdG9ycyAtIHRoaXMgaXMgYSBsaW1pdGVkIHNldCBvZiBrbm93biBodG1sIGVsZW1lbnRzIHRoYXQgd2Uga25vdyBob3cgdG8gZGVzZXJpYWxpemVcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3IgPSBIVE1MX0RFQ09SQVRPUl9UQUdTW3RhZ05hbWUoZWwpIHx8IFwiXCJdO1xuICAgICAgICBpZiAoISghZGVjb3JhdG9yIHx8ICFvcHRpb25zLmVuYWJsZWRTcGFuRGVjb3JhdG9ycy5pbmNsdWRlcyhkZWNvcmF0b3IpKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiX19kZWNvcmF0b3JcIixcbiAgICAgICAgICAgIG5hbWU6IGRlY29yYXRvcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgaHlwZXJsaW5rcywgYWRkIGFubm90YXRpb24gKGlmIGFsbG93ZWQgYnkgc2NoZW1hKSxcbiAgICAvLyBJZiBub3Qgc3VwcG9ydGVkIGp1c3Qgd3JpdGUgb3V0IHRoZSBsaW5rIHRleHQgYW5kIGhyZWYgaW4gcGxhaW4gdGV4dC5cbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgIT09IFwiYVwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGlua0VuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWRCbG9ja0Fubm90YXRpb25zLmluY2x1ZGVzKFwibGlua1wiKSwgaHJlZiA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgICAgaWYgKCFocmVmKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgICBsZXQgbWFya0RlZjtcbiAgICAgICAgcmV0dXJuIGxpbmtFbmFibGVkID8gKG1hcmtEZWYgPSB7XG4gICAgICAgICAgX2tleTogb3B0aW9ucy5rZXlHZW5lcmF0b3IgPyBvcHRpb25zLmtleUdlbmVyYXRvcigpIDoga2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgX3R5cGU6IFwibGlua1wiLFxuICAgICAgICAgIGhyZWZcbiAgICAgICAgfSwge1xuICAgICAgICAgIF90eXBlOiBcIl9fYW5ub3RhdGlvblwiLFxuICAgICAgICAgIG1hcmtEZWYsXG4gICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgfSkgOiBlbC5hcHBlbmRDaGlsZChlbC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgKCR7aHJlZn0pYCkpICYmIG5leHQoZWwuY2hpbGROb2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gaXNFbXBoYXNpcyhlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvZm9udC1zdHlsZTppdGFsaWMvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1N0cm9uZyhlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvZm9udC13ZWlnaHQ6NzAwLy50ZXN0KHN0eWxlIHx8IFwiXCIpIHx8IC9mb250LXdlaWdodDo2MDAvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1VuZGVybGluZShlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvdGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZS8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzTm90aW9uKGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmICEhZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1pcy1ub3Rpb25cIik7XG59XG5mdW5jdGlvbiBjcmVhdGVOb3Rpb25SdWxlcyhfYmxvY2tDb250ZW50VHlwZSkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoZWwpICYmIHRhZ05hbWUoZWwpID09PSBcInNwYW5cIiAmJiBpc05vdGlvbihlbCkpIHtcbiAgICAgICAgICBjb25zdCBzcGFuID0ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgbWFya3M6IFtdLFxuICAgICAgICAgICAgdGV4dDogZWwudGV4dENvbnRlbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpc1N0cm9uZyhlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwic3Ryb25nXCIpLCBpc1VuZGVybGluZShlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwidW5kZXJsaW5lXCIpLCBpc0VtcGhhc2lzKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJlbVwiKSwgc3BhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtU3R5bGUoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBpZiAoc3R5bGUgJiYgc3R5bGUubWF0Y2goL2xmb1xcZCsvKSlcbiAgICByZXR1cm4gc3R5bGUubWF0Y2goXCJsZm8xXCIpID8gXCJidWxsZXRcIiA6IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUxldmVsKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgaWYgKCFzdHlsZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGxldmVsTWF0Y2ggPSBzdHlsZS5tYXRjaCgvbGV2ZWxcXGQrLyk7XG4gIGlmICghbGV2ZWxNYXRjaClcbiAgICByZXR1cm47XG4gIGNvbnN0IFtsZXZlbF0gPSBsZXZlbE1hdGNoWzBdLm1hdGNoKC9cXGQvKSB8fCBbXTtcbiAgcmV0dXJuIChsZXZlbCA/IE51bWJlci5wYXJzZUludChsZXZlbCwgMTApIDogMSkgfHwgMTtcbn1cbmZ1bmN0aW9uIGlzV29yZExpc3RFbGVtZW50KGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmIGVsLmNsYXNzTmFtZSA/IGVsLmNsYXNzTmFtZSA9PT0gXCJNc29MaXN0UGFyYWdyYXBoQ3hTcEZpcnN0XCIgfHwgZWwuY2xhc3NOYW1lID09PSBcIk1zb0xpc3RQYXJhZ3JhcGhDeFNwTWlkZGxlXCIgfHwgZWwuY2xhc3NOYW1lID09PSBcIk1zb0xpc3RQYXJhZ3JhcGhDeFNwTGFzdFwiIDogITE7XG59XG5mdW5jdGlvbiBjcmVhdGVXb3JkUnVsZXMoKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcInBcIiAmJiBpc1dvcmRMaXN0RWxlbWVudChlbCkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfQkxPQ0ssXG4gICAgICAgICAgICBsaXN0SXRlbTogZ2V0TGlzdEl0ZW1TdHlsZShlbCksXG4gICAgICAgICAgICBsZXZlbDogZ2V0TGlzdEl0ZW1MZXZlbChlbCksXG4gICAgICAgICAgICBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjcmVhdGVSdWxlcyhibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgLi4uY3JlYXRlV29yZFJ1bGVzKCksXG4gICAgLi4uY3JlYXRlTm90aW9uUnVsZXMoKSxcbiAgICAuLi5jcmVhdGVHRG9jc1J1bGVzKGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMpLFxuICAgIC4uLmNyZWF0ZUhUTUxSdWxlcyhibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKVxuICBdO1xufVxuY2xhc3MgSHRtbERlc2VyaWFsaXplciB7XG4gIGJsb2NrQ29udGVudFR5cGU7XG4gIHJ1bGVzO1xuICBwYXJzZUh0bWw7XG4gIF9tYXJrRGVmcyA9IFtdO1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNlcmlhbGl6ZXIgcmVzcGVjdGluZyBhIFNhbml0eSBibG9jayBjb250ZW50IHR5cGUncyBzY2hlbWFcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrQ29udGVudFR5cGUgLSBTY2hlbWEgdHlwZSBmb3IgYXJyYXkgY29udGFpbmluZyBfYXQgbGVhc3RfIGEgYmxvY2sgY2hpbGQgdHlwZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBkZXNlcmlhbGl6YXRpb24gcHJvY2Vzc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBydWxlcyA9IFtdLCB1bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUgPSBcInByZXNlcnZlXCIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFibG9ja0NvbnRlbnRUeXBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyICdibG9ja0NvbnRlbnRUeXBlJyBpcyByZXF1aXJlZFwiKTtcbiAgICBjb25zdCBzdGFuZGFyZFJ1bGVzID0gY3JlYXRlUnVsZXMoYmxvY2tDb250ZW50VHlwZSwge1xuICAgICAgLi4uY3JlYXRlUnVsZU9wdGlvbnMoYmxvY2tDb250ZW50VHlwZSksXG4gICAgICBrZXlHZW5lcmF0b3I6IG9wdGlvbnMua2V5R2VuZXJhdG9yXG4gICAgfSk7XG4gICAgdGhpcy5ydWxlcyA9IFsuLi5ydWxlcywgLi4uc3RhbmRhcmRSdWxlc107XG4gICAgY29uc3QgcGFyc2VIdG1sID0gb3B0aW9ucy5wYXJzZUh0bWwgfHwgZGVmYXVsdFBhcnNlSHRtbCgpO1xuICAgIHRoaXMuYmxvY2tDb250ZW50VHlwZSA9IGJsb2NrQ29udGVudFR5cGUsIHRoaXMucGFyc2VIdG1sID0gKGh0bWwpID0+IHByZXByb2Nlc3MoaHRtbCwgcGFyc2VIdG1sLCB7IHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZSB9KS5ib2R5O1xuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBIVE1MLlxuICAgKlxuICAgKiBAcGFyYW0gaHRtbCAtIFRoZSBIVE1MIHRvIGRlc2VyaWFsaXplLCBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBibG9ja3MgLSBlaXRoZXIgcG9ydGFibGUgdGV4dCBibG9ja3Mgb3Igb3RoZXIgYWxsb3dlZCBibG9ja3NcbiAgICovXG4gIGRlc2VyaWFsaXplID0gKGh0bWwpID0+IHtcbiAgICB0aGlzLl9tYXJrRGVmcyA9IFtdO1xuICAgIGNvbnN0IHsgcGFyc2VIdG1sIH0gPSB0aGlzLCBmcmFnbWVudCA9IHBhcnNlSHRtbChodG1sKSwgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGZyYWdtZW50LmNoaWxkTm9kZXMpLCBibG9ja3MyID0gdHJpbVdoaXRlc3BhY2UoXG4gICAgICBmbGF0dGVuTmVzdGVkQmxvY2tzKFxuICAgICAgICBlbnN1cmVSb290SXNCbG9ja3ModGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnRzKGNoaWxkcmVuKSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX21hcmtEZWZzLmxlbmd0aCA+IDAgJiYgYmxvY2tzMi5maWx0ZXIoXG4gICAgICAoYmxvY2spID0+IGJsb2NrLl90eXBlID09PSBcImJsb2NrXCJcbiAgICApLmZvckVhY2goKGJsb2NrKSA9PiB7XG4gICAgICBibG9jay5tYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzIHx8IFtdLCBibG9jay5tYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzLmNvbmNhdChcbiAgICAgICAgdGhpcy5fbWFya0RlZnMuZmlsdGVyKChkZWYpID0+IGZsYXR0ZW4oXG4gICAgICAgICAgYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQubWFya3MgfHwgW10pXG4gICAgICAgICkuaW5jbHVkZXMoZGVmLl9rZXkpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5ibG9ja0NvbnRlbnRUeXBlLm9mLmZpbmQoZmluZEJsb2NrVHlwZSk7XG4gICAgcmV0dXJuIHR5cGUgPyBibG9ja3MyLm1hcCgoYmxvY2spID0+IChibG9jay5fdHlwZSA9PT0gXCJibG9ja1wiICYmIChibG9jay5fdHlwZSA9IHR5cGUubmFtZSksIGJsb2NrKSkgOiBibG9ja3MyO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYW4gYXJyYXkgb2YgRE9NIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudHMgLSBBcnJheSBvZiBET00gZWxlbWVudHMgdG8gZGVzZXJpYWxpemVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGRlc2VyaWFsaXplRWxlbWVudHMgPSAoZWxlbWVudHMgPSBbXSkgPT4ge1xuICAgIGxldCBub2RlcyA9IFtdO1xuICAgIHJldHVybiBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdCh0aGlzLmRlc2VyaWFsaXplRWxlbWVudChlbGVtZW50KSk7XG4gICAgfSksIG5vZGVzO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIERlc2VyaWFsaXplIGEgRE9NIGVsZW1lbnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGRlc2VyaWFsaXplRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgbmV4dCA9IChlbGVtZW50cykgPT4ge1xuICAgICAgaWYgKGlzTm9kZUxpc3QoZWxlbWVudHMpKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnRzKEFycmF5LmZyb20oZWxlbWVudHMpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgICBpZiAoZWxlbWVudHMpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRWxlbWVudChlbGVtZW50cyk7XG4gICAgfSwgYmxvY2sgPSAocHJvcHMpID0+ICh7XG4gICAgICBfdHlwZTogXCJfX2Jsb2NrXCIsXG4gICAgICBibG9jazogcHJvcHNcbiAgICB9KTtcbiAgICBsZXQgbm9kZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLnJ1bGVzW2ldO1xuICAgICAgaWYgKCFydWxlLmRlc2VyaWFsaXplKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJldCA9IHJ1bGUuZGVzZXJpYWxpemUoZWxlbWVudCwgbmV4dCwgYmxvY2spLCB0eXBlID0gcmVzb2x2ZUpzVHlwZShyZXQpO1xuICAgICAgaWYgKHR5cGUgIT09IFwiYXJyYXlcIiAmJiB0eXBlICE9PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IFwibnVsbFwiICYmIHR5cGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQSBydWxlIHJldHVybmVkIGFuIGludmFsaWQgZGVzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uOiBcIiR7bm9kZX1cIi5gXG4gICAgICAgICk7XG4gICAgICBpZiAocmV0ICE9PSB2b2lkIDApIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXQgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZXNlcmlhbGl6ZXIgcnVsZSByZXR1cm5lZCBgbnVsbGBcIik7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShyZXQpID8gbm9kZSA9IHJldCA6IGlzUGxhY2Vob2xkZXJEZWNvcmF0b3IocmV0KSA/IG5vZGUgPSB0aGlzLmRlc2VyaWFsaXplRGVjb3JhdG9yKHJldCkgOiBpc1BsYWNlaG9sZGVyQW5ub3RhdGlvbihyZXQpID8gbm9kZSA9IHRoaXMuZGVzZXJpYWxpemVBbm5vdGF0aW9uKHJldCkgOiBub2RlID0gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQgJiYgIUFycmF5LmlzQXJyYXkocmV0KSAmJiBpc01pbmltYWxCbG9jayhyZXQpICYmIFwibGlzdEl0ZW1cIiBpbiByZXQpIHtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlPy5wYXJlbnROb2RlO1xuICAgICAgICAgIGZvciAoOyBwYXJlbnQgJiYgdGFnTmFtZShwYXJlbnQpID09PSBcImxpXCI7IClcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlPy5wYXJlbnROb2RlLCByZXQubGV2ZWwgPSByZXQubGV2ZWwgPyByZXQubGV2ZWwgKyAxIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXQgJiYgIUFycmF5LmlzQXJyYXkocmV0KSAmJiBpc01pbmltYWxCbG9jayhyZXQpICYmIHJldC5zdHlsZSA9PT0gXCJibG9ja3F1b3RlXCIgJiYgcmV0LmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlzTWluaW1hbFNwYW4oY2hpbGQpICYmIGNoaWxkLnRleHQgPT09IFwiXFxyXCIgJiYgKGNoaWxkLnRleHQgPSBgXG5gLCAoaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHJldC5jaGlsZHJlbi5sZW5ndGggLSAxKSAmJiByZXQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGUgfHwgbmV4dChlbGVtZW50LmNoaWxkTm9kZXMpIHx8IFtdO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBgX19kZWNvcmF0b3JgIHR5cGVcbiAgICogKGFuIGludGVybmFsIG1hZGUgdXAgdHlwZSB0byBwcm9jZXNzIGRlY29yYXRvcnMgZXhjbHVzaXZlbHkpXG4gICAqXG4gICAqIEBwYXJhbSBkZWNvcmF0b3IgLVxuICAgKiBAcmV0dXJucyBhcnJheSBvZiAuLi5cbiAgICovXG4gIGRlc2VyaWFsaXplRGVjb3JhdG9yID0gKGRlY29yYXRvcikgPT4ge1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gZGVjb3JhdG9yLCBhcHBseURlY29yYXRvciA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoaXNQbGFjZWhvbGRlckRlY29yYXRvcihub2RlKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVEZWNvcmF0b3Iobm9kZSk7XG4gICAgICBpZiAoaXNNaW5pbWFsU3Bhbihub2RlKSlcbiAgICAgICAgbm9kZS5tYXJrcyA9IG5vZGUubWFya3MgfHwgW10sIG5vZGUudGV4dC50cmltKCkgJiYgbm9kZS5tYXJrcy51bnNoaWZ0KG5hbWUpO1xuICAgICAgZWxzZSBpZiAoXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBjb25zdCBibG9jayA9IG5vZGU7XG4gICAgICAgIGJsb2NrLmNoaWxkcmVuID0gYmxvY2suY2hpbGRyZW4ubWFwKGFwcGx5RGVjb3JhdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIGRlY29yYXRvci5jaGlsZHJlbi5yZWR1Y2UoKGNoaWxkcmVuLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCByZXQgPSBhcHBseURlY29yYXRvcihub2RlKTtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJldCkgPyBjaGlsZHJlbi5jb25jYXQocmV0KSA6IChjaGlsZHJlbi5wdXNoKHJldCksIGNoaWxkcmVuKTtcbiAgICB9LCBbXSk7XG4gIH07XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIGBfX2Fubm90YXRpb25gIG9iamVjdC5cbiAgICogKGFuIGludGVybmFsIG1hZGUgdXAgdHlwZSB0byBwcm9jZXNzIGFubm90YXRpb25zIGV4Y2x1c2l2ZWx5KVxuICAgKlxuICAgKiBAcGFyYW0gYW5ub3RhdGlvbiAtXG4gICAqIEByZXR1cm5zIEFycmF5IG9mLi4uXG4gICAqL1xuICBkZXNlcmlhbGl6ZUFubm90YXRpb24gPSAoYW5ub3RhdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgbWFya0RlZiB9ID0gYW5ub3RhdGlvbjtcbiAgICB0aGlzLl9tYXJrRGVmcy5wdXNoKG1hcmtEZWYpO1xuICAgIGNvbnN0IGFwcGx5QW5ub3RhdGlvbiA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoaXNQbGFjZWhvbGRlckFubm90YXRpb24obm9kZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplQW5ub3RhdGlvbihub2RlKTtcbiAgICAgIGlmIChpc01pbmltYWxTcGFuKG5vZGUpKVxuICAgICAgICBub2RlLm1hcmtzID0gbm9kZS5tYXJrcyB8fCBbXSwgbm9kZS50ZXh0LnRyaW0oKSAmJiBub2RlLm1hcmtzLnVuc2hpZnQobWFya0RlZi5fa2V5KTtcbiAgICAgIGVsc2UgaWYgKFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlO1xuICAgICAgICBibG9jay5jaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcChhcHBseUFubm90YXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICByZXR1cm4gYW5ub3RhdGlvbi5jaGlsZHJlbi5yZWR1Y2UoKGNoaWxkcmVuLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCByZXQgPSBhcHBseUFubm90YXRpb24obm9kZSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXQpID8gY2hpbGRyZW4uY29uY2F0KHJldCkgOiAoY2hpbGRyZW4ucHVzaChyZXQpLCBjaGlsZHJlbik7XG4gICAgfSwgW10pO1xuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQmxvY2sobm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChub2RlLl90eXBlICE9PSAob3B0aW9ucy5ibG9ja1R5cGVOYW1lIHx8IFwiYmxvY2tcIikpXG4gICAgcmV0dXJuIFwiX2tleVwiIGluIG5vZGUgPyBub2RlIDoge1xuICAgICAgLi4ubm9kZSxcbiAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpXG4gICAgfTtcbiAgY29uc3QgYmxvY2sgPSB7XG4gICAgX2tleTogb3B0aW9ucy5rZXlHZW5lcmF0b3IgPyBvcHRpb25zLmtleUdlbmVyYXRvcigpIDoga2V5R2VuZXJhdG9yKCksXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG1hcmtEZWZzOiBbXSxcbiAgICAuLi5ub2RlXG4gIH0sIGxhc3RDaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2Jsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAoIWxhc3RDaGlsZClcbiAgICByZXR1cm4gYmxvY2suY2hpbGRyZW4gPSBbXG4gICAgICB7XG4gICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgX2tleTogb3B0aW9ucy5rZXlHZW5lcmF0b3IgPyBvcHRpb25zLmtleUdlbmVyYXRvcigpIDoga2V5R2VuZXJhdG9yKCksXG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIG1hcmtzOiBbXVxuICAgICAgfVxuICAgIF0sIGJsb2NrO1xuICBjb25zdCB1c2VkTWFya0RlZnMgPSBbXSwgYWxsb3dlZERlY29yYXRvcnMgPSBvcHRpb25zLmFsbG93ZWREZWNvcmF0b3JzICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycykgPyBvcHRpb25zLmFsbG93ZWREZWNvcmF0b3JzIDogITE7XG4gIHJldHVybiBibG9jay5jaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLnJlZHVjZShcbiAgICAoYWNjLCBjaGlsZCkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNDaGlsZCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gcHJldmlvdXNDaGlsZCAmJiBpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpICYmIGlzUG9ydGFibGVUZXh0U3BhbihwcmV2aW91c0NoaWxkKSAmJiBpc0VxdWFsKHByZXZpb3VzQ2hpbGQubWFya3MsIGNoaWxkLm1hcmtzKSA/IChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkID09PSBjaGlsZCAmJiBjaGlsZC50ZXh0ID09PSBcIlwiICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgKHByZXZpb3VzQ2hpbGQudGV4dCArPSBjaGlsZC50ZXh0KSwgYWNjKSA6IChhY2MucHVzaChjaGlsZCksIGFjYyk7XG4gICAgfSxcbiAgICBbXVxuICApLm1hcCgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWNoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGlsZFwiKTtcbiAgICByZXR1cm4gY2hpbGQuX2tleSA9IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLCBpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpICYmIChjaGlsZC5tYXJrcyA/IGFsbG93ZWREZWNvcmF0b3JzICYmIChjaGlsZC5tYXJrcyA9IGNoaWxkLm1hcmtzLmZpbHRlcigobWFyaykgPT4ge1xuICAgICAgY29uc3QgaXNBbGxvd2VkID0gYWxsb3dlZERlY29yYXRvcnMuaW5jbHVkZXMobWFyayksIGlzVXNlZCA9IGJsb2NrLm1hcmtEZWZzPy5zb21lKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKTtcbiAgICAgIHJldHVybiBpc0FsbG93ZWQgfHwgaXNVc2VkO1xuICAgIH0pKSA6IGNoaWxkLm1hcmtzID0gW10sIHVzZWRNYXJrRGVmcy5wdXNoKC4uLmNoaWxkLm1hcmtzKSksIGNoaWxkO1xuICB9KSwgYmxvY2subWFya0RlZnMgPSAoYmxvY2subWFya0RlZnMgfHwgW10pLmZpbHRlcihcbiAgICAobWFya0RlZikgPT4gdXNlZE1hcmtEZWZzLmluY2x1ZGVzKG1hcmtEZWYuX2tleSlcbiAgKSwgYmxvY2s7XG59XG5mdW5jdGlvbiBodG1sVG9CbG9ja3MoaHRtbCwgYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBuZXcgSHRtbERlc2VyaWFsaXplcihibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKS5kZXNlcmlhbGl6ZShodG1sKS5tYXAoKGJsb2NrKSA9PiBub3JtYWxpemVCbG9jayhibG9jaywgeyBrZXlHZW5lcmF0b3I6IG9wdGlvbnMua2V5R2VuZXJhdG9yIH0pKTtcbn1cbmZ1bmN0aW9uIGdldEJsb2NrQ29udGVudEZlYXR1cmVzKGJsb2NrQ29udGVudFR5cGUpIHtcbiAgcmV0dXJuIGJsb2NrQ29udGVudEZlYXR1cmVzKGJsb2NrQ29udGVudFR5cGUpO1xufVxuZXhwb3J0IHtcbiAgZ2V0QmxvY2tDb250ZW50RmVhdHVyZXMsXG4gIGh0bWxUb0Jsb2NrcyxcbiAgbm9ybWFsaXplQmxvY2ssXG4gIHJhbmRvbUtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/block-tools/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockTextBefore: () => (/* binding */ getBlockTextBefore)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector.is-selection-expanded.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js\");\n\n\nconst getBlockTextBefore = (snapshot) => {\n  if (!snapshot.context.selection)\n    return \"\";\n  const point = (snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.reverseSelection)(snapshot.context.selection) : snapshot.context.selection).anchor, key = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(point.path[0]) ? point.path[0]._key : void 0, block = key ? snapshot.context.value.find((block2) => block2._key === key) : void 0;\n  if (!block)\n    return \"\";\n  const startOfBlock = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint)({\n    context: snapshot.context,\n    block: {\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    }\n  });\n  return (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionText)({\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startOfBlock,\n        focus: point\n      }\n    }\n  });\n};\n\n//# sourceMappingURL=selector.get-text-before.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuZ2V0LXRleHQtYmVmb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RjtBQUN2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsdUVBQWdCLHlFQUF5RSxxRUFBYztBQUM5SjtBQUNBO0FBQ0EsdUJBQXVCLHlFQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILFNBQVMsb0ZBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9zZWxlY3Rvci5nZXQtdGV4dC1iZWZvcmUuanM/MDQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRCbG9ja1N0YXJ0UG9pbnQsIGlzS2V5ZWRTZWdtZW50LCByZXZlcnNlU2VsZWN0aW9uIH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGdldFNlbGVjdGlvblRleHQgfSBmcm9tIFwiLi9zZWxlY3Rvci5pcy1zZWxlY3Rpb24tZXhwYW5kZWQuanNcIjtcbmNvbnN0IGdldEJsb2NrVGV4dEJlZm9yZSA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBwb2ludCA9IChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHJldmVyc2VTZWxlY3Rpb24oc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pIDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLmFuY2hvciwga2V5ID0gaXNLZXllZFNlZ21lbnQocG9pbnQucGF0aFswXSkgPyBwb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIGJsb2NrID0ga2V5ID8gc25hcHNob3QuY29udGV4dC52YWx1ZS5maW5kKChibG9jazIpID0+IGJsb2NrMi5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBzdGFydE9mQmxvY2sgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgYmxvY2s6IHtcbiAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgcGF0aDogW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZ2V0U2VsZWN0aW9uVGV4dCh7XG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHN0YXJ0T2ZCbG9jayxcbiAgICAgICAgZm9jdXM6IHBvaW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5leHBvcnQge1xuICBnZXRCbG9ja1RleHRCZWZvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rvci5nZXQtdGV4dC1iZWZvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActiveAnnotations: () => (/* binding */ getActiveAnnotations),\n/* harmony export */   getActiveListItem: () => (/* binding */ getActiveListItem),\n/* harmony export */   getActiveStyle: () => (/* binding */ getActiveStyle),\n/* harmony export */   getCaretWordSelection: () => (/* binding */ getCaretWordSelection),\n/* harmony export */   getFocusInlineObject: () => (/* binding */ getFocusInlineObject),\n/* harmony export */   getNextInlineObject: () => (/* binding */ getNextInlineObject),\n/* harmony export */   getSelectedSpans: () => (/* binding */ getSelectedSpans),\n/* harmony export */   getSelectedTextBlocks: () => (/* binding */ getSelectedTextBlocks),\n/* harmony export */   getSelectionEndPoint: () => (/* binding */ getSelectionEndPoint),\n/* harmony export */   getTrimmedSelection: () => (/* binding */ getTrimmedSelection),\n/* harmony export */   isActiveAnnotation: () => (/* binding */ isActiveAnnotation),\n/* harmony export */   isActiveDecorator: () => (/* binding */ isActiveDecorator),\n/* harmony export */   isActiveListItem: () => (/* binding */ isActiveListItem),\n/* harmony export */   isActiveStyle: () => (/* binding */ isActiveStyle),\n/* harmony export */   isAtTheEndOfBlock: () => (/* binding */ isAtTheEndOfBlock),\n/* harmony export */   isAtTheStartOfBlock: () => (/* binding */ isAtTheStartOfBlock),\n/* harmony export */   isOverlappingSelection: () => (/* binding */ isOverlappingSelection),\n/* harmony export */   isPointAfterSelection: () => (/* binding */ isPointAfterSelection),\n/* harmony export */   isPointBeforeSelection: () => (/* binding */ isPointBeforeSelection),\n/* harmony export */   isSelectingEntireBlocks: () => (/* binding */ isSelectingEntireBlocks)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector.is-selection-expanded.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js\");\n/* harmony import */ var _util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.is-equal-selection-points.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-equal-selection-points.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\n\n\n\nconst getSelectedSpans = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedSpans = [], startPoint = snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor, endPoint = snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus, startBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(endPoint.path[0]) ? endPoint.path[0]._key : void 0;\n  if (!startBlockKey || !endBlockKey)\n    return selectedSpans;\n  const startSpanKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endSpanKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(endPoint.path[2]) ? endPoint.path[2]._key : void 0;\n  let startBlockFound = !1;\n  for (const block of snapshot.context.value)\n    if (block._key === startBlockKey && (startBlockFound = !0), !!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block)) {\n      if (block._key === startBlockKey) {\n        for (const child of block.children)\n          if ((0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child)) {\n            if (startSpanKey && child._key === startSpanKey) {\n              if (startPoint.offset < child.text.length && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              }), startSpanKey === endSpanKey)\n                break;\n              continue;\n            }\n            if (endSpanKey && child._key === endSpanKey) {\n              endPoint.offset > 0 && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              });\n              break;\n            }\n            selectedSpans.length > 0 && selectedSpans.push({\n              node: child,\n              path: [{\n                _key: block._key\n              }, \"children\", {\n                _key: child._key\n              }]\n            });\n          }\n        if (startBlockKey === endBlockKey)\n          break;\n        continue;\n      }\n      if (block._key === endBlockKey) {\n        for (const child of block.children)\n          if ((0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child)) {\n            if (endSpanKey && child._key === endSpanKey) {\n              endPoint.offset > 0 && selectedSpans.push({\n                node: child,\n                path: [{\n                  _key: block._key\n                }, \"children\", {\n                  _key: child._key\n                }]\n              });\n              break;\n            }\n            selectedSpans.push({\n              node: child,\n              path: [{\n                _key: block._key\n              }, \"children\", {\n                _key: child._key\n              }]\n            });\n          }\n        break;\n      }\n      if (startBlockFound)\n        for (const child of block.children)\n          (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child) && selectedSpans.push({\n            node: child,\n            path: [{\n              _key: block._key\n            }, \"children\", {\n              _key: child._key\n            }]\n          });\n    }\n  return selectedSpans;\n}, getActiveAnnotations = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedBlocks = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot), selectedSpans = getSelectedSpans(snapshot), focusSpan = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot);\n  if (selectedSpans.length === 0 || !focusSpan)\n    return [];\n  if (selectedSpans.length === 1 && (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot)) {\n    if (snapshot.context.selection.focus.offset === 0)\n      return [];\n    if (snapshot.context.selection.focus.offset === focusSpan.node.text.length)\n      return [];\n  }\n  return selectedBlocks.flatMap((block) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block.node) ? block.node.markDefs ?? [] : []).filter((markDef) => selectedSpans.some((span) => span.node.marks?.includes(markDef._key)));\n}, getActiveListItem = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const selectedTextBlocks = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot).map((block) => block.node).filter((block) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);\n  if (!firstTextBlock)\n    return;\n  const firstListItem = firstTextBlock.listItem;\n  if (firstListItem && selectedTextBlocks.every((block) => block.listItem === firstListItem))\n    return firstListItem;\n}, getActiveStyle = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const selectedTextBlocks = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot).map((block) => block.node).filter((block) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);\n  if (!firstTextBlock)\n    return;\n  const firstStyle = firstTextBlock.style;\n  if (firstStyle && selectedTextBlocks.every((block) => block.style === firstStyle))\n    return firstStyle;\n}, getSelectionEndPoint = (snapshot) => {\n  if (snapshot.context.selection)\n    return snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus;\n}, getNextInlineObject = (snapshot) => {\n  const focusTextBlock = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot), selectionEndPointChildKey = selectionEndPoint && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isKeySegment)(selectionEndPoint.path[2]) ? selectionEndPoint.path[2]._key : void 0;\n  if (!focusTextBlock || !selectionEndPointChildKey)\n    return;\n  let endPointChildFound = !1, inlineObject;\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = !0;\n      continue;\n    }\n    if (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan)(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, \"children\", {\n          _key: child._key\n        }]\n      };\n      break;\n    }\n  }\n  return inlineObject;\n}, getCaretWordSelection = (snapshot) => {\n  if (!snapshot.context.selection || !(0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot))\n    return null;\n  const focusTextBlock = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionStartPoint)(snapshot), selectionStartOffset = selectionStartPoint ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.spanSelectionPointToBlockOffset)({\n    context: snapshot.context,\n    selectionPoint: selectionStartPoint\n  }) : void 0;\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset)\n    return null;\n  const previousInlineObject = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousInlineObject)(snapshot), blockStartPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint)({\n    context: snapshot.context,\n    block: focusTextBlock\n  }), textDirectlyBefore = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionText)({\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject ? {\n          path: previousInlineObject.path,\n          offset: 0\n        } : blockStartPoint,\n        focus: selectionStartPoint\n      }\n    }\n  }).split(/\\s+/).at(-1), nextInlineObject = getNextInlineObject(snapshot), blockEndPoint = (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.getBlockEndPoint)({\n    context: snapshot.context,\n    block: focusTextBlock\n  }), textDirectlyAfter = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionText)({\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject ? {\n          path: nextInlineObject.path,\n          offset: 0\n        } : blockEndPoint\n      }\n    }\n  }).split(/\\s+/).at(0);\n  if ((textDirectlyBefore === void 0 || textDirectlyBefore === \"\") && (textDirectlyAfter === void 0 || textDirectlyAfter === \"\"))\n    return null;\n  const caretWordStartOffset = textDirectlyBefore ? {\n    ...selectionStartOffset,\n    offset: selectionStartOffset.offset - textDirectlyBefore.length\n  } : selectionStartOffset, caretWordEndOffset = textDirectlyAfter ? {\n    ...selectionStartOffset,\n    offset: selectionStartOffset.offset + textDirectlyAfter.length\n  } : selectionStartOffset, caretWordStartSelectionPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint)({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: \"backward\"\n  }), caretWordEndSelectionPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint)({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: \"forward\"\n  });\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint)\n    return null;\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint\n  };\n  return (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionExpanded)({\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection\n    }\n  }) ? caretWordSelection : null;\n}, getFocusInlineObject = (snapshot) => {\n  const focusChild = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getFocusChild)(snapshot);\n  return focusChild && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextSpan)(focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}, getSelectedTextBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedTextBlocks = [], startKey = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0, endKey = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0;\n  if (!startKey || !endKey)\n    return selectedTextBlocks;\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      if ((0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) && selectedTextBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      }), startKey === endKey)\n        break;\n      continue;\n    }\n    if (block._key === endKey) {\n      (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) && selectedTextBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      });\n      break;\n    }\n    selectedTextBlocks.length > 0 && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) && selectedTextBlocks.push({\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    });\n  }\n  return selectedTextBlocks;\n}, getTrimmedSelection = (snapshot) => {\n  if (!snapshot.context.selection)\n    return snapshot.context.selection;\n  const startPoint = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionStartPoint)(snapshot), endPoint = getSelectionEndPoint(snapshot);\n  if (!startPoint || !endPoint)\n    return snapshot.context.selection;\n  const startBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(startPoint.path[0]) ? startPoint.path[0]._key : null, startChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(startPoint.path[2]) ? startPoint.path[2]._key : null, endBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(endPoint.path[0]) ? endPoint.path[0]._key : null, endChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(endPoint.path[2]) ? endPoint.path[2]._key : null;\n  if (!startBlockKey || !endBlockKey)\n    return snapshot.context.selection;\n  let startBlockFound = !1, adjustedStartPoint, trimStartPoint = !1, adjustedEndPoint, trimEndPoint = !1, previousPotentialEndpoint;\n  for (const block of snapshot.context.value)\n    if (!(block._key === startBlockKey && (startBlockFound = !0, (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) && (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEmptyTextBlock)(snapshot.context, block))) && startBlockFound && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block)) {\n      if (block._key === endBlockKey && (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEmptyTextBlock)(snapshot.context, block))\n        break;\n      for (const child of block.children) {\n        if (child._key === endChildKey && (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child) || endPoint.offset === 0)) {\n          adjustedEndPoint = previousPotentialEndpoint ? {\n            path: [{\n              _key: previousPotentialEndpoint.blockKey\n            }, \"children\", {\n              _key: previousPotentialEndpoint.span._key\n            }],\n            offset: previousPotentialEndpoint.span.text.length\n          } : void 0, trimEndPoint = !0;\n          break;\n        }\n        if (trimStartPoint) {\n          const lonelySpan = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child) && block.children.length === 1;\n          ((0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child) && child.text.length > 0 || lonelySpan) && (adjustedStartPoint = {\n            path: [{\n              _key: block._key\n            }, \"children\", {\n              _key: child._key\n            }],\n            offset: 0\n          }, previousPotentialEndpoint = {\n            blockKey: block._key,\n            span: child\n          }, trimStartPoint = !1);\n          continue;\n        }\n        if (child._key === startChildKey) {\n          if (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child)) {\n            trimStartPoint = !0;\n            continue;\n          }\n          if (startPoint.offset === child.text.length) {\n            trimStartPoint = !0, previousPotentialEndpoint = child.text.length > 0 ? {\n              blockKey: block._key,\n              span: child\n            } : previousPotentialEndpoint;\n            continue;\n          }\n        }\n        previousPotentialEndpoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child) && child.text.length > 0 ? {\n          blockKey: block._key,\n          span: child\n        } : previousPotentialEndpoint;\n      }\n      if (block._key === endBlockKey)\n        break;\n    }\n  const trimmedSelection = snapshot.context.selection.backward ? {\n    anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n    focus: adjustedStartPoint ?? startPoint,\n    backward: !0\n  } : {\n    anchor: adjustedStartPoint ?? startPoint,\n    focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint\n  };\n  if ((0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n    context: {\n      ...snapshot.context,\n      selection: trimmedSelection\n    }\n  })) {\n    const focusTextBlock = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection\n      }\n    });\n    if (focusTextBlock && !(0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node))\n      return null;\n  }\n  return trimmedSelection;\n};\nfunction isActiveAnnotation(annotation) {\n  return (snapshot) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const selectedBlocks = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)(snapshot), focusSpan = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)(snapshot), selectedSpans = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionExpanded)(snapshot) ? getSelectedSpans(snapshot) : focusSpan ? [focusSpan] : [];\n    if (selectedSpans.length === 0 || selectedSpans.some((span) => !span.node.marks || span.node.marks?.length === 0))\n      return !1;\n    const selectionMarkDefs = selectedBlocks.flatMap((block) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block.node) ? block.node.markDefs ?? [] : []);\n    return selectedSpans.every((span) => (span.node.marks?.flatMap((mark) => {\n      const markDef = selectionMarkDefs.find((markDef2) => markDef2._key === mark);\n      return markDef ? [markDef._type] : [];\n    }) ?? []).includes(annotation));\n  };\n}\nfunction isActiveDecorator(decorator) {\n  return (snapshot) => {\n    if ((0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionExpanded)(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot);\n      return selectedSpans.length > 0 && selectedSpans.every((span) => span.node.marks?.includes(decorator));\n    }\n    return snapshot.context.activeDecorators.includes(decorator);\n  };\n}\nfunction isActiveListItem(listItem) {\n  return (snapshot) => getActiveListItem(snapshot) === listItem;\n}\nfunction isActiveStyle(style) {\n  return (snapshot) => getActiveStyle(snapshot) === style;\n}\nfunction isAtTheEndOfBlock(block) {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !(0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const blockEndPoint = (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.getBlockEndPoint)({\n      context: snapshot.context,\n      block\n    });\n    return (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEqualSelectionPoints)(snapshot.context.selection.focus, blockEndPoint);\n  };\n}\nfunction isAtTheStartOfBlock(block) {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !(0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const blockStartPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint)({\n      context: snapshot.context,\n      block\n    });\n    return (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEqualSelectionPoints)(snapshot.context.selection.focus, blockStartPoint);\n  };\n}\nfunction isPointAfterSelection(point) {\n  return (snapshot) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const selection = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.reverseSelection)(snapshot.context.selection) : snapshot.context.selection, pointBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(point.path[0]) ? point.path[0]._key : void 0, pointChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(point.path[2]) ? point.path[2]._key : void 0, endBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selection.focus.path[0]) ? selection.focus.path[0]._key : void 0, endChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selection.focus.path[2]) ? selection.focus.path[2]._key : void 0;\n    if (!pointBlockKey || !endBlockKey)\n      return !1;\n    let after = !1;\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = !0;\n          break;\n        }\n        if (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) || !pointChildKey || !endChildKey)\n          break;\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = !0;\n              break;\n            }\n            after = point.offset > selection.focus.offset;\n            break;\n          }\n          if (child._key === pointChildKey)\n            break;\n        }\n      }\n      if (block._key === pointBlockKey)\n        break;\n    }\n    return after;\n  };\n}\nfunction isPointBeforeSelection(point) {\n  return (snapshot) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const selection = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.reverseSelection)(snapshot.context.selection) : snapshot.context.selection, pointBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(point.path[0]) ? point.path[0]._key : void 0, pointChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(point.path[2]) ? point.path[2]._key : void 0, startBlockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selection.anchor.path[0]) ? selection.anchor.path[0]._key : void 0, startChildKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selection.anchor.path[2]) ? selection.anchor.path[2]._key : void 0;\n    if (!pointBlockKey || !startBlockKey)\n      return !1;\n    let before = !1;\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = !0;\n          break;\n        }\n        if (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) || !pointChildKey || !startChildKey)\n          break;\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = !0;\n              break;\n            }\n            before = point.offset < selection.anchor.offset;\n            break;\n          }\n          if (child._key === startChildKey)\n            break;\n        }\n      }\n      if (block._key === startBlockKey)\n        break;\n    }\n    return before;\n  };\n}\nfunction isOverlappingSelection(selection) {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection)\n      return !1;\n    const selectionStartPoint = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionStartPoint)({\n      context: {\n        ...snapshot.context,\n        selection\n      }\n    }), selectionEndPoint = getSelectionEndPoint({\n      context: {\n        ...snapshot.context,\n        selection\n      }\n    }), originalSelectionStartPoint = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionStartPoint)(snapshot), originalSelectionEndPoint = getSelectionEndPoint(snapshot);\n    if (!selectionStartPoint || !selectionEndPoint || !originalSelectionStartPoint || !originalSelectionEndPoint)\n      return !1;\n    const startPointBeforeSelection = isPointBeforeSelection(selectionStartPoint)(snapshot), startPointAfterSelection = isPointAfterSelection(selectionStartPoint)(snapshot), endPointBeforeSelection = isPointBeforeSelection(selectionEndPoint)(snapshot), endPointAfterSelection = isPointAfterSelection(selectionEndPoint)(snapshot), originalStartPointBeforeStartPoint = isPointBeforeSelection(originalSelectionStartPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint\n        }\n      }\n    }), originalStartPointAfterStartPoint = isPointAfterSelection(originalSelectionStartPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint\n        }\n      }\n    }), originalEndPointBeforeEndPoint = isPointBeforeSelection(originalSelectionEndPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint\n        }\n      }\n    }), originalEndPointAfterEndPoint = isPointAfterSelection(originalSelectionEndPoint)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint\n        }\n      }\n    }), endPointEqualToOriginalStartPoint = (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEqualSelectionPoints)(selectionEndPoint, originalSelectionStartPoint), startPointEqualToOriginalEndPoint = (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEqualSelectionPoints)(selectionStartPoint, originalSelectionEndPoint);\n    return endPointBeforeSelection && !endPointEqualToOriginalStartPoint || startPointAfterSelection && !startPointEqualToOriginalEndPoint ? !1 : !originalStartPointBeforeStartPoint && originalStartPointAfterStartPoint && !originalEndPointBeforeEndPoint && originalEndPointAfterEndPoint ? !endPointEqualToOriginalStartPoint : originalStartPointBeforeStartPoint && !originalStartPointAfterStartPoint && originalEndPointBeforeEndPoint && !originalEndPointAfterEndPoint ? !startPointEqualToOriginalEndPoint : !startPointAfterSelection || !startPointBeforeSelection || !endPointAfterSelection || !endPointBeforeSelection;\n  };\n}\nconst isSelectingEntireBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return !1;\n  const startPoint = snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor, endPoint = snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus, startBlock = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionStartBlock)(snapshot), endBlock = (0,_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_1__.getSelectionEndBlock)(snapshot);\n  if (!startBlock || !endBlock)\n    return !1;\n  const startBlockStartPoint = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint)({\n    context: snapshot.context,\n    block: startBlock\n  }), endBlockEndPoint = (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.getBlockEndPoint)({\n    context: snapshot.context,\n    block: endBlock\n  });\n  return (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEqualSelectionPoints)(startBlockStartPoint, startPoint) && (0,_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_3__.isEqualSelectionPoints)(endBlockEndPoint, endPoint);\n};\n\n//# sourceMappingURL=selector.is-selecting-entire-blocks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW5nLWVudGlyZS1ibG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFOO0FBQytEO0FBQ25LO0FBQ2hEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDRSQUE0UixxRUFBYyx1RUFBdUUscUVBQWM7QUFDL1g7QUFDQTtBQUNBLHVCQUF1QixxRUFBYyxzRUFBc0UscUVBQWM7QUFDekg7QUFDQTtBQUNBLGtFQUFrRSxrRUFBVztBQUM3RTtBQUNBO0FBQ0EsY0FBYywrREFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EseUJBQXlCLHFGQUFpQixvRUFBb0UsZ0ZBQVk7QUFDMUg7QUFDQTtBQUNBLG9DQUFvQyx3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eHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmlzLXNlbGVjdGluZy1lbnRpcmUtYmxvY2tzLmpzPzE5NjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUZXh0QmxvY2ssIGlzU3BhbiQxIGFzIGlzU3BhbiwgaXNLZXllZFNlZ21lbnQsIGlzU3BhbiBhcyBpc1NwYW4kMSwgc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCwgZ2V0QmxvY2tTdGFydFBvaW50LCBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LCByZXZlcnNlU2VsZWN0aW9uIH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGdldFNlbGVjdGVkQmxvY2tzLCBnZXRGb2N1c1NwYW4sIGlzU2VsZWN0aW9uQ29sbGFwc2VkLCBnZXRGb2N1c1RleHRCbG9jaywgZ2V0U2VsZWN0aW9uU3RhcnRQb2ludCwgZ2V0UHJldmlvdXNJbmxpbmVPYmplY3QsIGdldFNlbGVjdGlvblRleHQsIGlzU2VsZWN0aW9uRXhwYW5kZWQsIGdldEZvY3VzQ2hpbGQsIGdldFNlbGVjdGlvblN0YXJ0QmxvY2ssIGdldFNlbGVjdGlvbkVuZEJsb2NrIH0gZnJvbSBcIi4vc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWV4cGFuZGVkLmpzXCI7XG5pbXBvcnQgeyBnZXRCbG9ja0VuZFBvaW50LCBpc0VtcHR5VGV4dEJsb2NrLCBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzIH0gZnJvbSBcIi4vdXRpbC5pcy1lcXVhbC1zZWxlY3Rpb24tcG9pbnRzLmpzXCI7XG5pbXBvcnQgeyBpc0tleVNlZ21lbnQsIGlzUG9ydGFibGVUZXh0U3BhbiB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5jb25zdCBnZXRTZWxlY3RlZFNwYW5zID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBzZWxlY3RlZFNwYW5zID0gW10sIHN0YXJ0UG9pbnQgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzIDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLCBlbmRQb2ludCA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yIDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMsIHN0YXJ0QmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChzdGFydFBvaW50LnBhdGhbMF0pID8gc3RhcnRQb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIGVuZEJsb2NrS2V5ID0gaXNLZXllZFNlZ21lbnQoZW5kUG9pbnQucGF0aFswXSkgPyBlbmRQb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghc3RhcnRCbG9ja0tleSB8fCAhZW5kQmxvY2tLZXkpXG4gICAgcmV0dXJuIHNlbGVjdGVkU3BhbnM7XG4gIGNvbnN0IHN0YXJ0U3BhbktleSA9IGlzS2V5ZWRTZWdtZW50KHN0YXJ0UG9pbnQucGF0aFsyXSkgPyBzdGFydFBvaW50LnBhdGhbMl0uX2tleSA6IHZvaWQgMCwgZW5kU3BhbktleSA9IGlzS2V5ZWRTZWdtZW50KGVuZFBvaW50LnBhdGhbMl0pID8gZW5kUG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICBsZXQgc3RhcnRCbG9ja0ZvdW5kID0gITE7XG4gIGZvciAoY29uc3QgYmxvY2sgb2Ygc25hcHNob3QuY29udGV4dC52YWx1ZSlcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSAmJiAoc3RhcnRCbG9ja0ZvdW5kID0gITApLCAhIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSkge1xuICAgICAgaWYgKGJsb2NrLl9rZXkgPT09IHN0YXJ0QmxvY2tLZXkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0U3BhbktleSAmJiBjaGlsZC5fa2V5ID09PSBzdGFydFNwYW5LZXkpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQub2Zmc2V0IDwgY2hpbGQudGV4dC5sZW5ndGggJiYgc2VsZWN0ZWRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgIH0pLCBzdGFydFNwYW5LZXkgPT09IGVuZFNwYW5LZXkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZFNwYW5LZXkgJiYgY2hpbGQuX2tleSA9PT0gZW5kU3BhbktleSkge1xuICAgICAgICAgICAgICBlbmRQb2ludC5vZmZzZXQgPiAwICYmIHNlbGVjdGVkU3BhbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZFNwYW5zLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEJsb2NrS2V5ID09PSBlbmRCbG9ja0tleSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSkge1xuICAgICAgICAgICAgaWYgKGVuZFNwYW5LZXkgJiYgY2hpbGQuX2tleSA9PT0gZW5kU3BhbktleSkge1xuICAgICAgICAgICAgICBlbmRQb2ludC5vZmZzZXQgPiAwICYmIHNlbGVjdGVkU3BhbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZFNwYW5zLnB1c2goe1xuICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRCbG9ja0ZvdW5kKVxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICAgIGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgJiYgc2VsZWN0ZWRTcGFucy5wdXNoKHtcbiAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSk7XG4gICAgfVxuICByZXR1cm4gc2VsZWN0ZWRTcGFucztcbn0sIGdldEFjdGl2ZUFubm90YXRpb25zID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KSwgc2VsZWN0ZWRTcGFucyA9IGdldFNlbGVjdGVkU3BhbnMoc25hcHNob3QpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpO1xuICBpZiAoc2VsZWN0ZWRTcGFucy5sZW5ndGggPT09IDAgfHwgIWZvY3VzU3BhbilcbiAgICByZXR1cm4gW107XG4gIGlmIChzZWxlY3RlZFNwYW5zLmxlbmd0aCA9PT0gMSAmJiBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCkpIHtcbiAgICBpZiAoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMub2Zmc2V0ID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPT09IGZvY3VzU3Bhbi5ub2RlLnRleHQubGVuZ3RoKVxuICAgICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2subm9kZSkgPyBibG9jay5ub2RlLm1hcmtEZWZzID8/IFtdIDogW10pLmZpbHRlcigobWFya0RlZikgPT4gc2VsZWN0ZWRTcGFucy5zb21lKChzcGFuKSA9PiBzcGFuLm5vZGUubWFya3M/LmluY2x1ZGVzKG1hcmtEZWYuX2tleSkpKTtcbn0sIGdldEFjdGl2ZUxpc3RJdGVtID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBzZWxlY3RlZFRleHRCbG9ja3MgPSBnZXRTZWxlY3RlZEJsb2NrcyhzbmFwc2hvdCkubWFwKChibG9jaykgPT4gYmxvY2subm9kZSkuZmlsdGVyKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spKSwgZmlyc3RUZXh0QmxvY2sgPSBzZWxlY3RlZFRleHRCbG9ja3MuYXQoMCk7XG4gIGlmICghZmlyc3RUZXh0QmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBmaXJzdExpc3RJdGVtID0gZmlyc3RUZXh0QmxvY2subGlzdEl0ZW07XG4gIGlmIChmaXJzdExpc3RJdGVtICYmIHNlbGVjdGVkVGV4dEJsb2Nrcy5ldmVyeSgoYmxvY2spID0+IGJsb2NrLmxpc3RJdGVtID09PSBmaXJzdExpc3RJdGVtKSlcbiAgICByZXR1cm4gZmlyc3RMaXN0SXRlbTtcbn0sIGdldEFjdGl2ZVN0eWxlID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBzZWxlY3RlZFRleHRCbG9ja3MgPSBnZXRTZWxlY3RlZEJsb2NrcyhzbmFwc2hvdCkubWFwKChibG9jaykgPT4gYmxvY2subm9kZSkuZmlsdGVyKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spKSwgZmlyc3RUZXh0QmxvY2sgPSBzZWxlY3RlZFRleHRCbG9ja3MuYXQoMCk7XG4gIGlmICghZmlyc3RUZXh0QmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBmaXJzdFN0eWxlID0gZmlyc3RUZXh0QmxvY2suc3R5bGU7XG4gIGlmIChmaXJzdFN0eWxlICYmIHNlbGVjdGVkVGV4dEJsb2Nrcy5ldmVyeSgoYmxvY2spID0+IGJsb2NrLnN0eWxlID09PSBmaXJzdFN0eWxlKSlcbiAgICByZXR1cm4gZmlyc3RTdHlsZTtcbn0sIGdldFNlbGVjdGlvbkVuZFBvaW50ID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmIChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IgOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cztcbn0sIGdldE5leHRJbmxpbmVPYmplY3QgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QpLCBzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5ID0gc2VsZWN0aW9uRW5kUG9pbnQgJiYgaXNLZXlTZWdtZW50KHNlbGVjdGlvbkVuZFBvaW50LnBhdGhbMl0pID8gc2VsZWN0aW9uRW5kUG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5KVxuICAgIHJldHVybjtcbiAgbGV0IGVuZFBvaW50Q2hpbGRGb3VuZCA9ICExLCBpbmxpbmVPYmplY3Q7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZC5fa2V5ID09PSBzZWxlY3Rpb25FbmRQb2ludENoaWxkS2V5KSB7XG4gICAgICBlbmRQb2ludENoaWxkRm91bmQgPSAhMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWlzU3BhbiQxKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSAmJiBlbmRQb2ludENoaWxkRm91bmQpIHtcbiAgICAgIGlubGluZU9iamVjdCA9IHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBhdGg6IFsuLi5mb2N1c1RleHRCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmxpbmVPYmplY3Q7XG59LCBnZXRDYXJldFdvcmRTZWxlY3Rpb24gPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QpLCBzZWxlY3Rpb25TdGFydE9mZnNldCA9IHNlbGVjdGlvblN0YXJ0UG9pbnQgPyBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIHNlbGVjdGlvblBvaW50OiBzZWxlY3Rpb25TdGFydFBvaW50XG4gIH0pIDogdm9pZCAwO1xuICBpZiAoIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25TdGFydFBvaW50IHx8ICFzZWxlY3Rpb25TdGFydE9mZnNldClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgcHJldmlvdXNJbmxpbmVPYmplY3QgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdChzbmFwc2hvdCksIGJsb2NrU3RhcnRQb2ludCA9IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBibG9jazogZm9jdXNUZXh0QmxvY2tcbiAgfSksIHRleHREaXJlY3RseUJlZm9yZSA9IGdldFNlbGVjdGlvblRleHQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiBwcmV2aW91c0lubGluZU9iamVjdCA/IHtcbiAgICAgICAgICBwYXRoOiBwcmV2aW91c0lubGluZU9iamVjdC5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9IDogYmxvY2tTdGFydFBvaW50LFxuICAgICAgICBmb2N1czogc2VsZWN0aW9uU3RhcnRQb2ludFxuICAgICAgfVxuICAgIH1cbiAgfSkuc3BsaXQoL1xccysvKS5hdCgtMSksIG5leHRJbmxpbmVPYmplY3QgPSBnZXROZXh0SW5saW5lT2JqZWN0KHNuYXBzaG90KSwgYmxvY2tFbmRQb2ludCA9IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgYmxvY2s6IGZvY3VzVGV4dEJsb2NrXG4gIH0pLCB0ZXh0RGlyZWN0bHlBZnRlciA9IGdldFNlbGVjdGlvblRleHQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25TdGFydFBvaW50LFxuICAgICAgICBmb2N1czogbmV4dElubGluZU9iamVjdCA/IHtcbiAgICAgICAgICBwYXRoOiBuZXh0SW5saW5lT2JqZWN0LnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0gOiBibG9ja0VuZFBvaW50XG4gICAgICB9XG4gICAgfVxuICB9KS5zcGxpdCgvXFxzKy8pLmF0KDApO1xuICBpZiAoKHRleHREaXJlY3RseUJlZm9yZSA9PT0gdm9pZCAwIHx8IHRleHREaXJlY3RseUJlZm9yZSA9PT0gXCJcIikgJiYgKHRleHREaXJlY3RseUFmdGVyID09PSB2b2lkIDAgfHwgdGV4dERpcmVjdGx5QWZ0ZXIgPT09IFwiXCIpKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBjYXJldFdvcmRTdGFydE9mZnNldCA9IHRleHREaXJlY3RseUJlZm9yZSA/IHtcbiAgICAuLi5zZWxlY3Rpb25TdGFydE9mZnNldCxcbiAgICBvZmZzZXQ6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0Lm9mZnNldCAtIHRleHREaXJlY3RseUJlZm9yZS5sZW5ndGhcbiAgfSA6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0LCBjYXJldFdvcmRFbmRPZmZzZXQgPSB0ZXh0RGlyZWN0bHlBZnRlciA/IHtcbiAgICAuLi5zZWxlY3Rpb25TdGFydE9mZnNldCxcbiAgICBvZmZzZXQ6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0Lm9mZnNldCArIHRleHREaXJlY3RseUFmdGVyLmxlbmd0aFxuICB9IDogc2VsZWN0aW9uU3RhcnRPZmZzZXQsIGNhcmV0V29yZFN0YXJ0U2VsZWN0aW9uUG9pbnQgPSBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGJsb2NrT2Zmc2V0OiBjYXJldFdvcmRTdGFydE9mZnNldCxcbiAgICBkaXJlY3Rpb246IFwiYmFja3dhcmRcIlxuICB9KSwgY2FyZXRXb3JkRW5kU2VsZWN0aW9uUG9pbnQgPSBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGJsb2NrT2Zmc2V0OiBjYXJldFdvcmRFbmRPZmZzZXQsXG4gICAgZGlyZWN0aW9uOiBcImZvcndhcmRcIlxuICB9KTtcbiAgaWYgKCFjYXJldFdvcmRTdGFydFNlbGVjdGlvblBvaW50IHx8ICFjYXJldFdvcmRFbmRTZWxlY3Rpb25Qb2ludClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2FyZXRXb3JkU2VsZWN0aW9uID0ge1xuICAgIGFuY2hvcjogY2FyZXRXb3JkU3RhcnRTZWxlY3Rpb25Qb2ludCxcbiAgICBmb2N1czogY2FyZXRXb3JkRW5kU2VsZWN0aW9uUG9pbnRcbiAgfTtcbiAgcmV0dXJuIGlzU2VsZWN0aW9uRXhwYW5kZWQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IGNhcmV0V29yZFNlbGVjdGlvblxuICAgIH1cbiAgfSkgPyBjYXJldFdvcmRTZWxlY3Rpb24gOiBudWxsO1xufSwgZ2V0Rm9jdXNJbmxpbmVPYmplY3QgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNDaGlsZCA9IGdldEZvY3VzQ2hpbGQoc25hcHNob3QpO1xuICByZXR1cm4gZm9jdXNDaGlsZCAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKGZvY3VzQ2hpbGQubm9kZSkgPyB7XG4gICAgbm9kZTogZm9jdXNDaGlsZC5ub2RlLFxuICAgIHBhdGg6IGZvY3VzQ2hpbGQucGF0aFxuICB9IDogdm9pZCAwO1xufSwgZ2V0U2VsZWN0ZWRUZXh0QmxvY2tzID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBzZWxlY3RlZFRleHRCbG9ja3MgPSBbXSwgc3RhcnRLZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5ZWRTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXllZFNlZ21lbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgZW5kS2V5ID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBpc0tleWVkU2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXllZFNlZ21lbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghc3RhcnRLZXkgfHwgIWVuZEtleSlcbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0QmxvY2tzO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHNuYXBzaG90LmNvbnRleHQudmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRLZXkpIHtcbiAgICAgIGlmIChpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgJiYgc2VsZWN0ZWRUZXh0QmxvY2tzLnB1c2goe1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KSwgc3RhcnRLZXkgPT09IGVuZEtleSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEtleSkge1xuICAgICAgaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spICYmIHNlbGVjdGVkVGV4dEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzLmxlbmd0aCA+IDAgJiYgaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spICYmIHNlbGVjdGVkVGV4dEJsb2Nrcy5wdXNoKHtcbiAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgcGF0aDogW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWRUZXh0QmxvY2tzO1xufSwgZ2V0VHJpbW1lZFNlbGVjdGlvbiA9IChzbmFwc2hvdCkgPT4ge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgY29uc3Qgc3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QpLCBlbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNuYXBzaG90KTtcbiAgaWYgKCFzdGFydFBvaW50IHx8ICFlbmRQb2ludClcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb247XG4gIGNvbnN0IHN0YXJ0QmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChzdGFydFBvaW50LnBhdGhbMF0pID8gc3RhcnRQb2ludC5wYXRoWzBdLl9rZXkgOiBudWxsLCBzdGFydENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoc3RhcnRQb2ludC5wYXRoWzJdKSA/IHN0YXJ0UG9pbnQucGF0aFsyXS5fa2V5IDogbnVsbCwgZW5kQmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChlbmRQb2ludC5wYXRoWzBdKSA/IGVuZFBvaW50LnBhdGhbMF0uX2tleSA6IG51bGwsIGVuZENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoZW5kUG9pbnQucGF0aFsyXSkgPyBlbmRQb2ludC5wYXRoWzJdLl9rZXkgOiBudWxsO1xuICBpZiAoIXN0YXJ0QmxvY2tLZXkgfHwgIWVuZEJsb2NrS2V5KVxuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbjtcbiAgbGV0IHN0YXJ0QmxvY2tGb3VuZCA9ICExLCBhZGp1c3RlZFN0YXJ0UG9pbnQsIHRyaW1TdGFydFBvaW50ID0gITEsIGFkanVzdGVkRW5kUG9pbnQsIHRyaW1FbmRQb2ludCA9ICExLCBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHNuYXBzaG90LmNvbnRleHQudmFsdWUpXG4gICAgaWYgKCEoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSAmJiAoc3RhcnRCbG9ja0ZvdW5kID0gITAsIGlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSAmJiBpc0VtcHR5VGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSkpICYmIHN0YXJ0QmxvY2tGb3VuZCAmJiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykpIHtcbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRCbG9ja0tleSAmJiBpc0VtcHR5VGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBlbmRDaGlsZEtleSAmJiAoIWlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgfHwgZW5kUG9pbnQub2Zmc2V0ID09PSAwKSkge1xuICAgICAgICAgIGFkanVzdGVkRW5kUG9pbnQgPSBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50ID8ge1xuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludC5ibG9ja0tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQuc3Bhbi5fa2V5XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9mZnNldDogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludC5zcGFuLnRleHQubGVuZ3RoXG4gICAgICAgICAgfSA6IHZvaWQgMCwgdHJpbUVuZFBvaW50ID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1TdGFydFBvaW50KSB7XG4gICAgICAgICAgY29uc3QgbG9uZWx5U3BhbiA9IGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBjaGlsZCkgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxO1xuICAgICAgICAgIChpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpICYmIGNoaWxkLnRleHQubGVuZ3RoID4gMCB8fCBsb25lbHlTcGFuKSAmJiAoYWRqdXN0ZWRTdGFydFBvaW50ID0ge1xuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfSwgcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludCA9IHtcbiAgICAgICAgICAgIGJsb2NrS2V5OiBibG9jay5fa2V5LFxuICAgICAgICAgICAgc3BhbjogY2hpbGRcbiAgICAgICAgICB9LCB0cmltU3RhcnRQb2ludCA9ICExKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gc3RhcnRDaGlsZEtleSkge1xuICAgICAgICAgIGlmICghaXNTcGFuKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSkge1xuICAgICAgICAgICAgdHJpbVN0YXJ0UG9pbnQgPSAhMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRQb2ludC5vZmZzZXQgPT09IGNoaWxkLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmltU3RhcnRQb2ludCA9ICEwLCBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50ID0gY2hpbGQudGV4dC5sZW5ndGggPiAwID8ge1xuICAgICAgICAgICAgICBibG9ja0tleTogYmxvY2suX2tleSxcbiAgICAgICAgICAgICAgc3BhbjogY2hpbGRcbiAgICAgICAgICAgIH0gOiBwcmV2aW91c1BvdGVudGlhbEVuZHBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzUG90ZW50aWFsRW5kcG9pbnQgPSBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpICYmIGNoaWxkLnRleHQubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICBibG9ja0tleTogYmxvY2suX2tleSxcbiAgICAgICAgICBzcGFuOiBjaGlsZFxuICAgICAgICB9IDogcHJldmlvdXNQb3RlbnRpYWxFbmRwb2ludDtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRCbG9ja0tleSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICBjb25zdCB0cmltbWVkU2VsZWN0aW9uID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyB7XG4gICAgYW5jaG9yOiB0cmltRW5kUG9pbnQgJiYgYWRqdXN0ZWRFbmRQb2ludCA/IGFkanVzdGVkRW5kUG9pbnQgOiBlbmRQb2ludCxcbiAgICBmb2N1czogYWRqdXN0ZWRTdGFydFBvaW50ID8/IHN0YXJ0UG9pbnQsXG4gICAgYmFja3dhcmQ6ICEwXG4gIH0gOiB7XG4gICAgYW5jaG9yOiBhZGp1c3RlZFN0YXJ0UG9pbnQgPz8gc3RhcnRQb2ludCxcbiAgICBmb2N1czogdHJpbUVuZFBvaW50ICYmIGFkanVzdGVkRW5kUG9pbnQgPyBhZGp1c3RlZEVuZFBvaW50IDogZW5kUG9pbnRcbiAgfTtcbiAgaWYgKGlzU2VsZWN0aW9uQ29sbGFwc2VkKHtcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgc2VsZWN0aW9uOiB0cmltbWVkU2VsZWN0aW9uXG4gICAgfVxuICB9KSkge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IHRyaW1tZWRTZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZm9jdXNUZXh0QmxvY2sgJiYgIWlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNUZXh0QmxvY2subm9kZSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdHJpbW1lZFNlbGVjdGlvbjtcbn07XG5mdW5jdGlvbiBpc0FjdGl2ZUFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KSwgc2VsZWN0ZWRTcGFucyA9IGlzU2VsZWN0aW9uRXhwYW5kZWQoc25hcHNob3QpID8gZ2V0U2VsZWN0ZWRTcGFucyhzbmFwc2hvdCkgOiBmb2N1c1NwYW4gPyBbZm9jdXNTcGFuXSA6IFtdO1xuICAgIGlmIChzZWxlY3RlZFNwYW5zLmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RlZFNwYW5zLnNvbWUoKHNwYW4pID0+ICFzcGFuLm5vZGUubWFya3MgfHwgc3Bhbi5ub2RlLm1hcmtzPy5sZW5ndGggPT09IDApKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGlvbk1hcmtEZWZzID0gc2VsZWN0ZWRCbG9ja3MuZmxhdE1hcCgoYmxvY2spID0+IGlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrLm5vZGUpID8gYmxvY2subm9kZS5tYXJrRGVmcyA/PyBbXSA6IFtdKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTcGFucy5ldmVyeSgoc3BhbikgPT4gKHNwYW4ubm9kZS5tYXJrcz8uZmxhdE1hcCgobWFyaykgPT4ge1xuICAgICAgY29uc3QgbWFya0RlZiA9IHNlbGVjdGlvbk1hcmtEZWZzLmZpbmQoKG1hcmtEZWYyKSA9PiBtYXJrRGVmMi5fa2V5ID09PSBtYXJrKTtcbiAgICAgIHJldHVybiBtYXJrRGVmID8gW21hcmtEZWYuX3R5cGVdIDogW107XG4gICAgfSkgPz8gW10pLmluY2x1ZGVzKGFubm90YXRpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWN0aXZlRGVjb3JhdG9yKGRlY29yYXRvcikge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKGlzU2VsZWN0aW9uRXhwYW5kZWQoc25hcHNob3QpKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFNwYW5zID0gZ2V0U2VsZWN0ZWRTcGFucyhzbmFwc2hvdCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRTcGFucy5sZW5ndGggPiAwICYmIHNlbGVjdGVkU3BhbnMuZXZlcnkoKHNwYW4pID0+IHNwYW4ubm9kZS5tYXJrcz8uaW5jbHVkZXMoZGVjb3JhdG9yKSk7XG4gICAgfVxuICAgIHJldHVybiBzbmFwc2hvdC5jb250ZXh0LmFjdGl2ZURlY29yYXRvcnMuaW5jbHVkZXMoZGVjb3JhdG9yKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWN0aXZlTGlzdEl0ZW0obGlzdEl0ZW0pIHtcbiAgcmV0dXJuIChzbmFwc2hvdCkgPT4gZ2V0QWN0aXZlTGlzdEl0ZW0oc25hcHNob3QpID09PSBsaXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGlzQWN0aXZlU3R5bGUoc3R5bGUpIHtcbiAgcmV0dXJuIChzbmFwc2hvdCkgPT4gZ2V0QWN0aXZlU3R5bGUoc25hcHNob3QpID09PSBzdHlsZTtcbn1cbmZ1bmN0aW9uIGlzQXRUaGVFbmRPZkJsb2NrKGJsb2NrKSB7XG4gIHJldHVybiAoc25hcHNob3QpID0+IHtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYmxvY2tFbmRQb2ludCA9IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMsIGJsb2NrRW5kUG9pbnQpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBdFRoZVN0YXJ0T2ZCbG9jayhibG9jaykge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGJsb2NrU3RhcnRQb2ludCA9IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2tcbiAgICB9KTtcbiAgICByZXR1cm4gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cywgYmxvY2tTdGFydFBvaW50KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRBZnRlclNlbGVjdGlvbihwb2ludCkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHJldmVyc2VTZWxlY3Rpb24oc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pIDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24sIHBvaW50QmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChwb2ludC5wYXRoWzBdKSA/IHBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgcG9pbnRDaGlsZEtleSA9IGlzS2V5ZWRTZWdtZW50KHBvaW50LnBhdGhbMl0pID8gcG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwLCBlbmRCbG9ja0tleSA9IGlzS2V5ZWRTZWdtZW50KHNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IHNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIGVuZENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0pID8gc2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0uX2tleSA6IHZvaWQgMDtcbiAgICBpZiAoIXBvaW50QmxvY2tLZXkgfHwgIWVuZEJsb2NrS2V5KVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBhZnRlciA9ICExO1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2Ygc25hcHNob3QuY29udGV4dC52YWx1ZSkge1xuICAgICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEJsb2NrS2V5KSB7XG4gICAgICAgIGlmIChibG9jay5fa2V5ICE9PSBwb2ludEJsb2NrS2V5KSB7XG4gICAgICAgICAgYWZ0ZXIgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrKSB8fCAhcG9pbnRDaGlsZEtleSB8fCAhZW5kQ2hpbGRLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5fa2V5ICE9PSBwb2ludENoaWxkS2V5KSB7XG4gICAgICAgICAgICAgIGFmdGVyID0gITA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWZ0ZXIgPSBwb2ludC5vZmZzZXQgPiBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBwb2ludENoaWxkS2V5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBwb2ludEJsb2NrS2V5KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFmdGVyO1xuICB9O1xufVxuZnVuY3Rpb24gaXNQb2ludEJlZm9yZVNlbGVjdGlvbihwb2ludCkge1xuICByZXR1cm4gKHNuYXBzaG90KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHJldmVyc2VTZWxlY3Rpb24oc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pIDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24sIHBvaW50QmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChwb2ludC5wYXRoWzBdKSA/IHBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgcG9pbnRDaGlsZEtleSA9IGlzS2V5ZWRTZWdtZW50KHBvaW50LnBhdGhbMl0pID8gcG9pbnQucGF0aFsyXS5fa2V5IDogdm9pZCAwLCBzdGFydEJsb2NrS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IHNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwLCBzdGFydENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdKSA/IHNlbGVjdGlvbi5hbmNob3IucGF0aFsyXS5fa2V5IDogdm9pZCAwO1xuICAgIGlmICghcG9pbnRCbG9ja0tleSB8fCAhc3RhcnRCbG9ja0tleSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgYmVmb3JlID0gITE7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlKSB7XG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gcG9pbnRCbG9ja0tleSkge1xuICAgICAgICBpZiAoYmxvY2suX2tleSAhPT0gc3RhcnRCbG9ja0tleSkge1xuICAgICAgICAgIGJlZm9yZSA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spIHx8ICFwb2ludENoaWxkS2V5IHx8ICFzdGFydENoaWxkS2V5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLl9rZXkgPT09IHBvaW50Q2hpbGRLZXkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5fa2V5ICE9PSBzdGFydENoaWxkS2V5KSB7XG4gICAgICAgICAgICAgIGJlZm9yZSA9ICEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZm9yZSA9IHBvaW50Lm9mZnNldCA8IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBzdGFydENoaWxkS2V5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBzdGFydEJsb2NrS2V5KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGJlZm9yZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHJldHVybiAoc25hcHNob3QpID0+IHtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSwgc2VsZWN0aW9uRW5kUG9pbnQgPSBnZXRTZWxlY3Rpb25FbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pLCBvcmlnaW5hbFNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90KSwgb3JpZ2luYWxTZWxlY3Rpb25FbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNuYXBzaG90KTtcbiAgICBpZiAoIXNlbGVjdGlvblN0YXJ0UG9pbnQgfHwgIXNlbGVjdGlvbkVuZFBvaW50IHx8ICFvcmlnaW5hbFNlbGVjdGlvblN0YXJ0UG9pbnQgfHwgIW9yaWdpbmFsU2VsZWN0aW9uRW5kUG9pbnQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3Qgc3RhcnRQb2ludEJlZm9yZVNlbGVjdGlvbiA9IGlzUG9pbnRCZWZvcmVTZWxlY3Rpb24oc2VsZWN0aW9uU3RhcnRQb2ludCkoc25hcHNob3QpLCBzdGFydFBvaW50QWZ0ZXJTZWxlY3Rpb24gPSBpc1BvaW50QWZ0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uU3RhcnRQb2ludCkoc25hcHNob3QpLCBlbmRQb2ludEJlZm9yZVNlbGVjdGlvbiA9IGlzUG9pbnRCZWZvcmVTZWxlY3Rpb24oc2VsZWN0aW9uRW5kUG9pbnQpKHNuYXBzaG90KSwgZW5kUG9pbnRBZnRlclNlbGVjdGlvbiA9IGlzUG9pbnRBZnRlclNlbGVjdGlvbihzZWxlY3Rpb25FbmRQb2ludCkoc25hcHNob3QpLCBvcmlnaW5hbFN0YXJ0UG9pbnRCZWZvcmVTdGFydFBvaW50ID0gaXNQb2ludEJlZm9yZVNlbGVjdGlvbihvcmlnaW5hbFNlbGVjdGlvblN0YXJ0UG9pbnQpKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICBhbmNob3I6IHNlbGVjdGlvblN0YXJ0UG9pbnQsXG4gICAgICAgICAgZm9jdXM6IHNlbGVjdGlvblN0YXJ0UG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBvcmlnaW5hbFN0YXJ0UG9pbnRBZnRlclN0YXJ0UG9pbnQgPSBpc1BvaW50QWZ0ZXJTZWxlY3Rpb24ob3JpZ2luYWxTZWxlY3Rpb25TdGFydFBvaW50KSh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25TdGFydFBvaW50LFxuICAgICAgICAgIGZvY3VzOiBzZWxlY3Rpb25TdGFydFBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgb3JpZ2luYWxFbmRQb2ludEJlZm9yZUVuZFBvaW50ID0gaXNQb2ludEJlZm9yZVNlbGVjdGlvbihvcmlnaW5hbFNlbGVjdGlvbkVuZFBvaW50KSh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25FbmRQb2ludCxcbiAgICAgICAgICBmb2N1czogc2VsZWN0aW9uRW5kUG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBvcmlnaW5hbEVuZFBvaW50QWZ0ZXJFbmRQb2ludCA9IGlzUG9pbnRBZnRlclNlbGVjdGlvbihvcmlnaW5hbFNlbGVjdGlvbkVuZFBvaW50KSh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25FbmRQb2ludCxcbiAgICAgICAgICBmb2N1czogc2VsZWN0aW9uRW5kUG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBlbmRQb2ludEVxdWFsVG9PcmlnaW5hbFN0YXJ0UG9pbnQgPSBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHNlbGVjdGlvbkVuZFBvaW50LCBvcmlnaW5hbFNlbGVjdGlvblN0YXJ0UG9pbnQpLCBzdGFydFBvaW50RXF1YWxUb09yaWdpbmFsRW5kUG9pbnQgPSBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHNlbGVjdGlvblN0YXJ0UG9pbnQsIG9yaWdpbmFsU2VsZWN0aW9uRW5kUG9pbnQpO1xuICAgIHJldHVybiBlbmRQb2ludEJlZm9yZVNlbGVjdGlvbiAmJiAhZW5kUG9pbnRFcXVhbFRvT3JpZ2luYWxTdGFydFBvaW50IHx8IHN0YXJ0UG9pbnRBZnRlclNlbGVjdGlvbiAmJiAhc3RhcnRQb2ludEVxdWFsVG9PcmlnaW5hbEVuZFBvaW50ID8gITEgOiAhb3JpZ2luYWxTdGFydFBvaW50QmVmb3JlU3RhcnRQb2ludCAmJiBvcmlnaW5hbFN0YXJ0UG9pbnRBZnRlclN0YXJ0UG9pbnQgJiYgIW9yaWdpbmFsRW5kUG9pbnRCZWZvcmVFbmRQb2ludCAmJiBvcmlnaW5hbEVuZFBvaW50QWZ0ZXJFbmRQb2ludCA/ICFlbmRQb2ludEVxdWFsVG9PcmlnaW5hbFN0YXJ0UG9pbnQgOiBvcmlnaW5hbFN0YXJ0UG9pbnRCZWZvcmVTdGFydFBvaW50ICYmICFvcmlnaW5hbFN0YXJ0UG9pbnRBZnRlclN0YXJ0UG9pbnQgJiYgb3JpZ2luYWxFbmRQb2ludEJlZm9yZUVuZFBvaW50ICYmICFvcmlnaW5hbEVuZFBvaW50QWZ0ZXJFbmRQb2ludCA/ICFzdGFydFBvaW50RXF1YWxUb09yaWdpbmFsRW5kUG9pbnQgOiAhc3RhcnRQb2ludEFmdGVyU2VsZWN0aW9uIHx8ICFzdGFydFBvaW50QmVmb3JlU2VsZWN0aW9uIHx8ICFlbmRQb2ludEFmdGVyU2VsZWN0aW9uIHx8ICFlbmRQb2ludEJlZm9yZVNlbGVjdGlvbjtcbiAgfTtcbn1cbmNvbnN0IGlzU2VsZWN0aW5nRW50aXJlQmxvY2tzID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzdGFydFBvaW50ID0gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvciwgZW5kUG9pbnQgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvciA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLCBzdGFydEJsb2NrID0gZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayhzbmFwc2hvdCksIGVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2soc25hcHNob3QpO1xuICBpZiAoIXN0YXJ0QmxvY2sgfHwgIWVuZEJsb2NrKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc3RhcnRCbG9ja1N0YXJ0UG9pbnQgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgYmxvY2s6IHN0YXJ0QmxvY2tcbiAgfSksIGVuZEJsb2NrRW5kUG9pbnQgPSBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGJsb2NrOiBlbmRCbG9ja1xuICB9KTtcbiAgcmV0dXJuIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoc3RhcnRCbG9ja1N0YXJ0UG9pbnQsIHN0YXJ0UG9pbnQpICYmIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMoZW5kQmxvY2tFbmRQb2ludCwgZW5kUG9pbnQpO1xufTtcbmV4cG9ydCB7XG4gIGdldEFjdGl2ZUFubm90YXRpb25zLFxuICBnZXRBY3RpdmVMaXN0SXRlbSxcbiAgZ2V0QWN0aXZlU3R5bGUsXG4gIGdldENhcmV0V29yZFNlbGVjdGlvbixcbiAgZ2V0Rm9jdXNJbmxpbmVPYmplY3QsXG4gIGdldE5leHRJbmxpbmVPYmplY3QsXG4gIGdldFNlbGVjdGVkU3BhbnMsXG4gIGdldFNlbGVjdGVkVGV4dEJsb2NrcyxcbiAgZ2V0U2VsZWN0aW9uRW5kUG9pbnQsXG4gIGdldFRyaW1tZWRTZWxlY3Rpb24sXG4gIGlzQWN0aXZlQW5ub3RhdGlvbixcbiAgaXNBY3RpdmVEZWNvcmF0b3IsXG4gIGlzQWN0aXZlTGlzdEl0ZW0sXG4gIGlzQWN0aXZlU3R5bGUsXG4gIGlzQXRUaGVFbmRPZkJsb2NrLFxuICBpc0F0VGhlU3RhcnRPZkJsb2NrLFxuICBpc092ZXJsYXBwaW5nU2VsZWN0aW9uLFxuICBpc1BvaW50QWZ0ZXJTZWxlY3Rpb24sXG4gIGlzUG9pbnRCZWZvcmVTZWxlY3Rpb24sXG4gIGlzU2VsZWN0aW5nRW50aXJlQmxvY2tzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3IuaXMtc2VsZWN0aW5nLWVudGlyZS1ibG9ja3MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFirstBlock: () => (/* binding */ getFirstBlock),\n/* harmony export */   getFocusBlock: () => (/* binding */ getFocusBlock),\n/* harmony export */   getFocusBlockObject: () => (/* binding */ getFocusBlockObject),\n/* harmony export */   getFocusChild: () => (/* binding */ getFocusChild),\n/* harmony export */   getFocusListBlock: () => (/* binding */ getFocusListBlock),\n/* harmony export */   getFocusSpan: () => (/* binding */ getFocusSpan),\n/* harmony export */   getFocusTextBlock: () => (/* binding */ getFocusTextBlock),\n/* harmony export */   getLastBlock: () => (/* binding */ getLastBlock),\n/* harmony export */   getNextBlock: () => (/* binding */ getNextBlock),\n/* harmony export */   getPreviousBlock: () => (/* binding */ getPreviousBlock),\n/* harmony export */   getPreviousInlineObject: () => (/* binding */ getPreviousInlineObject),\n/* harmony export */   getSelectedBlocks: () => (/* binding */ getSelectedBlocks),\n/* harmony export */   getSelectedSlice: () => (/* binding */ getSelectedSlice),\n/* harmony export */   getSelectionEndBlock: () => (/* binding */ getSelectionEndBlock),\n/* harmony export */   getSelectionStartBlock: () => (/* binding */ getSelectionStartBlock),\n/* harmony export */   getSelectionStartPoint: () => (/* binding */ getSelectionStartPoint),\n/* harmony export */   getSelectionText: () => (/* binding */ getSelectionText),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed),\n/* harmony export */   isSelectionExpanded: () => (/* binding */ isSelectionExpanded)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\n\nconst isSelectionCollapsed = (snapshot) => snapshot.context.selection ? JSON.stringify(snapshot.context.selection.anchor.path) === JSON.stringify(snapshot.context.selection.focus.path) && snapshot.context.selection?.anchor.offset === snapshot.context.selection?.focus.offset : !1, getFocusBlock = (snapshot) => {\n  const key = snapshot.context.selection && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getFocusListBlock = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot);\n  return focusTextBlock && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isListBlock)(snapshot.context, focusTextBlock.node) ? {\n    node: focusTextBlock.node,\n    path: focusTextBlock.path\n  } : void 0;\n}, getFocusTextBlock = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot);\n  return focusBlock && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusBlockObject = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot);\n  return focusBlock && !(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusChild = (snapshot) => {\n  const focusBlock = getFocusTextBlock(snapshot);\n  if (!focusBlock)\n    return;\n  const key = snapshot.context.selection && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[2]) ? snapshot.context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [...focusBlock.path, \"children\", {\n      _key: key\n    }]\n  } : void 0;\n}, getFocusSpan = (snapshot) => {\n  const focusChild = getFocusChild(snapshot);\n  return focusChild && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}, getFirstBlock = (snapshot) => {\n  const node = snapshot.context.value[0];\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getLastBlock = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1] ? snapshot.context.value[snapshot.context.value.length - 1] : void 0;\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getSelectedBlocks = (snapshot) => {\n  if (!snapshot.context.selection)\n    return [];\n  const selectedBlocks = [], startKey = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0, endKey = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0;\n  if (!startKey || !endKey)\n    return selectedBlocks;\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      if (selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      }), startKey === endKey)\n        break;\n      continue;\n    }\n    if (block._key === endKey) {\n      selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      });\n      break;\n    }\n    selectedBlocks.length > 0 && selectedBlocks.push({\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    });\n  }\n  return selectedBlocks;\n}, getSelectionStartBlock = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const key = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getSelectionEndBlock = (snapshot) => {\n  if (!snapshot.context.selection)\n    return;\n  const key = snapshot.context.selection.backward ? (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0 : (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(snapshot.context.selection.focus.path[0]) ? snapshot.context.selection.focus.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getPreviousBlock = (snapshot) => {\n  let previousBlock;\n  const selectionStartBlock = getSelectionStartBlock(snapshot);\n  if (!selectionStartBlock)\n    return;\n  let foundSelectionStartBlock = !1;\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = !0;\n      break;\n    }\n    previousBlock = {\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    };\n  }\n  if (foundSelectionStartBlock && previousBlock)\n    return previousBlock;\n}, getNextBlock = (snapshot) => {\n  let nextBlock;\n  const selectionEndBlock = getSelectionEndBlock(snapshot);\n  if (!selectionEndBlock)\n    return;\n  let foundSelectionEndBlock = !1;\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = !0;\n      continue;\n    }\n    if (foundSelectionEndBlock) {\n      nextBlock = {\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      };\n      break;\n    }\n  }\n  if (foundSelectionEndBlock && nextBlock)\n    return nextBlock;\n}, getSelectionStartPoint = (snapshot) => {\n  if (snapshot.context.selection)\n    return snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor;\n}, getPreviousInlineObject = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot), selectionStartPoint = getSelectionStartPoint(snapshot), selectionStartPointChildKey = selectionStartPoint && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_1__.isKeySegment)(selectionStartPoint.path[2]) ? selectionStartPoint.path[2]._key : void 0;\n  if (!focusTextBlock || !selectionStartPointChildKey)\n    return;\n  let inlineObject;\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey)\n      break;\n    (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan)(snapshot.context, child) || (inlineObject = {\n      node: child,\n      path: [...focusTextBlock.path, \"children\", {\n        _key: child._key\n      }]\n    });\n  }\n  return inlineObject;\n}, getSelectedSlice = (snapshot) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.sliceBlocks)({\n  context: snapshot.context,\n  blocks: snapshot.context.value\n}), getSelectionText = (snapshot) => getSelectedSlice(snapshot).reduce((text, block) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(snapshot.context, block) ? text + block.children.reduce((text2, child) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(snapshot.context, child) ? text2 + child.text : text2, \"\") : text, \"\"), isSelectionExpanded = (snapshot) => !isSelectionCollapsed(snapshot);\n\n//# sourceMappingURL=selector.is-selection-expanded.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWV4cGFuZGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUMwRjtBQUN2STtBQUNBLDRDQUE0QyxxRUFBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsMkJBQTJCLGtFQUFXO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsdUJBQXVCLGtFQUFXO0FBQ2xDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0Esd0JBQXdCLGtFQUFXO0FBQ25DO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxRUFBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsdUJBQXVCLCtEQUFNO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhFQUE4RSxxRUFBYyxzR0FBc0cscUVBQWMsc0pBQXNKLHFFQUFjLHdHQUF3RyxxRUFBYztBQUMxZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9EQUFvRCxxRUFBYyxzR0FBc0cscUVBQWM7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0RBQW9ELHFFQUFjLHdHQUF3RyxxRUFBYztBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELG1LQUFtSywyREFBWTtBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQyxtQ0FBbUMsa0VBQVc7QUFDL0M7QUFDQTtBQUNBLENBQUMsdUZBQXVGLGtFQUFXLDJFQUEyRSwrREFBTTtBQXFCbEw7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9zZWxlY3Rvci5pcy1zZWxlY3Rpb24tZXhwYW5kZWQuanM/MmI1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0tleVNlZ21lbnQgfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuaW1wb3J0IHsgaXNUZXh0QmxvY2ssIGlzU3BhbiQxIGFzIGlzU3BhbiwgaXNMaXN0QmxvY2ssIGlzS2V5ZWRTZWdtZW50LCBpc1NwYW4gYXMgaXNTcGFuJDEsIHNsaWNlQmxvY2tzIH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmNvbnN0IGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gKHNuYXBzaG90KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiA/IEpTT04uc3RyaW5naWZ5KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoKSA9PT0gSlNPTi5zdHJpbmdpZnkoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aCkgJiYgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmFuY2hvci5vZmZzZXQgPT09IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgOiAhMSwgZ2V0Rm9jdXNCbG9jayA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBrZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiBpc0tleWVkU2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IHNuYXBzaG90LmNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNMaXN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCk7XG4gIHJldHVybiBmb2N1c1RleHRCbG9jayAmJiBpc0xpc3RCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c1RleHRCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c1RleHRCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzVGV4dEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c0Jsb2NrT2JqZWN0ID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHNuYXBzaG90KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGZvY3VzQmxvY2subm9kZSkgPyB7XG4gICAgbm9kZTogZm9jdXNCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aFxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNDaGlsZCA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpO1xuICBpZiAoIWZvY3VzQmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiBpc0tleWVkU2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGZvY3VzQmxvY2subm9kZS5jaGlsZHJlbi5maW5kKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFsuLi5mb2N1c0Jsb2NrLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzU3BhbiA9IChzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBmb2N1c0NoaWxkID0gZ2V0Rm9jdXNDaGlsZChzbmFwc2hvdCk7XG4gIHJldHVybiBmb2N1c0NoaWxkICYmIGlzU3BhbihzbmFwc2hvdC5jb250ZXh0LCBmb2N1c0NoaWxkLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQ2hpbGQubm9kZSxcbiAgICBwYXRoOiBmb2N1c0NoaWxkLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZpcnN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNuYXBzaG90LmNvbnRleHQudmFsdWVbMF07XG4gIHJldHVybiBub2RlID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IG5vZGUuX2tleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRMYXN0QmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNuYXBzaG90LmNvbnRleHQudmFsdWVbc25hcHNob3QuY29udGV4dC52YWx1ZS5sZW5ndGggLSAxXSA/IHNuYXBzaG90LmNvbnRleHQudmFsdWVbc25hcHNob3QuY29udGV4dC52YWx1ZS5sZW5ndGggLSAxXSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogbm9kZS5fa2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldFNlbGVjdGVkQmxvY2tzID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFtdLCBzdGFydEtleSA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXllZFNlZ21lbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDAgOiBpc0tleWVkU2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwLCBlbmRLZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5ZWRTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAgOiBpc0tleWVkU2VnbWVudChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMDtcbiAgaWYgKCFzdGFydEtleSB8fCAhZW5kS2V5KVxuICAgIHJldHVybiBzZWxlY3RlZEJsb2NrcztcbiAgZm9yIChjb25zdCBibG9jayBvZiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHN0YXJ0S2V5KSB7XG4gICAgICBpZiAoc2VsZWN0ZWRCbG9ja3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV1cbiAgICAgIH0pLCBzdGFydEtleSA9PT0gZW5kS2V5KVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYmxvY2suX2tleSA9PT0gZW5kS2V5KSB7XG4gICAgICBzZWxlY3RlZEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEJsb2Nrcy5wdXNoKHtcbiAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgcGF0aDogW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWRCbG9ja3M7XG59LCBnZXRTZWxlY3Rpb25TdGFydEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5ZWRTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXllZFNlZ21lbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IHNuYXBzaG90LmNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0U2VsZWN0aW9uRW5kQmxvY2sgPSAoc25hcHNob3QpID0+IHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXllZFNlZ21lbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0uX2tleSA6IHZvaWQgMCA6IGlzS2V5ZWRTZWdtZW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwLCBub2RlID0ga2V5ID8gc25hcHNob3QuY29udGV4dC52YWx1ZS5maW5kKChibG9jaykgPT4gYmxvY2suX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgJiYga2V5ID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRQcmV2aW91c0Jsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGxldCBwcmV2aW91c0Jsb2NrO1xuICBjb25zdCBzZWxlY3Rpb25TdGFydEJsb2NrID0gZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayhzbmFwc2hvdCk7XG4gIGlmICghc2VsZWN0aW9uU3RhcnRCbG9jaylcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAhMTtcbiAgZm9yIChjb25zdCBibG9jayBvZiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHNlbGVjdGlvblN0YXJ0QmxvY2subm9kZS5fa2V5KSB7XG4gICAgICBmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAhMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91c0Jsb2NrID0ge1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH07XG4gIH1cbiAgaWYgKGZvdW5kU2VsZWN0aW9uU3RhcnRCbG9jayAmJiBwcmV2aW91c0Jsb2NrKVxuICAgIHJldHVybiBwcmV2aW91c0Jsb2NrO1xufSwgZ2V0TmV4dEJsb2NrID0gKHNuYXBzaG90KSA9PiB7XG4gIGxldCBuZXh0QmxvY2s7XG4gIGNvbnN0IHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2soc25hcHNob3QpO1xuICBpZiAoIXNlbGVjdGlvbkVuZEJsb2NrKVxuICAgIHJldHVybjtcbiAgbGV0IGZvdW5kU2VsZWN0aW9uRW5kQmxvY2sgPSAhMTtcbiAgZm9yIChjb25zdCBibG9jayBvZiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlKSB7XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IHNlbGVjdGlvbkVuZEJsb2NrLm5vZGUuX2tleSkge1xuICAgICAgZm91bmRTZWxlY3Rpb25FbmRCbG9jayA9ICEwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmb3VuZFNlbGVjdGlvbkVuZEJsb2NrKSB7XG4gICAgICBuZXh0QmxvY2sgPSB7XG4gICAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGZvdW5kU2VsZWN0aW9uRW5kQmxvY2sgJiYgbmV4dEJsb2NrKVxuICAgIHJldHVybiBuZXh0QmxvY2s7XG59LCBnZXRTZWxlY3Rpb25TdGFydFBvaW50ID0gKHNuYXBzaG90KSA9PiB7XG4gIGlmIChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbi5mb2N1cyA6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLmFuY2hvcjtcbn0sIGdldFByZXZpb3VzSW5saW5lT2JqZWN0ID0gKHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnRDaGlsZEtleSA9IHNlbGVjdGlvblN0YXJ0UG9pbnQgJiYgaXNLZXlTZWdtZW50KHNlbGVjdGlvblN0YXJ0UG9pbnQucGF0aFsyXSkgPyBzZWxlY3Rpb25TdGFydFBvaW50LnBhdGhbMl0uX2tleSA6IHZvaWQgMDtcbiAgaWYgKCFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uU3RhcnRQb2ludENoaWxkS2V5KVxuICAgIHJldHVybjtcbiAgbGV0IGlubGluZU9iamVjdDtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLl9rZXkgPT09IHNlbGVjdGlvblN0YXJ0UG9pbnRDaGlsZEtleSlcbiAgICAgIGJyZWFrO1xuICAgIGlzU3BhbiQxKHNuYXBzaG90LmNvbnRleHQsIGNoaWxkKSB8fCAoaW5saW5lT2JqZWN0ID0ge1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBwYXRoOiBbLi4uZm9jdXNUZXh0QmxvY2sucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlubGluZU9iamVjdDtcbn0sIGdldFNlbGVjdGVkU2xpY2UgPSAoc25hcHNob3QpID0+IHNsaWNlQmxvY2tzKHtcbiAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgYmxvY2tzOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlXG59KSwgZ2V0U2VsZWN0aW9uVGV4dCA9IChzbmFwc2hvdCkgPT4gZ2V0U2VsZWN0ZWRTbGljZShzbmFwc2hvdCkucmVkdWNlKCh0ZXh0LCBibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spID8gdGV4dCArIGJsb2NrLmNoaWxkcmVuLnJlZHVjZSgodGV4dDIsIGNoaWxkKSA9PiBpc1NwYW4oc25hcHNob3QuY29udGV4dCwgY2hpbGQpID8gdGV4dDIgKyBjaGlsZC50ZXh0IDogdGV4dDIsIFwiXCIpIDogdGV4dCwgXCJcIiksIGlzU2VsZWN0aW9uRXhwYW5kZWQgPSAoc25hcHNob3QpID0+ICFpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCk7XG5leHBvcnQge1xuICBnZXRGaXJzdEJsb2NrLFxuICBnZXRGb2N1c0Jsb2NrLFxuICBnZXRGb2N1c0Jsb2NrT2JqZWN0LFxuICBnZXRGb2N1c0NoaWxkLFxuICBnZXRGb2N1c0xpc3RCbG9jayxcbiAgZ2V0Rm9jdXNTcGFuLFxuICBnZXRGb2N1c1RleHRCbG9jayxcbiAgZ2V0TGFzdEJsb2NrLFxuICBnZXROZXh0QmxvY2ssXG4gIGdldFByZXZpb3VzQmxvY2ssXG4gIGdldFByZXZpb3VzSW5saW5lT2JqZWN0LFxuICBnZXRTZWxlY3RlZEJsb2NrcyxcbiAgZ2V0U2VsZWN0ZWRTbGljZSxcbiAgZ2V0U2VsZWN0aW9uRW5kQmxvY2ssXG4gIGdldFNlbGVjdGlvblN0YXJ0QmxvY2ssXG4gIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQsXG4gIGdldFNlbGVjdGlvblRleHQsXG4gIGlzU2VsZWN0aW9uQ29sbGFwc2VkLFxuICBpc1NlbGVjdGlvbkV4cGFuZGVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3IuaXMtc2VsZWN0aW9uLWV4cGFuZGVkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js":
/*!************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   useEditor: () => (/* binding */ useEditor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction getGlobalScope() {\n  if (typeof globalThis < \"u\") return globalThis;\n  if (typeof window < \"u\") return window;\n  if (typeof self < \"u\") return self;\n  if (typeof global < \"u\") return global;\n  throw new Error(\"@portabletext/editor: could not locate global scope\");\n}\nconst globalScope = getGlobalScope();\nfunction createGloballyScopedContext(key, defaultValue) {\n  const symbol = Symbol.for(key);\n  return typeof document > \"u\" ? (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue) : (globalScope[symbol] = globalScope[symbol] ?? (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultValue), globalScope[symbol]);\n}\nconst EditorContext = createGloballyScopedContext(\"@portabletext/editor/context/editor\", null);\nfunction useEditor() {\n  const editor = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EditorContext);\n  if (!editor)\n    throw new Error(\"No Editor set. Use EditorProvider to set one.\");\n  return editor;\n}\n\n//# sourceMappingURL=use-editor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXNlLWVkaXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQWEsK0RBQStELG9EQUFhO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFudGVjLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3VzZS1lZGl0b3IuanM/MzAwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsU2NvcGUoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIikgcmV0dXJuIHdpbmRvdztcbiAgaWYgKHR5cGVvZiBzZWxmIDwgXCJ1XCIpIHJldHVybiBzZWxmO1xuICBpZiAodHlwZW9mIGdsb2JhbCA8IFwidVwiKSByZXR1cm4gZ2xvYmFsO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJAcG9ydGFibGV0ZXh0L2VkaXRvcjogY291bGQgbm90IGxvY2F0ZSBnbG9iYWwgc2NvcGVcIik7XG59XG5jb25zdCBnbG9iYWxTY29wZSA9IGdldEdsb2JhbFNjb3BlKCk7XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxseVNjb3BlZENvbnRleHQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihrZXkpO1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIgPyBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkgOiAoZ2xvYmFsU2NvcGVbc3ltYm9sXSA9IGdsb2JhbFNjb3BlW3N5bWJvbF0gPz8gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpLCBnbG9iYWxTY29wZVtzeW1ib2xdKTtcbn1cbmNvbnN0IEVkaXRvckNvbnRleHQgPSBjcmVhdGVHbG9iYWxseVNjb3BlZENvbnRleHQoXCJAcG9ydGFibGV0ZXh0L2VkaXRvci9jb250ZXh0L2VkaXRvclwiLCBudWxsKTtcbmZ1bmN0aW9uIHVzZUVkaXRvcigpIHtcbiAgY29uc3QgZWRpdG9yID0gUmVhY3QudXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRWRpdG9yIHNldC4gVXNlIEVkaXRvclByb3ZpZGVyIHRvIHNldCBvbmUuXCIpO1xuICByZXR1cm4gZWRpdG9yO1xufVxuZXhwb3J0IHtcbiAgRWRpdG9yQ29udGV4dCxcbiAgdXNlRWRpdG9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWVkaXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToBlockSelectionPoint: () => (/* binding */ blockOffsetToBlockSelectionPoint),\n/* harmony export */   blockOffsetToSelectionPoint: () => (/* binding */ blockOffsetToSelectionPoint),\n/* harmony export */   blockOffsetsToSelection: () => (/* binding */ blockOffsetsToSelection),\n/* harmony export */   childSelectionPointToBlockOffset: () => (/* binding */ childSelectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\nfunction blockOffsetToBlockSelectionPoint({\n  context,\n  blockOffset\n}) {\n  let selectionPoint;\n  for (const block of context.value)\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{\n          _key: block._key\n        }],\n        offset: blockOffset.offset\n      };\n      break;\n    }\n  return selectionPoint;\n}\nfunction blockOffsetToSelectionPoint({\n  context,\n  blockOffset,\n  direction\n}) {\n  return (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.blockOffsetToSpanSelectionPoint)({\n    context,\n    blockOffset,\n    direction\n  }) || blockOffsetToBlockSelectionPoint({\n    context,\n    blockOffset\n  });\n}\nfunction blockOffsetsToSelection({\n  context,\n  offsets,\n  backward\n}) {\n  const anchor = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.anchor,\n    direction: backward ? \"backward\" : \"forward\"\n  }), focus = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.focus,\n    direction: backward ? \"forward\" : \"backward\"\n  });\n  return !anchor || !focus ? null : {\n    anchor,\n    focus,\n    backward\n  };\n}\nfunction childSelectionPointToBlockOffset({\n  context,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, childKey = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;\n  if (!(!blockKey || !childKey)) {\n    for (const block of context.value)\n      if (block._key === blockKey && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block))\n        for (const child of block.children) {\n          if (child._key === childKey)\n            return {\n              path: [{\n                _key: block._key\n              }],\n              offset: offset + selectionPoint.offset\n            };\n          (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(context, child) && (offset += child.text.length);\n        }\n  }\n}\n\n//# sourceMappingURL=util.child-selection-point-to-block-offset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5jaGlsZC1zZWxlY3Rpb24tcG9pbnQtdG8tYmxvY2stb2Zmc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUyxzRkFBK0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLHFFQUFjLDRFQUE0RSxxRUFBYztBQUMzSDtBQUNBO0FBQ0EscUNBQXFDLGtFQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVUsK0RBQU07QUFDaEI7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLmNoaWxkLXNlbGVjdGlvbi1wb2ludC10by1ibG9jay1vZmZzZXQuanM/NTU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LCBpc1RleHRCbG9jaywgaXNTcGFuJDEgYXMgaXNTcGFuLCBpc0tleWVkU2VnbWVudCB9IGZyb20gXCIuL3V0aWwuc2xpY2UtYmxvY2tzLmpzXCI7XG5mdW5jdGlvbiBibG9ja09mZnNldFRvQmxvY2tTZWxlY3Rpb25Qb2ludCh7XG4gIGNvbnRleHQsXG4gIGJsb2NrT2Zmc2V0XG59KSB7XG4gIGxldCBzZWxlY3Rpb25Qb2ludDtcbiAgZm9yIChjb25zdCBibG9jayBvZiBjb250ZXh0LnZhbHVlKVxuICAgIGlmIChibG9jay5fa2V5ID09PSBibG9ja09mZnNldC5wYXRoWzBdLl9rZXkpIHtcbiAgICAgIHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0sXG4gICAgICAgIG9mZnNldDogYmxvY2tPZmZzZXQub2Zmc2V0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gc2VsZWN0aW9uUG9pbnQ7XG59XG5mdW5jdGlvbiBibG9ja09mZnNldFRvU2VsZWN0aW9uUG9pbnQoe1xuICBjb250ZXh0LFxuICBibG9ja09mZnNldCxcbiAgZGlyZWN0aW9uXG59KSB7XG4gIHJldHVybiBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50KHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrT2Zmc2V0LFxuICAgIGRpcmVjdGlvblxuICB9KSB8fCBibG9ja09mZnNldFRvQmxvY2tTZWxlY3Rpb25Qb2ludCh7XG4gICAgY29udGV4dCxcbiAgICBibG9ja09mZnNldFxuICB9KTtcbn1cbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uKHtcbiAgY29udGV4dCxcbiAgb2Zmc2V0cyxcbiAgYmFja3dhcmRcbn0pIHtcbiAgY29uc3QgYW5jaG9yID0gYmxvY2tPZmZzZXRUb1NlbGVjdGlvblBvaW50KHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrT2Zmc2V0OiBvZmZzZXRzLmFuY2hvcixcbiAgICBkaXJlY3Rpb246IGJhY2t3YXJkID8gXCJiYWNrd2FyZFwiIDogXCJmb3J3YXJkXCJcbiAgfSksIGZvY3VzID0gYmxvY2tPZmZzZXRUb1NlbGVjdGlvblBvaW50KHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrT2Zmc2V0OiBvZmZzZXRzLmZvY3VzLFxuICAgIGRpcmVjdGlvbjogYmFja3dhcmQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIlxuICB9KTtcbiAgcmV0dXJuICFhbmNob3IgfHwgIWZvY3VzID8gbnVsbCA6IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXMsXG4gICAgYmFja3dhcmRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgY29udGV4dCxcbiAgc2VsZWN0aW9uUG9pbnRcbn0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGJsb2NrS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uUG9pbnQucGF0aFswXSkgPyBzZWxlY3Rpb25Qb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIGNoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uUG9pbnQucGF0aFsyXSkgPyBzZWxlY3Rpb25Qb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghKCFibG9ja0tleSB8fCAhY2hpbGRLZXkpKSB7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBjb250ZXh0LnZhbHVlKVxuICAgICAgaWYgKGJsb2NrLl9rZXkgPT09IGJsb2NrS2V5ICYmIGlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrKSlcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBjaGlsZEtleSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaXNTcGFuKGNvbnRleHQsIGNoaWxkKSAmJiAob2Zmc2V0ICs9IGNoaWxkLnRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICB9XG59XG5leHBvcnQge1xuICBibG9ja09mZnNldFRvQmxvY2tTZWxlY3Rpb25Qb2ludCxcbiAgYmxvY2tPZmZzZXRUb1NlbGVjdGlvblBvaW50LFxuICBibG9ja09mZnNldHNUb1NlbGVjdGlvbixcbiAgY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmNoaWxkLXNlbGVjdGlvbi1wb2ludC10by1ibG9jay1vZmZzZXQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-equal-selection-points.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.is-equal-selection-points.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockEndPoint: () => (/* binding */ getBlockEndPoint),\n/* harmony export */   isEmptyTextBlock: () => (/* binding */ isEmptyTextBlock),\n/* harmony export */   isEqualSelectionPoints: () => (/* binding */ isEqualSelectionPoints)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\nfunction getBlockEndPoint({\n  context,\n  block\n}) {\n  if ((0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block.node)) {\n    const lastChild = block.node.children[block.node.children.length - 1];\n    if (lastChild)\n      return {\n        path: [...block.path, \"children\", {\n          _key: lastChild._key\n        }],\n        offset: (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(context, lastChild) ? lastChild.text.length : 0\n      };\n  }\n  return {\n    path: block.path,\n    offset: 0\n  };\n}\nfunction isEmptyTextBlock(context, block) {\n  if (!(0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTextBlock)(context, block))\n    return !1;\n  const onlyText = block.children.every((child) => (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isSpan$1)(context, child)), blockText = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.getTextBlockText)(block);\n  return onlyText && blockText === \"\";\n}\nfunction isEqualSelectionPoints(a, b) {\n  return a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path);\n}\n\n//# sourceMappingURL=util.is-equal-selection-points.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5pcy1lcXVhbC1zZWxlY3Rpb24tcG9pbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE1BQU0sa0VBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsK0RBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0VBQVc7QUFDbEI7QUFDQSxtREFBbUQsK0RBQU0sK0JBQStCLHVFQUFnQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLmlzLWVxdWFsLXNlbGVjdGlvbi1wb2ludHMuanM/MWRjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1RleHRCbG9jaywgaXNTcGFuJDEgYXMgaXNTcGFuLCBnZXRUZXh0QmxvY2tUZXh0IH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmZ1bmN0aW9uIGdldEJsb2NrRW5kUG9pbnQoe1xuICBjb250ZXh0LFxuICBibG9ja1xufSkge1xuICBpZiAoaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2subm9kZSkpIHtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBibG9jay5ub2RlLmNoaWxkcmVuW2Jsb2NrLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaGlsZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IFsuLi5ibG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBsYXN0Q2hpbGQuX2tleVxuICAgICAgICB9XSxcbiAgICAgICAgb2Zmc2V0OiBpc1NwYW4oY29udGV4dCwgbGFzdENoaWxkKSA/IGxhc3RDaGlsZC50ZXh0Lmxlbmd0aCA6IDBcbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBibG9jay5wYXRoLFxuICAgIG9mZnNldDogMFxuICB9O1xufVxuZnVuY3Rpb24gaXNFbXB0eVRleHRCbG9jayhjb250ZXh0LCBibG9jaykge1xuICBpZiAoIWlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IG9ubHlUZXh0ID0gYmxvY2suY2hpbGRyZW4uZXZlcnkoKGNoaWxkKSA9PiBpc1NwYW4oY29udGV4dCwgY2hpbGQpKSwgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChibG9jayk7XG4gIHJldHVybiBvbmx5VGV4dCAmJiBibG9ja1RleHQgPT09IFwiXCI7XG59XG5mdW5jdGlvbiBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKGEsIGIpIHtcbiAgcmV0dXJuIGEub2Zmc2V0ID09PSBiLm9mZnNldCAmJiBKU09OLnN0cmluZ2lmeShhLnBhdGgpID09PSBKU09OLnN0cmluZ2lmeShiLnBhdGgpO1xufVxuZXhwb3J0IHtcbiAgZ2V0QmxvY2tFbmRQb2ludCxcbiAgaXNFbXB0eVRleHRCbG9jayxcbiAgaXNFcXVhbFNlbGVjdGlvblBvaW50c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuaXMtZXF1YWwtc2VsZWN0aW9uLXBvaW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-equal-selection-points.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTextBlock: () => (/* binding */ isTextBlock),\n/* harmony export */   mergeTextBlocks: () => (/* binding */ mergeTextBlocks)\n/* harmony export */ });\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\nfunction isTextBlock(context, block) {\n  return (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isTypedObject)(block) && block._type === context.schema.block.name;\n}\nfunction mergeTextBlocks({\n  context,\n  targetBlock,\n  incomingBlock\n}) {\n  const parsedIncomingBlock = (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.parseBlock)({\n    context,\n    block: incomingBlock,\n    options: {\n      refreshKeys: !0,\n      validateFields: !0\n    }\n  });\n  return !parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock) ? targetBlock : {\n    ...targetBlock,\n    children: [...targetBlock.children, ...parsedIncomingBlock.children],\n    markDefs: [...targetBlock.markDefs ?? [], ...parsedIncomingBlock.markDefs ?? []]\n  };\n}\n\n//# sourceMappingURL=util.merge-text-blocks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5tZXJnZS10ZXh0LWJsb2Nrcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUU7QUFDbkU7QUFDQSxTQUFTLG9FQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLGlFQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFudGVjLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwubWVyZ2UtdGV4dC1ibG9ja3MuanM/NTlkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1R5cGVkT2JqZWN0LCBwYXJzZUJsb2NrIH0gZnJvbSBcIi4vdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmZ1bmN0aW9uIGlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrKSB7XG4gIHJldHVybiBpc1R5cGVkT2JqZWN0KGJsb2NrKSAmJiBibG9jay5fdHlwZSA9PT0gY29udGV4dC5zY2hlbWEuYmxvY2submFtZTtcbn1cbmZ1bmN0aW9uIG1lcmdlVGV4dEJsb2Nrcyh7XG4gIGNvbnRleHQsXG4gIHRhcmdldEJsb2NrLFxuICBpbmNvbWluZ0Jsb2NrXG59KSB7XG4gIGNvbnN0IHBhcnNlZEluY29taW5nQmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICBjb250ZXh0LFxuICAgIGJsb2NrOiBpbmNvbWluZ0Jsb2NrLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZnJlc2hLZXlzOiAhMCxcbiAgICAgIHZhbGlkYXRlRmllbGRzOiAhMFxuICAgIH1cbiAgfSk7XG4gIHJldHVybiAhcGFyc2VkSW5jb21pbmdCbG9jayB8fCAhaXNUZXh0QmxvY2soY29udGV4dCwgcGFyc2VkSW5jb21pbmdCbG9jaykgPyB0YXJnZXRCbG9jayA6IHtcbiAgICAuLi50YXJnZXRCbG9jayxcbiAgICBjaGlsZHJlbjogWy4uLnRhcmdldEJsb2NrLmNoaWxkcmVuLCAuLi5wYXJzZWRJbmNvbWluZ0Jsb2NrLmNoaWxkcmVuXSxcbiAgICBtYXJrRGVmczogWy4uLnRhcmdldEJsb2NrLm1hcmtEZWZzID8/IFtdLCAuLi5wYXJzZWRJbmNvbWluZ0Jsb2NrLm1hcmtEZWZzID8/IFtdXVxuICB9O1xufVxuZXhwb3J0IHtcbiAgaXNUZXh0QmxvY2ssXG4gIG1lcmdlVGV4dEJsb2Nrc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwubWVyZ2UtdGV4dC1ibG9ja3MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.selection-point-to-block-offset.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.selection-point-to-block-offset.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSelectionEndPoint: () => (/* binding */ getSelectionEndPoint),\n/* harmony export */   getSelectionStartPoint: () => (/* binding */ getSelectionStartPoint),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed),\n/* harmony export */   selectionPointToBlockOffset: () => (/* binding */ selectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.child-selection-point-to-block-offset.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\");\n/* harmony import */ var _util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n\n\nfunction getSelectionEndPoint(selection) {\n  return selection ? selection.backward ? selection.anchor : selection.focus : null;\n}\nfunction getSelectionStartPoint(selection) {\n  return selection ? selection.backward ? selection.focus : selection.anchor : null;\n}\nfunction isSelectionCollapsed(selection) {\n  return selection ? selection.anchor.path.join() === selection.focus.path.join() && selection.anchor.offset === selection.focus.offset : !1;\n}\nfunction selectionPointToBlockOffset({\n  context,\n  selectionPoint\n}) {\n  return selectionPoint.path.length === 1 && (0,_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_0__.isKeyedSegment)(selectionPoint.path[0]) ? {\n    path: [{\n      _key: selectionPoint.path[0]._key\n    }],\n    offset: selectionPoint.offset\n  } : (0,_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_1__.childSelectionPointToBlockOffset)({\n    context,\n    selectionPoint\n  });\n}\n\n//# sourceMappingURL=util.selection-point-to-block-offset.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5zZWxlY3Rpb24tcG9pbnQtdG8tYmxvY2stb2Zmc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRztBQUMzQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkNBQTZDLHFFQUFjO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLEVBQUUsZ0hBQWdDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFudGVjLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3V0aWwuc2VsZWN0aW9uLXBvaW50LXRvLWJsb2NrLW9mZnNldC5qcz85MWJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0IH0gZnJvbSBcIi4vdXRpbC5jaGlsZC1zZWxlY3Rpb24tcG9pbnQtdG8tYmxvY2stb2Zmc2V0LmpzXCI7XG5pbXBvcnQgeyBpc0tleWVkU2VnbWVudCB9IGZyb20gXCIuL3V0aWwuc2xpY2UtYmxvY2tzLmpzXCI7XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25FbmRQb2ludChzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5iYWNrd2FyZCA/IHNlbGVjdGlvbi5hbmNob3IgOiBzZWxlY3Rpb24uZm9jdXMgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5iYWNrd2FyZCA/IHNlbGVjdGlvbi5mb2N1cyA6IHNlbGVjdGlvbi5hbmNob3IgOiBudWxsO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc2VsZWN0aW9uKSB7XG4gIHJldHVybiBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uYW5jaG9yLnBhdGguam9pbigpID09PSBzZWxlY3Rpb24uZm9jdXMucGF0aC5qb2luKCkgJiYgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgOiAhMTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gIGNvbnRleHQsXG4gIHNlbGVjdGlvblBvaW50XG59KSB7XG4gIHJldHVybiBzZWxlY3Rpb25Qb2ludC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBpc0tleWVkU2VnbWVudChzZWxlY3Rpb25Qb2ludC5wYXRoWzBdKSA/IHtcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogc2VsZWN0aW9uUG9pbnQucGF0aFswXS5fa2V5XG4gICAgfV0sXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgfSA6IGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICBjb250ZXh0LFxuICAgIHNlbGVjdGlvblBvaW50XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgZ2V0U2VsZWN0aW9uRW5kUG9pbnQsXG4gIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQsXG4gIGlzU2VsZWN0aW9uQ29sbGFwc2VkLFxuICBzZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLnNlbGVjdGlvbi1wb2ludC10by1ibG9jay1vZmZzZXQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.selection-point-to-block-offset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToSpanSelectionPoint: () => (/* binding */ blockOffsetToSpanSelectionPoint),\n/* harmony export */   getBlockStartPoint: () => (/* binding */ getBlockStartPoint),\n/* harmony export */   getTextBlockText: () => (/* binding */ getTextBlockText),\n/* harmony export */   isKeyedSegment: () => (/* binding */ isKeyedSegment),\n/* harmony export */   isListBlock: () => (/* binding */ isListBlock),\n/* harmony export */   isSpan: () => (/* binding */ isSpan),\n/* harmony export */   isSpan$1: () => (/* binding */ isSpan$1),\n/* harmony export */   isTextBlock: () => (/* binding */ isTextBlock),\n/* harmony export */   isTypedObject: () => (/* binding */ isTypedObject),\n/* harmony export */   parseAnnotation: () => (/* binding */ parseAnnotation),\n/* harmony export */   parseBlock: () => (/* binding */ parseBlock),\n/* harmony export */   parseBlockObject: () => (/* binding */ parseBlockObject),\n/* harmony export */   parseBlocks: () => (/* binding */ parseBlocks),\n/* harmony export */   parseInlineObject: () => (/* binding */ parseInlineObject),\n/* harmony export */   parseTextBlock: () => (/* binding */ parseTextBlock),\n/* harmony export */   reverseSelection: () => (/* binding */ reverseSelection),\n/* harmony export */   sliceBlocks: () => (/* binding */ sliceBlocks),\n/* harmony export */   spanSelectionPointToBlockOffset: () => (/* binding */ spanSelectionPointToBlockOffset)\n/* harmony export */ });\nfunction isTypedObject(object) {\n  return isRecord(object) && typeof object._type == \"string\";\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction parseBlocks({\n  context,\n  blocks,\n  options\n}) {\n  return Array.isArray(blocks) ? blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({\n      context,\n      block,\n      options\n    });\n    return parsedBlock ? [parsedBlock] : [];\n  }) : [];\n}\nfunction parseBlock({\n  context,\n  block,\n  options\n}) {\n  return parseTextBlock({\n    block,\n    context,\n    options\n  }) ?? parseBlockObject({\n    blockObject: block,\n    context,\n    options\n  });\n}\nfunction parseBlockObject({\n  blockObject,\n  context,\n  options\n}) {\n  if (!isTypedObject(blockObject))\n    return;\n  const schemaType = context.schema.blockObjects.find(({\n    name\n  }) => name === blockObject._type);\n  if (schemaType)\n    return parseObject({\n      object: blockObject,\n      context: {\n        keyGenerator: context.keyGenerator,\n        schemaType\n      },\n      options\n    });\n}\nfunction isListBlock(context, block) {\n  return isTextBlock(context, block) && block.level !== void 0 && block.listItem !== void 0;\n}\nfunction isTextBlock(context, block) {\n  return parseTextBlock({\n    block,\n    context: {\n      schema: context.schema,\n      keyGenerator: () => \"\"\n    },\n    options: {\n      refreshKeys: !1,\n      validateFields: !1\n    }\n  }) !== void 0;\n}\nfunction parseTextBlock({\n  block,\n  context,\n  options\n}) {\n  if (!isTypedObject(block))\n    return;\n  const customFields = {};\n  for (const key of Object.keys(block))\n    key !== \"_type\" && key !== \"_key\" && key !== \"children\" && key !== \"markDefs\" && key !== \"style\" && key !== \"listItem\" && key !== \"level\" && (customFields[key] = block[key]);\n  if (block._type !== context.schema.block.name)\n    return;\n  const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == \"string\" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef))\n      return [];\n    const schemaType = context.schema.annotations.find(({\n      name\n    }) => name === markDef._type);\n    if (!schemaType)\n      return [];\n    if (typeof markDef._key != \"string\")\n      return [];\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator\n      },\n      options\n    });\n    return parsedAnnotation ? (markDefKeyMap.set(markDef._key, parsedAnnotation._key), [parsedAnnotation]) : [];\n  }), children = (Array.isArray(block.children) ? block.children : []).map((child) => parseSpan({\n    span: child,\n    context,\n    markDefKeyMap,\n    options\n  }) ?? parseInlineObject({\n    inlineObject: child,\n    context,\n    options\n  })).filter((child) => child !== void 0), parsedBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children: children.length > 0 ? children : [{\n      _key: context.keyGenerator(),\n      _type: context.schema.span.name,\n      text: \"\",\n      marks: []\n    }],\n    markDefs,\n    ...options.validateFields ? {} : customFields\n  };\n  if (typeof block.style == \"string\" && context.schema.styles.find((style) => style.name === block.style))\n    parsedBlock.style = block.style;\n  else {\n    const defaultStyle = context.schema.styles.at(0)?.name;\n    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : console.error(\"Expected default style\");\n  }\n  return typeof block.listItem == \"string\" && context.schema.lists.find((list) => list.name === block.listItem) && (parsedBlock.listItem = block.listItem), typeof block.level == \"number\" && (parsedBlock.level = block.level), parsedBlock;\n}\nfunction isSpan$1(context, child) {\n  return parseSpan({\n    span: child,\n    markDefKeyMap: /* @__PURE__ */ new Map(),\n    context: {\n      schema: context.schema,\n      keyGenerator: () => \"\"\n    },\n    options: {\n      refreshKeys: !1,\n      validateFields: !1\n    }\n  }) !== void 0;\n}\nfunction parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options\n}) {\n  if (!isTypedObject(span))\n    return;\n  const customFields = {};\n  for (const key of Object.keys(span))\n    key !== \"_type\" && key !== \"_key\" && key !== \"text\" && key !== \"marks\" && (customFields[key] = span[key]);\n  if (span._type !== context.schema.span.name || span._type !== \"span\")\n    return;\n  const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark) => {\n    if (typeof mark != \"string\")\n      return [];\n    const markDefKey = markDefKeyMap.get(mark);\n    return markDefKey !== void 0 ? [markDefKey] : context.schema.decorators.some((decorator) => decorator.name === mark) ? [mark] : [];\n  });\n  return {\n    _type: \"span\",\n    _key: options.refreshKeys ? context.keyGenerator() : typeof span._key == \"string\" ? span._key : context.keyGenerator(),\n    text: typeof span.text == \"string\" ? span.text : \"\",\n    marks,\n    ...options.validateFields ? {} : customFields\n  };\n}\nfunction parseInlineObject({\n  inlineObject,\n  context,\n  options\n}) {\n  if (!isTypedObject(inlineObject))\n    return;\n  const schemaType = context.schema.inlineObjects.find(({\n    name\n  }) => name === inlineObject._type);\n  if (schemaType)\n    return parseObject({\n      object: inlineObject,\n      context: {\n        keyGenerator: context.keyGenerator,\n        schemaType\n      },\n      options\n    });\n}\nfunction parseAnnotation({\n  annotation,\n  context,\n  options\n}) {\n  if (!isTypedObject(annotation))\n    return;\n  const schemaType = context.schema.annotations.find(({\n    name\n  }) => name === annotation._type);\n  if (schemaType)\n    return parseObject({\n      object: annotation,\n      context: {\n        keyGenerator: context.keyGenerator,\n        schemaType\n      },\n      options\n    });\n}\nfunction parseObject({\n  object,\n  context,\n  options\n}) {\n  const {\n    _type,\n    _key,\n    ...customFields\n  } = object, values = options.validateFields ? context.schemaType.fields.reduce((fieldValues, field) => {\n    const fieldValue = object[field.name];\n    return fieldValue !== void 0 && (fieldValues[field.name] = fieldValue), fieldValues;\n  }, {}) : customFields;\n  return {\n    _type: context.schemaType.name,\n    _key: options.refreshKeys ? context.keyGenerator() : typeof object._key == \"string\" ? object._key : context.keyGenerator(),\n    ...values\n  };\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && segment !== null && \"_key\" in segment;\n}\nfunction blockOffsetToSpanSelectionPoint({\n  context,\n  blockOffset,\n  direction\n}) {\n  let offsetLeft = blockOffset.offset, selectionPoint, skippedInlineObject = !1;\n  for (const block of context.value)\n    if (block._key === blockOffset.path[0]._key && isTextBlock(context, block))\n      for (const child of block.children) {\n        if (direction === \"forward\") {\n          if (!isSpan$1(context, child))\n            continue;\n          if (offsetLeft <= child.text.length) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: offsetLeft\n            };\n            break;\n          }\n          offsetLeft -= child.text.length;\n          continue;\n        }\n        if (!isSpan$1(context, child)) {\n          skippedInlineObject = !0;\n          continue;\n        }\n        if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n          skippedInlineObject && (selectionPoint = {\n            path: [...blockOffset.path, \"children\", {\n              _key: child._key\n            }],\n            offset: 0\n          });\n          break;\n        }\n        if (offsetLeft > child.text.length) {\n          offsetLeft -= child.text.length;\n          continue;\n        }\n        if (offsetLeft <= child.text.length && (selectionPoint = {\n          path: [...blockOffset.path, \"children\", {\n            _key: child._key\n          }],\n          offset: offsetLeft\n        }, offsetLeft -= child.text.length, offsetLeft !== 0))\n          break;\n      }\n  return selectionPoint;\n}\nfunction spanSelectionPointToBlockOffset({\n  context,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = isKeyedSegment(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, spanKey = isKeyedSegment(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;\n  if (!(!blockKey || !spanKey)) {\n    for (const block of context.value)\n      if (block._key === blockKey && isTextBlock(context, block)) {\n        for (const child of block.children)\n          if (isSpan$1(context, child)) {\n            if (child._key === spanKey)\n              return {\n                path: [{\n                  _key: block._key\n                }],\n                offset: offset + selectionPoint.offset\n              };\n            offset += child.text.length;\n          }\n      }\n  }\n}\nfunction getBlockStartPoint({\n  context,\n  block\n}) {\n  return isTextBlock(context, block.node) ? {\n    path: [...block.path, \"children\", {\n      _key: block.node.children[0]._key\n    }],\n    offset: 0\n  } : {\n    path: block.path,\n    offset: 0\n  };\n}\nfunction getTextBlockText(block) {\n  return block.children.map((child) => child.text ?? \"\").join(\"\");\n}\nfunction isSpan(context, child) {\n  return child._type === context.schema.span.name;\n}\nfunction reverseSelection(selection) {\n  return selection && (selection.backward ? {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !1\n  } : {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !0\n  });\n}\nfunction sliceBlocks({\n  context,\n  blocks\n}) {\n  const slice = [];\n  if (!context.selection)\n    return slice;\n  let startBlock;\n  const middleBlocks = [];\n  let endBlock;\n  const startPoint = context.selection.backward ? context.selection.focus : context.selection.anchor, endPoint = context.selection.backward ? context.selection.anchor : context.selection.focus, startBlockKey = isKeyedSegment(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = isKeyedSegment(endPoint.path[0]) ? endPoint.path[0]._key : void 0, startChildKey = isKeyedSegment(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endChildKey = isKeyedSegment(endPoint.path[2]) ? endPoint.path[2]._key : void 0;\n  if (!startBlockKey || !endBlockKey)\n    return slice;\n  for (const block of blocks) {\n    if (!isTextBlock(context, block) && block._key === startBlockKey && block._key === endBlockKey) {\n      startBlock = block;\n      break;\n    }\n    if (block._key === startBlockKey) {\n      if (!isTextBlock(context, block)) {\n        startBlock = block;\n        continue;\n      }\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isSpan$1(context, child)) {\n              const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);\n              startBlock = {\n                ...block,\n                children: [{\n                  ...child,\n                  text\n                }]\n              };\n            } else\n              startBlock = {\n                ...block,\n                children: [child]\n              };\n            if (startChildKey === endChildKey)\n              break;\n            continue;\n          }\n          if (startBlock && isTextBlock(context, startBlock) && (endChildKey && child._key === endChildKey && isSpan$1(context, child) ? startBlock.children.push({\n            ...child,\n            text: child.text.slice(0, endPoint.offset)\n          }) : startBlock.children.push(child), block._key === endBlockKey && endChildKey && child._key === endChildKey))\n            break;\n        }\n        if (startBlockKey === endBlockKey)\n          break;\n        continue;\n      }\n      if (startBlock = block, startBlockKey === endBlockKey)\n        break;\n    }\n    if (block._key === endBlockKey) {\n      if (!isTextBlock(context, block)) {\n        endBlock = block;\n        break;\n      }\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: []\n        };\n        for (const child of block.children)\n          if (endBlock && isTextBlock(context, endBlock)) {\n            if (child._key === endChildKey && isSpan$1(context, child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset)\n              });\n              break;\n            }\n            if (endBlock.children.push(child), endChildKey && child._key === endChildKey)\n              break;\n          }\n        break;\n      }\n      endBlock = block;\n      break;\n    }\n    startBlock && middleBlocks.push(block);\n  }\n  return [...startBlock ? [startBlock] : [], ...middleBlocks, ...endBlock ? [endBlock] : []];\n}\n\n//# sourceMappingURL=util.slice-blocks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5zbGljZS1ibG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYW50ZWMvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5zbGljZS1ibG9ja3MuanM/ZGMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpc1R5cGVkT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gaXNSZWNvcmQob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0Ll90eXBlID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1JlY29yZCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2Nrcyh7XG4gIGNvbnRleHQsXG4gIGJsb2NrcyxcbiAgb3B0aW9uc1xufSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShibG9ja3MpID8gYmxvY2tzLmZsYXRNYXAoKGJsb2NrKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkQmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBibG9jayxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkQmxvY2sgPyBbcGFyc2VkQmxvY2tdIDogW107XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrKHtcbiAgY29udGV4dCxcbiAgYmxvY2ssXG4gIG9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIHBhcnNlVGV4dEJsb2NrKHtcbiAgICBibG9jayxcbiAgICBjb250ZXh0LFxuICAgIG9wdGlvbnNcbiAgfSkgPz8gcGFyc2VCbG9ja09iamVjdCh7XG4gICAgYmxvY2tPYmplY3Q6IGJsb2NrLFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tPYmplY3Qoe1xuICBibG9ja09iamVjdCxcbiAgY29udGV4dCxcbiAgb3B0aW9uc1xufSkge1xuICBpZiAoIWlzVHlwZWRPYmplY3QoYmxvY2tPYmplY3QpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGNvbnRleHQuc2NoZW1hLmJsb2NrT2JqZWN0cy5maW5kKCh7XG4gICAgbmFtZVxuICB9KSA9PiBuYW1lID09PSBibG9ja09iamVjdC5fdHlwZSk7XG4gIGlmIChzY2hlbWFUeXBlKVxuICAgIHJldHVybiBwYXJzZU9iamVjdCh7XG4gICAgICBvYmplY3Q6IGJsb2NrT2JqZWN0LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICBzY2hlbWFUeXBlXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNMaXN0QmxvY2soY29udGV4dCwgYmxvY2spIHtcbiAgcmV0dXJuIGlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrKSAmJiBibG9jay5sZXZlbCAhPT0gdm9pZCAwICYmIGJsb2NrLmxpc3RJdGVtICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykge1xuICByZXR1cm4gcGFyc2VUZXh0QmxvY2soe1xuICAgIGJsb2NrLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICBrZXlHZW5lcmF0b3I6ICgpID0+IFwiXCJcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlZnJlc2hLZXlzOiAhMSxcbiAgICAgIHZhbGlkYXRlRmllbGRzOiAhMVxuICAgIH1cbiAgfSkgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dEJsb2NrKHtcbiAgYmxvY2ssXG4gIGNvbnRleHQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgaWYgKCFpc1R5cGVkT2JqZWN0KGJsb2NrKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGN1c3RvbUZpZWxkcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhibG9jaykpXG4gICAga2V5ICE9PSBcIl90eXBlXCIgJiYga2V5ICE9PSBcIl9rZXlcIiAmJiBrZXkgIT09IFwiY2hpbGRyZW5cIiAmJiBrZXkgIT09IFwibWFya0RlZnNcIiAmJiBrZXkgIT09IFwic3R5bGVcIiAmJiBrZXkgIT09IFwibGlzdEl0ZW1cIiAmJiBrZXkgIT09IFwibGV2ZWxcIiAmJiAoY3VzdG9tRmllbGRzW2tleV0gPSBibG9ja1trZXldKTtcbiAgaWYgKGJsb2NrLl90eXBlICE9PSBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lKVxuICAgIHJldHVybjtcbiAgY29uc3QgX2tleSA9IG9wdGlvbnMucmVmcmVzaEtleXMgPyBjb250ZXh0LmtleUdlbmVyYXRvcigpIDogdHlwZW9mIGJsb2NrLl9rZXkgPT0gXCJzdHJpbmdcIiA/IGJsb2NrLl9rZXkgOiBjb250ZXh0LmtleUdlbmVyYXRvcigpLCB1bnBhcnNlZE1hcmtEZWZzID0gQXJyYXkuaXNBcnJheShibG9jay5tYXJrRGVmcykgPyBibG9jay5tYXJrRGVmcyA6IFtdLCBtYXJrRGVmS2V5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbWFya0RlZnMgPSB1bnBhcnNlZE1hcmtEZWZzLmZsYXRNYXAoKG1hcmtEZWYpID0+IHtcbiAgICBpZiAoIWlzVHlwZWRPYmplY3QobWFya0RlZikpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGNvbnRleHQuc2NoZW1hLmFubm90YXRpb25zLmZpbmQoKHtcbiAgICAgIG5hbWVcbiAgICB9KSA9PiBuYW1lID09PSBtYXJrRGVmLl90eXBlKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBtYXJrRGVmLl9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBwYXJzZWRBbm5vdGF0aW9uID0gcGFyc2VPYmplY3Qoe1xuICAgICAgb2JqZWN0OiBtYXJrRGVmLFxuICAgICAgY29udGV4dDoge1xuICAgICAgICBzY2hlbWFUeXBlLFxuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZWRBbm5vdGF0aW9uID8gKG1hcmtEZWZLZXlNYXAuc2V0KG1hcmtEZWYuX2tleSwgcGFyc2VkQW5ub3RhdGlvbi5fa2V5KSwgW3BhcnNlZEFubm90YXRpb25dKSA6IFtdO1xuICB9KSwgY2hpbGRyZW4gPSAoQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgPyBibG9jay5jaGlsZHJlbiA6IFtdKS5tYXAoKGNoaWxkKSA9PiBwYXJzZVNwYW4oe1xuICAgIHNwYW46IGNoaWxkLFxuICAgIGNvbnRleHQsXG4gICAgbWFya0RlZktleU1hcCxcbiAgICBvcHRpb25zXG4gIH0pID8/IHBhcnNlSW5saW5lT2JqZWN0KHtcbiAgICBpbmxpbmVPYmplY3Q6IGNoaWxkLFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uc1xuICB9KSkuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgIT09IHZvaWQgMCksIHBhcnNlZEJsb2NrID0ge1xuICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgIF9rZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLmxlbmd0aCA+IDAgPyBjaGlsZHJlbiA6IFt7XG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBtYXJrczogW11cbiAgICB9XSxcbiAgICBtYXJrRGVmcyxcbiAgICAuLi5vcHRpb25zLnZhbGlkYXRlRmllbGRzID8ge30gOiBjdXN0b21GaWVsZHNcbiAgfTtcbiAgaWYgKHR5cGVvZiBibG9jay5zdHlsZSA9PSBcInN0cmluZ1wiICYmIGNvbnRleHQuc2NoZW1hLnN0eWxlcy5maW5kKChzdHlsZSkgPT4gc3R5bGUubmFtZSA9PT0gYmxvY2suc3R5bGUpKVxuICAgIHBhcnNlZEJsb2NrLnN0eWxlID0gYmxvY2suc3R5bGU7XG4gIGVsc2Uge1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IGNvbnRleHQuc2NoZW1hLnN0eWxlcy5hdCgwKT8ubmFtZTtcbiAgICBkZWZhdWx0U3R5bGUgIT09IHZvaWQgMCA/IHBhcnNlZEJsb2NrLnN0eWxlID0gZGVmYXVsdFN0eWxlIDogY29uc29sZS5lcnJvcihcIkV4cGVjdGVkIGRlZmF1bHQgc3R5bGVcIik7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBibG9jay5saXN0SXRlbSA9PSBcInN0cmluZ1wiICYmIGNvbnRleHQuc2NoZW1hLmxpc3RzLmZpbmQoKGxpc3QpID0+IGxpc3QubmFtZSA9PT0gYmxvY2subGlzdEl0ZW0pICYmIChwYXJzZWRCbG9jay5saXN0SXRlbSA9IGJsb2NrLmxpc3RJdGVtKSwgdHlwZW9mIGJsb2NrLmxldmVsID09IFwibnVtYmVyXCIgJiYgKHBhcnNlZEJsb2NrLmxldmVsID0gYmxvY2subGV2ZWwpLCBwYXJzZWRCbG9jaztcbn1cbmZ1bmN0aW9uIGlzU3BhbiQxKGNvbnRleHQsIGNoaWxkKSB7XG4gIHJldHVybiBwYXJzZVNwYW4oe1xuICAgIHNwYW46IGNoaWxkLFxuICAgIG1hcmtEZWZLZXlNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgY29udGV4dDoge1xuICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgIGtleUdlbmVyYXRvcjogKCkgPT4gXCJcIlxuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVmcmVzaEtleXM6ICExLFxuICAgICAgdmFsaWRhdGVGaWVsZHM6ICExXG4gICAgfVxuICB9KSAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gcGFyc2VTcGFuKHtcbiAgc3BhbixcbiAgY29udGV4dCxcbiAgbWFya0RlZktleU1hcCxcbiAgb3B0aW9uc1xufSkge1xuICBpZiAoIWlzVHlwZWRPYmplY3Qoc3BhbikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBjdXN0b21GaWVsZHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3BhbikpXG4gICAga2V5ICE9PSBcIl90eXBlXCIgJiYga2V5ICE9PSBcIl9rZXlcIiAmJiBrZXkgIT09IFwidGV4dFwiICYmIGtleSAhPT0gXCJtYXJrc1wiICYmIChjdXN0b21GaWVsZHNba2V5XSA9IHNwYW5ba2V5XSk7XG4gIGlmIChzcGFuLl90eXBlICE9PSBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUgfHwgc3Bhbi5fdHlwZSAhPT0gXCJzcGFuXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBtYXJrcyA9IChBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpID8gc3Bhbi5tYXJrcyA6IFtdKS5mbGF0TWFwKChtYXJrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBtYXJrICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbWFya0RlZktleSA9IG1hcmtEZWZLZXlNYXAuZ2V0KG1hcmspO1xuICAgIHJldHVybiBtYXJrRGVmS2V5ICE9PSB2b2lkIDAgPyBbbWFya0RlZktleV0gOiBjb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUgPT09IG1hcmspID8gW21hcmtdIDogW107XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIF90eXBlOiBcInNwYW5cIixcbiAgICBfa2V5OiBvcHRpb25zLnJlZnJlc2hLZXlzID8gY29udGV4dC5rZXlHZW5lcmF0b3IoKSA6IHR5cGVvZiBzcGFuLl9rZXkgPT0gXCJzdHJpbmdcIiA/IHNwYW4uX2tleSA6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgdGV4dDogdHlwZW9mIHNwYW4udGV4dCA9PSBcInN0cmluZ1wiID8gc3Bhbi50ZXh0IDogXCJcIixcbiAgICBtYXJrcyxcbiAgICAuLi5vcHRpb25zLnZhbGlkYXRlRmllbGRzID8ge30gOiBjdXN0b21GaWVsZHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5saW5lT2JqZWN0KHtcbiAgaW5saW5lT2JqZWN0LFxuICBjb250ZXh0LFxuICBvcHRpb25zXG59KSB7XG4gIGlmICghaXNUeXBlZE9iamVjdChpbmxpbmVPYmplY3QpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGNvbnRleHQuc2NoZW1hLmlubGluZU9iamVjdHMuZmluZCgoe1xuICAgIG5hbWVcbiAgfSkgPT4gbmFtZSA9PT0gaW5saW5lT2JqZWN0Ll90eXBlKTtcbiAgaWYgKHNjaGVtYVR5cGUpXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHtcbiAgICAgIG9iamVjdDogaW5saW5lT2JqZWN0LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICBzY2hlbWFUeXBlXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VBbm5vdGF0aW9uKHtcbiAgYW5ub3RhdGlvbixcbiAgY29udGV4dCxcbiAgb3B0aW9uc1xufSkge1xuICBpZiAoIWlzVHlwZWRPYmplY3QoYW5ub3RhdGlvbikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBzY2hlbWFUeXBlID0gY29udGV4dC5zY2hlbWEuYW5ub3RhdGlvbnMuZmluZCgoe1xuICAgIG5hbWVcbiAgfSkgPT4gbmFtZSA9PT0gYW5ub3RhdGlvbi5fdHlwZSk7XG4gIGlmIChzY2hlbWFUeXBlKVxuICAgIHJldHVybiBwYXJzZU9iamVjdCh7XG4gICAgICBvYmplY3Q6IGFubm90YXRpb24sXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgIHNjaGVtYVR5cGVcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdCh7XG4gIG9iamVjdCxcbiAgY29udGV4dCxcbiAgb3B0aW9uc1xufSkge1xuICBjb25zdCB7XG4gICAgX3R5cGUsXG4gICAgX2tleSxcbiAgICAuLi5jdXN0b21GaWVsZHNcbiAgfSA9IG9iamVjdCwgdmFsdWVzID0gb3B0aW9ucy52YWxpZGF0ZUZpZWxkcyA/IGNvbnRleHQuc2NoZW1hVHlwZS5maWVsZHMucmVkdWNlKChmaWVsZFZhbHVlcywgZmllbGQpID0+IHtcbiAgICBjb25zdCBmaWVsZFZhbHVlID0gb2JqZWN0W2ZpZWxkLm5hbWVdO1xuICAgIHJldHVybiBmaWVsZFZhbHVlICE9PSB2b2lkIDAgJiYgKGZpZWxkVmFsdWVzW2ZpZWxkLm5hbWVdID0gZmllbGRWYWx1ZSksIGZpZWxkVmFsdWVzO1xuICB9LCB7fSkgOiBjdXN0b21GaWVsZHM7XG4gIHJldHVybiB7XG4gICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hVHlwZS5uYW1lLFxuICAgIF9rZXk6IG9wdGlvbnMucmVmcmVzaEtleXMgPyBjb250ZXh0LmtleUdlbmVyYXRvcigpIDogdHlwZW9mIG9iamVjdC5fa2V5ID09IFwic3RyaW5nXCIgPyBvYmplY3QuX2tleSA6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgLi4udmFsdWVzXG4gIH07XG59XG5mdW5jdGlvbiBpc0tleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIHNlZ21lbnQgIT09IG51bGwgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICBjb250ZXh0LFxuICBibG9ja09mZnNldCxcbiAgZGlyZWN0aW9uXG59KSB7XG4gIGxldCBvZmZzZXRMZWZ0ID0gYmxvY2tPZmZzZXQub2Zmc2V0LCBzZWxlY3Rpb25Qb2ludCwgc2tpcHBlZElubGluZU9iamVjdCA9ICExO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpXG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGJsb2NrT2Zmc2V0LnBhdGhbMF0uX2tleSAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgICAgaWYgKCFpc1NwYW4kMShjb250ZXh0LCBjaGlsZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA8PSBjaGlsZC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uUG9pbnQgPSB7XG4gICAgICAgICAgICAgIHBhdGg6IFsuLi5ibG9ja09mZnNldC5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldExlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0TGVmdCAtPSBjaGlsZC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3BhbiQxKGNvbnRleHQsIGNoaWxkKSkge1xuICAgICAgICAgIHNraXBwZWRJbmxpbmVPYmplY3QgPSAhMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMCAmJiBzZWxlY3Rpb25Qb2ludCAmJiAhc2tpcHBlZElubGluZU9iamVjdCkge1xuICAgICAgICAgIHNraXBwZWRJbmxpbmVPYmplY3QgJiYgKHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICAgICAgcGF0aDogWy4uLmJsb2NrT2Zmc2V0LnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRMZWZ0ID4gY2hpbGQudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICBvZmZzZXRMZWZ0IC09IGNoaWxkLnRleHQubGVuZ3RoO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRMZWZ0IDw9IGNoaWxkLnRleHQubGVuZ3RoICYmIChzZWxlY3Rpb25Qb2ludCA9IHtcbiAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tPZmZzZXQucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXRMZWZ0XG4gICAgICAgIH0sIG9mZnNldExlZnQgLT0gY2hpbGQudGV4dC5sZW5ndGgsIG9mZnNldExlZnQgIT09IDApKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICByZXR1cm4gc2VsZWN0aW9uUG9pbnQ7XG59XG5mdW5jdGlvbiBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgY29udGV4dCxcbiAgc2VsZWN0aW9uUG9pbnRcbn0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGJsb2NrS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uUG9pbnQucGF0aFswXSkgPyBzZWxlY3Rpb25Qb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIHNwYW5LZXkgPSBpc0tleWVkU2VnbWVudChzZWxlY3Rpb25Qb2ludC5wYXRoWzJdKSA/IHNlbGVjdGlvblBvaW50LnBhdGhbMl0uX2tleSA6IHZvaWQgMDtcbiAgaWYgKCEoIWJsb2NrS2V5IHx8ICFzcGFuS2V5KSkge1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSlcbiAgICAgIGlmIChibG9jay5fa2V5ID09PSBibG9ja0tleSAmJiBpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNTcGFuJDEoY29udGV4dCwgY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gc3BhbktleSlcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgc2VsZWN0aW9uUG9pbnQub2Zmc2V0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQudGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICBjb250ZXh0LFxuICBibG9ja1xufSkge1xuICByZXR1cm4gaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2subm9kZSkgPyB7XG4gICAgcGF0aDogWy4uLmJsb2NrLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogYmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5XG4gICAgfV0sXG4gICAgb2Zmc2V0OiAwXG4gIH0gOiB7XG4gICAgcGF0aDogYmxvY2sucGF0aCxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRleHRCbG9ja1RleHQoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRleHQgPz8gXCJcIikuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU3Bhbihjb250ZXh0LCBjaGlsZCkge1xuICByZXR1cm4gY2hpbGQuX3R5cGUgPT09IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHJldHVybiBzZWxlY3Rpb24gJiYgKHNlbGVjdGlvbi5iYWNrd2FyZCA/IHtcbiAgICBhbmNob3I6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICBmb2N1czogc2VsZWN0aW9uLmFuY2hvcixcbiAgICBiYWNrd2FyZDogITFcbiAgfSA6IHtcbiAgICBhbmNob3I6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICBmb2N1czogc2VsZWN0aW9uLmFuY2hvcixcbiAgICBiYWNrd2FyZDogITBcbiAgfSk7XG59XG5mdW5jdGlvbiBzbGljZUJsb2Nrcyh7XG4gIGNvbnRleHQsXG4gIGJsb2Nrc1xufSkge1xuICBjb25zdCBzbGljZSA9IFtdO1xuICBpZiAoIWNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBzbGljZTtcbiAgbGV0IHN0YXJ0QmxvY2s7XG4gIGNvbnN0IG1pZGRsZUJsb2NrcyA9IFtdO1xuICBsZXQgZW5kQmxvY2s7XG4gIGNvbnN0IHN0YXJ0UG9pbnQgPSBjb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzIDogY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLCBlbmRQb2ludCA9IGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yIDogY29udGV4dC5zZWxlY3Rpb24uZm9jdXMsIHN0YXJ0QmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudChzdGFydFBvaW50LnBhdGhbMF0pID8gc3RhcnRQb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIGVuZEJsb2NrS2V5ID0gaXNLZXllZFNlZ21lbnQoZW5kUG9pbnQucGF0aFswXSkgPyBlbmRQb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIHN0YXJ0Q2hpbGRLZXkgPSBpc0tleWVkU2VnbWVudChzdGFydFBvaW50LnBhdGhbMl0pID8gc3RhcnRQb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDAsIGVuZENoaWxkS2V5ID0gaXNLZXllZFNlZ21lbnQoZW5kUG9pbnQucGF0aFsyXSkgPyBlbmRQb2ludC5wYXRoWzJdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghc3RhcnRCbG9ja0tleSB8fCAhZW5kQmxvY2tLZXkpXG4gICAgcmV0dXJuIHNsaWNlO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJsb2Nrcykge1xuICAgIGlmICghaXNUZXh0QmxvY2soY29udGV4dCwgYmxvY2spICYmIGJsb2NrLl9rZXkgPT09IHN0YXJ0QmxvY2tLZXkgJiYgYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkpIHtcbiAgICAgIHN0YXJ0QmxvY2sgPSBibG9jaztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRCbG9ja0tleSkge1xuICAgICAgaWYgKCFpc1RleHRCbG9jayhjb250ZXh0LCBibG9jaykpIHtcbiAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydENoaWxkS2V5KSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gc3RhcnRDaGlsZEtleSkge1xuICAgICAgICAgICAgaWYgKGlzU3BhbiQxKGNvbnRleHQsIGNoaWxkKSkge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkgPyBjaGlsZC50ZXh0LnNsaWNlKHN0YXJ0UG9pbnQub2Zmc2V0LCBlbmRQb2ludC5vZmZzZXQpIDogY2hpbGQudGV4dC5zbGljZShzdGFydFBvaW50Lm9mZnNldCk7XG4gICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdGFydENoaWxkS2V5ID09PSBlbmRDaGlsZEtleSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0QmxvY2sgJiYgaXNUZXh0QmxvY2soY29udGV4dCwgc3RhcnRCbG9jaykgJiYgKGVuZENoaWxkS2V5ICYmIGNoaWxkLl9rZXkgPT09IGVuZENoaWxkS2V5ICYmIGlzU3BhbiQxKGNvbnRleHQsIGNoaWxkKSA/IHN0YXJ0QmxvY2suY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIHRleHQ6IGNoaWxkLnRleHQuc2xpY2UoMCwgZW5kUG9pbnQub2Zmc2V0KVxuICAgICAgICAgIH0pIDogc3RhcnRCbG9jay5jaGlsZHJlbi5wdXNoKGNoaWxkKSwgYmxvY2suX2tleSA9PT0gZW5kQmxvY2tLZXkgJiYgZW5kQ2hpbGRLZXkgJiYgY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QmxvY2tLZXkgPT09IGVuZEJsb2NrS2V5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydEJsb2NrID0gYmxvY2ssIHN0YXJ0QmxvY2tLZXkgPT09IGVuZEJsb2NrS2V5KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEJsb2NrS2V5KSB7XG4gICAgICBpZiAoIWlzVGV4dEJsb2NrKGNvbnRleHQsIGJsb2NrKSkge1xuICAgICAgICBlbmRCbG9jayA9IGJsb2NrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlbmRDaGlsZEtleSkge1xuICAgICAgICBlbmRCbG9jayA9IHtcbiAgICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgICBpZiAoZW5kQmxvY2sgJiYgaXNUZXh0QmxvY2soY29udGV4dCwgZW5kQmxvY2spKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2tleSA9PT0gZW5kQ2hpbGRLZXkgJiYgaXNTcGFuJDEoY29udGV4dCwgY2hpbGQpKSB7XG4gICAgICAgICAgICAgIGVuZEJsb2NrLmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoaWxkLnRleHQuc2xpY2UoMCwgZW5kUG9pbnQub2Zmc2V0KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kQmxvY2suY2hpbGRyZW4ucHVzaChjaGlsZCksIGVuZENoaWxkS2V5ICYmIGNoaWxkLl9rZXkgPT09IGVuZENoaWxkS2V5KVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZW5kQmxvY2sgPSBibG9jaztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzdGFydEJsb2NrICYmIG1pZGRsZUJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgfVxuICByZXR1cm4gWy4uLnN0YXJ0QmxvY2sgPyBbc3RhcnRCbG9ja10gOiBbXSwgLi4ubWlkZGxlQmxvY2tzLCAuLi5lbmRCbG9jayA/IFtlbmRCbG9ja10gOiBbXV07XG59XG5leHBvcnQge1xuICBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LFxuICBnZXRCbG9ja1N0YXJ0UG9pbnQsXG4gIGdldFRleHRCbG9ja1RleHQsXG4gIGlzS2V5ZWRTZWdtZW50LFxuICBpc0xpc3RCbG9jayxcbiAgaXNTcGFuLFxuICBpc1NwYW4kMSxcbiAgaXNUZXh0QmxvY2ssXG4gIGlzVHlwZWRPYmplY3QsXG4gIHBhcnNlQW5ub3RhdGlvbixcbiAgcGFyc2VCbG9jayxcbiAgcGFyc2VCbG9ja09iamVjdCxcbiAgcGFyc2VCbG9ja3MsXG4gIHBhcnNlSW5saW5lT2JqZWN0LFxuICBwYXJzZVRleHRCbG9jayxcbiAgcmV2ZXJzZVNlbGVjdGlvbixcbiAgc2xpY2VCbG9ja3MsXG4gIHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLnNsaWNlLWJsb2Nrcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/behaviors/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/behaviors/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   effect: () => (/* binding */ effect),\n/* harmony export */   execute: () => (/* binding */ execute),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   raise: () => (/* binding */ raise)\n/* harmony export */ });\nfunction execute(event) {\n  return {\n    type: \"execute\",\n    event\n  };\n}\nfunction forward(event) {\n  return {\n    type: \"forward\",\n    event\n  };\n}\nfunction raise(event) {\n  return {\n    type: \"raise\",\n    event\n  };\n}\nfunction effect(effect2) {\n  return {\n    type: \"effect\",\n    effect: effect2\n  };\n}\nfunction defineBehavior(behavior) {\n  return behavior;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2JlaGF2aW9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYW50ZWMvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2JlaGF2aW9ycy9pbmRleC5qcz9iYjhjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGV4ZWN1dGUoZXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImV4ZWN1dGVcIixcbiAgICBldmVudFxuICB9O1xufVxuZnVuY3Rpb24gZm9yd2FyZChldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZm9yd2FyZFwiLFxuICAgIGV2ZW50XG4gIH07XG59XG5mdW5jdGlvbiByYWlzZShldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmFpc2VcIixcbiAgICBldmVudFxuICB9O1xufVxuZnVuY3Rpb24gZWZmZWN0KGVmZmVjdDIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgIGVmZmVjdDogZWZmZWN0MlxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgcmV0dXJuIGJlaGF2aW9yO1xufVxuZXhwb3J0IHtcbiAgZGVmaW5lQmVoYXZpb3IsXG4gIGVmZmVjdCxcbiAgZXhlY3V0ZSxcbiAgZm9yd2FyZCxcbiAgcmFpc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/behaviors/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorEventListener: () => (/* binding */ EditorEventListener),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   defineSchema: () => (/* binding */ defineSchema),\n/* harmony export */   keyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* reexport safe */ _chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_14__.useEditor),\n/* harmony export */   useEditorSelector: () => (/* binding */ useEditorSelector),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var _chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./_chunks-es/use-editor.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var _chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./_chunks-es/util.is-equal-selection-points.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-equal-selection-points.js\");\n/* harmony import */ var _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./_chunks-es/util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./_chunks-es/selector.is-selection-expanded.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js\");\n/* harmony import */ var _chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./_chunks-es/selector.is-selecting-entire-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js\");\n/* harmony import */ var slate_dom__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! slate-dom */ \"(ssr)/./node_modules/slate-dom/dist/index.es.js\");\n/* harmony import */ var _chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./_chunks-es/util.selection-point-to-block-offset.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.selection-point-to-block-offset.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n/* harmony import */ var _behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./behaviors/index.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/behaviors/index.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-b47a3833.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-527db318.development.esm.js\");\n/* harmony import */ var _portabletext_block_tools__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @portabletext/block-tools */ \"(ssr)/./node_modules/@portabletext/block-tools/lib/index.js\");\n/* harmony import */ var _portabletext_to_html__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @portabletext/to-html */ \"(ssr)/./node_modules/@portabletext/to-html/dist/pt-to-html.mjs\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./_chunks-es/util.child-selection-point-to-block-offset.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\");\n/* harmony import */ var lodash_startcase__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash.startcase */ \"(ssr)/./node_modules/lodash.startcase/index.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction EditorEventListener(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_14__.useEditor)(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_15__.useEffectEvent)(props.on);\n  let t0;\n  $[0] !== editor || $[1] !== on ? (t0 = () => {\n    const subscription = editor.on(\"*\", on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];\n  let t1;\n  return $[3] !== editor ? (t1 = [editor], $[3] = editor, $[4] = t1) : t1 = $[4], (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction getCompoundClientRect(nodes) {\n  if (nodes.length === 0)\n    return new DOMRect(0, 0, 0, 0);\n  const elements = nodes.filter((node) => node instanceof Element), firstRect = elements.at(0)?.getBoundingClientRect();\n  if (!firstRect)\n    return new DOMRect(0, 0, 0, 0);\n  let left = firstRect.left, top = firstRect.top, right = firstRect.right, bottom = firstRect.bottom;\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect();\n    left = Math.min(left, rect.left), top = Math.min(top, rect.top), right = Math.max(right, rect.right), bottom = Math.max(bottom, rect.bottom);\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_4__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_4__ && debug__WEBPACK_IMPORTED_MODULE_4__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_4__(namespace) : debug__WEBPACK_IMPORTED_MODULE_4__(rootName);\n}\nfunction getDragSelection({\n  eventSelection,\n  snapshot\n}) {\n  let dragSelection = eventSelection;\n  if ((0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getFocusInlineObject)({\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  }))\n    return dragSelection;\n  const draggingCollapsedSelection = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)({\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  }), draggedTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)({\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  }), draggedSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusSpan)({\n    context: {\n      ...snapshot.context,\n      selection: eventSelection\n    }\n  });\n  draggingCollapsedSelection && draggedTextBlock && draggedSpan && (dragSelection = {\n    anchor: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: draggedTextBlock\n    }),\n    focus: (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: draggedTextBlock\n    })\n  });\n  const selectedBlocks = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectedBlocks)(snapshot);\n  if (snapshot.context.selection && (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionExpanded)(snapshot) && selectedBlocks.length > 1) {\n    const selectionStartBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectionStartBlock)(snapshot), selectionEndBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectionEndBlock)(snapshot);\n    if (!selectionStartBlock || !selectionEndBlock)\n      return dragSelection;\n    const selectionStartPoint = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: selectionStartBlock\n    }), selectionEndPoint = (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: selectionEndBlock\n    });\n    (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isOverlappingSelection)(eventSelection)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionEndPoint\n        }\n      }\n    }) && (dragSelection = {\n      anchor: selectionStartPoint,\n      focus: selectionEndPoint\n    });\n  }\n  return dragSelection;\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, {\n  schemaTypes\n}, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const {\n      _type,\n      _key,\n      ...rest\n    } = block;\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const {\n          _type: cType,\n          _key: cKey,\n          ...cRest\n        } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n          _type: cType,\n          _key: cKey,\n          children: [{\n            _key: VOID_CHILD_KEY,\n            _type: \"span\",\n            text: \"\",\n            marks: []\n          }],\n          value: cRest,\n          __inline: !0\n        }, keyMap)) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].name), keepObjectEquality({\n        _type,\n        _key,\n        ...rest,\n        children\n      }, keyMap));\n    }\n    return keepObjectEquality({\n      _type,\n      _key,\n      children: [{\n        _key: VOID_CHILD_KEY,\n        _type: \"span\",\n        text: \"\",\n        marks: []\n      }],\n      value: rest\n    }, keyMap);\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const {\n      _key,\n      _type\n    } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const {\n          _type: _cType\n        } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child;\n          return keepObjectEquality({\n            ...rest,\n            ...v,\n            _key: k,\n            _type: t\n          }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({\n        ...block,\n        children,\n        _key,\n        _type\n      }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality({\n      _key,\n      _type,\n      ...typeof blockValue == \"object\" ? blockValue : {}\n    }, keyMap);\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].name && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nfunction getFocusBlock({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  try {\n    return slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, editor.selection.focus.path.slice(0, 1)) ?? [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getSelectionStartBlock({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  const selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Range.start(editor.selection);\n  return getPointBlock({\n    editor,\n    point: selectionStartPoint\n  });\n}\nfunction getSelectionEndBlock({\n  editor\n}) {\n  if (!editor.selection)\n    return [void 0, void 0];\n  const selectionEndPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Range.end(editor.selection);\n  return getPointBlock({\n    editor,\n    point: selectionEndPoint\n  });\n}\nfunction getPointBlock({\n  editor,\n  point\n}) {\n  try {\n    const [block] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, point.path.slice(0, 1)) ?? [void 0, void 0];\n    return block ? [block, point.path.slice(0, 1)] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getFocusChild({\n  editor\n}) {\n  const [focusBlock, focusBlockPath] = getFocusBlock({\n    editor\n  }), childIndex = editor.selection?.focus.path.at(1);\n  if (!focusBlock || !focusBlockPath || childIndex === void 0)\n    return [void 0, void 0];\n  try {\n    const focusChild = slate__WEBPACK_IMPORTED_MODULE_20__.Node.child(focusBlock, childIndex);\n    return focusChild ? [focusChild, [...focusBlockPath, childIndex]] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getPointChild({\n  editor,\n  point\n}) {\n  const [block, blockPath] = getPointBlock({\n    editor,\n    point\n  }), childIndex = point.path.at(1);\n  if (!block || !blockPath || childIndex === void 0)\n    return [void 0, void 0];\n  try {\n    const pointChild = slate__WEBPACK_IMPORTED_MODULE_20__.Node.child(block, childIndex);\n    return pointChild ? [pointChild, [...blockPath, childIndex]] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getFirstBlock({\n  editor\n}) {\n  const firstBlockPath = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, []).path.at(0);\n  try {\n    return firstBlockPath !== void 0 ? slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, [firstBlockPath]) ?? [void 0, void 0] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getLastBlock({\n  editor\n}) {\n  const lastBlockPath = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, []).path.at(0);\n  try {\n    return lastBlockPath !== void 0 ? slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, [lastBlockPath]) ?? [void 0, void 0] : [void 0, void 0];\n  } catch {\n    return [void 0, void 0];\n  }\n}\nfunction getNodeBlock({\n  editor,\n  schema,\n  node\n}) {\n  if (slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isEditor(node))\n    return;\n  if (isBlockElement({\n    editor,\n    schema\n  }, node))\n    return elementToBlock({\n      schema,\n      element: node\n    });\n  const parent = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n    mode: \"highest\",\n    at: [],\n    match: (n) => isBlockElement({\n      editor,\n      schema\n    }, n) && n.children.some((child) => child._key === node._key)\n  })).at(0)?.at(0);\n  return slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(parent) ? elementToBlock({\n    schema,\n    element: parent\n  }) : void 0;\n}\nfunction elementToBlock({\n  schema,\n  element\n}) {\n  return fromSlateValue([element], schema.block.name)?.at(0);\n}\nfunction isBlockElement({\n  editor,\n  schema\n}, node) {\n  return slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(node) && !editor.isInline(node) && (schema.block.name === node._type || schema.blockObjects.some((blockObject) => blockObject.name === node._type));\n}\nfunction isListItemActive({\n  editor,\n  listItem\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listItem) : !1;\n}\nfunction isStyleActive({\n  editor,\n  style\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => node.style === style) : !1;\n}\nfunction slateRangeToSelection({\n  schema,\n  editor,\n  range\n}) {\n  const [anchorBlock] = getPointBlock({\n    editor,\n    point: range.anchor\n  }), [focusBlock] = getPointBlock({\n    editor,\n    point: range.focus\n  });\n  if (!anchorBlock || !focusBlock)\n    return null;\n  const [anchorChild] = anchorBlock._type === schema.block.name ? getPointChild({\n    editor,\n    point: range.anchor\n  }) : [void 0, void 0], [focusChild] = focusBlock._type === schema.block.name ? getPointChild({\n    editor,\n    point: range.focus\n  }) : [void 0, void 0], selection = {\n    anchor: {\n      path: [{\n        _key: anchorBlock._key\n      }],\n      offset: range.anchor.offset\n    },\n    focus: {\n      path: [{\n        _key: focusBlock._key\n      }],\n      offset: range.focus.offset\n    },\n    backward: slate__WEBPACK_IMPORTED_MODULE_20__.Range.isBackward(range)\n  };\n  return anchorChild && (selection.anchor.path.push(\"children\"), selection.anchor.path.push({\n    _key: anchorChild._key\n  })), focusChild && (selection.focus.path.push(\"children\"), selection.focus.path.push({\n    _key: focusChild._key\n  })), selection;\n}\nfunction getEventPosition({\n  editorActor,\n  slateEditor,\n  event\n}) {\n  if (editorActor.getSnapshot().matches({\n    setup: \"setting up\"\n  }))\n    return;\n  const node = getEventNode({\n    slateEditor,\n    event\n  });\n  if (!node)\n    return;\n  const block = getNodeBlock({\n    editor: slateEditor,\n    schema: editorActor.getSnapshot().context.schema,\n    node\n  }), positionBlock = getEventPositionBlock({\n    node,\n    slateEditor,\n    event\n  }), selection = getEventSelection({\n    schema: editorActor.getSnapshot().context.schema,\n    slateEditor,\n    event\n  });\n  if (block && positionBlock && !selection && !slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isEditor(node))\n    return {\n      block: positionBlock,\n      isEditor: !1,\n      selection: {\n        anchor: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{\n              _key: block._key\n            }]\n          }\n        }),\n        focus: (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{\n              _key: block._key\n            }]\n          }\n        })\n      }\n    };\n  if (!positionBlock || !selection)\n    return;\n  const focusBlockPath = selection.focus.path.at(0), focusBlockKey = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isKeyedSegment)(focusBlockPath) ? focusBlockPath._key : void 0;\n  if (focusBlockKey)\n    return (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.isSelectionCollapsed)(selection) && block && focusBlockKey !== block._key ? {\n      block: positionBlock,\n      isEditor: !1,\n      selection: {\n        anchor: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{\n              _key: block._key\n            }]\n          }\n        }),\n        focus: (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{\n              _key: block._key\n            }]\n          }\n        })\n      }\n    } : {\n      block: positionBlock,\n      isEditor: slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isEditor(node),\n      selection\n    };\n}\nfunction getEventNode({\n  slateEditor,\n  event\n}) {\n  return slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.hasTarget(slateEditor, event.target) ? slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toSlateNode(slateEditor, event.target) : void 0;\n}\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event\n}) {\n  const [firstBlock] = getFirstBlock({\n    editor: slateEditor\n  });\n  if (!firstBlock)\n    return;\n  const firstBlockRect = slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toDOMNode(slateEditor, firstBlock).getBoundingClientRect();\n  if (event.pageY < firstBlockRect.top)\n    return \"start\";\n  const [lastBlock] = getLastBlock({\n    editor: slateEditor\n  });\n  if (!lastBlock)\n    return;\n  const lastBlockRef = slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toDOMNode(slateEditor, lastBlock).getBoundingClientRect();\n  if (event.pageY > lastBlockRef.bottom)\n    return \"end\";\n  const elementRect = slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toDOMNode(slateEditor, node).getBoundingClientRect(), top = elementRect.top, height = elementRect.height;\n  return Math.abs(top - event.pageY) < height / 2 ? \"start\" : \"end\";\n}\nfunction getEventSelection({\n  schema,\n  slateEditor,\n  event\n}) {\n  const range = getSlateRangeFromEvent(slateEditor, event);\n  return range ? slateRangeToSelection({\n    schema,\n    editor: slateEditor,\n    range\n  }) : null;\n}\nfunction getSlateRangeFromEvent(editor, event) {\n  if (!event.target || !(0,slate_dom__WEBPACK_IMPORTED_MODULE_22__.isDOMNode)(event.target))\n    return;\n  const window2 = slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.getWindow(editor);\n  let domRange;\n  if (window2.document.caretPositionFromPoint !== void 0) {\n    const position = window2.document.caretPositionFromPoint(event.clientX, event.clientY);\n    if (position)\n      try {\n        domRange = window2.document.createRange(), domRange.setStart(position.offsetNode, position.offset), domRange.setEnd(position.offsetNode, position.offset);\n      } catch {\n      }\n  } else if (window2.document.caretRangeFromPoint !== void 0)\n    domRange = window2.document.caretRangeFromPoint(event.clientX, event.clientY) ?? void 0;\n  else {\n    console.warn(\"Neither caretPositionFromPoint nor caretRangeFromPoint is supported\");\n    return;\n  }\n  if (!domRange)\n    return;\n  let range;\n  try {\n    range = slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: !1,\n      // It can still throw even with this option set to true\n      suppressThrow: !1\n    });\n  } catch {\n  }\n  return range;\n}\nfunction toSlatePath(path, editor) {\n  if (!editor)\n    return [];\n  const [block, blockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n    at: [],\n    match: (n) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_23__.isKeySegment)(path[0]) && n._key === path[0]._key\n  }))[0] || [void 0, void 0];\n  if (!block || !slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(block))\n    return [];\n  if (editor.isVoid(block))\n    return [blockPath[0], 0];\n  const childPath = [path[2]], childIndex = block.children.findIndex((child) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__([{\n    _key: child._key\n  }], childPath));\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex];\n    return slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n  }\n  return [blockPath[0], 0];\n}\nfunction toSlateRange(selection, editor) {\n  if (!selection || !editor)\n    return null;\n  const anchor = {\n    path: toSlatePath(selection.anchor.path, editor),\n    offset: selection.anchor.offset\n  }, focus = {\n    path: toSlatePath(selection.focus.path, editor),\n    offset: selection.focus.offset\n  };\n  return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? {\n    anchor,\n    focus\n  } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_20__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_20__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(focus, range.focus) ? range : {\n    anchor,\n    focus\n  };\n}\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({\n      _key: block._key\n    });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({\n        _key: child._key\n      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return {\n    path: newPath,\n    offset: newOffset\n  };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const {\n    anchor,\n    focus\n  } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n    _key: blk._key\n  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n    _key: blk._key\n  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n    anchor: newAnchor,\n    focus: newFocus,\n    backward: selection.backward\n  } : null;\n}\nfunction getSelectionDomNodes({\n  slateEditor,\n  snapshot\n}) {\n  if (!snapshot.context.selection)\n    return {\n      blockNodes: [],\n      childNodes: []\n    };\n  const range = toSlateRange(snapshot.context.selection, slateEditor);\n  if (!range)\n    return {\n      blockNodes: [],\n      childNodes: []\n    };\n  const blockEntries = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(slateEditor, {\n    at: range,\n    mode: \"highest\",\n    match: (n) => !slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isEditor(n)\n  })), childEntries = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(slateEditor, {\n    at: range,\n    mode: \"lowest\",\n    match: (n) => !slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isEditor(n) && slateEditor.isTextSpan(n) || !slateEditor.isBlock(n)\n  }));\n  return {\n    blockNodes: blockEntries.map(([blockNode]) => slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toDOMNode(slateEditor, blockNode)),\n    childNodes: childEntries.map(([childNode]) => slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.toDOMNode(slateEditor, childNode))\n  };\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), EditorActorContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nfunction DropIndicator() {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(1);\n  let t0;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { contentEditable: !1, className: \"pt-drop-indicator\", style: {\n    position: \"absolute\",\n    width: \"100%\",\n    height: 1,\n    borderBottom: \"1px solid currentColor\",\n    zIndex: 5\n  }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {}) }), $[0] = t0) : t0 = $[0], t0;\n}\nfunction RenderDefaultBlockObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.blockObject._key || $[2] !== props.blockObject._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: t0, children: [\n    \"[\",\n    props.blockObject._type,\n    \": \",\n    props.blockObject._key,\n    \"]\"\n  ] }), $[1] = props.blockObject._key, $[2] = props.blockObject._type, $[3] = t1) : t1 = $[3], t1;\n}\nfunction RenderDefaultInlineObject(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.inlineObject._key || $[2] !== props.inlineObject._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { style: t0, children: [\n    \"[\",\n    props.inlineObject._type,\n    \": \",\n    props.inlineObject._key,\n    \"]\"\n  ] }), $[1] = props.inlineObject._key, $[2] = props.inlineObject._type, $[3] = t1) : t1 = $[3], t1;\n}\nconst defaultKeyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {\n  let table;\n  return () => {\n    if (table)\n      return table;\n    table = [];\n    for (let i = 0; i < 256; ++i)\n      table[i] = (i + 256).toString(16).slice(1);\n    return table;\n  };\n})();\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n  const table = getByteHexTable();\n  return whatwgRNG(length).reduce((str, n) => str + table[n], \"\").slice(0, length);\n}\nfunction createEditorPriority(config) {\n  return {\n    id: defaultKeyGenerator(),\n    name: config?.name,\n    reference: config?.reference\n  };\n}\nconst corePriority = createEditorPriority({\n  name: \"core\"\n});\nfunction createCoreBlockElementBehaviorsConfig({\n  key,\n  onSetDragPositionBlock\n}) {\n  return [{\n    behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n      on: \"drag.dragover\",\n      guard: ({\n        snapshot,\n        event\n      }) => {\n        const dropFocusBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlock)({\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection\n          }\n        });\n        if (!dropFocusBlock || dropFocusBlock.node._key !== key)\n          return !1;\n        const dragOrigin = snapshot.beta.internalDrag?.origin;\n        return !dragOrigin || (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectedBlocks)({\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection\n          }\n        }).some((draggedBlock) => draggedBlock.node._key === key) ? !1 : (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isSelectingEntireBlocks)({\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection\n          }\n        });\n      },\n      actions: [({\n        event\n      }) => [{\n        type: \"effect\",\n        effect: () => {\n          onSetDragPositionBlock(event.position.block);\n        }\n      }]]\n    }),\n    priority: createEditorPriority({\n      reference: {\n        priority: corePriority,\n        importance: \"lower\"\n      }\n    })\n  }, {\n    behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n      on: \"drag.*\",\n      guard: ({\n        event\n      }) => event.type !== \"drag.dragover\",\n      actions: [({\n        event\n      }) => [{\n        type: \"effect\",\n        effect: () => {\n          onSetDragPositionBlock(void 0);\n        }\n      }, (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.forward)(event)]]\n    }),\n    priority: createEditorPriority({\n      reference: {\n        priority: corePriority,\n        importance: \"lower\"\n      }\n    })\n  }];\n}\nfunction useCoreBlockElementBehaviors(t0) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5), {\n    key,\n    onSetDragPositionBlock\n  } = t0, editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext);\n  let t1, t2;\n  $[0] !== editorActor || $[1] !== key || $[2] !== onSetDragPositionBlock ? (t1 = () => {\n    const behaviorConfigs = createCoreBlockElementBehaviorsConfig({\n      key,\n      onSetDragPositionBlock\n    });\n    for (const behaviorConfig of behaviorConfigs)\n      editorActor.send({\n        type: \"add behavior\",\n        behaviorConfig\n      });\n    return () => {\n      for (const behaviorConfig_0 of behaviorConfigs)\n        editorActor.send({\n          type: \"remove behavior\",\n          behaviorConfig: behaviorConfig_0\n        });\n    };\n  }, t2 = [editorActor, key, onSetDragPositionBlock], $[0] = editorActor, $[1] = key, $[2] = onSetDragPositionBlock, $[3] = t1, $[4] = t2) : (t1 = $[3], t2 = $[4]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t1, t2);\n}\nfunction RenderBlockObject(props) {\n  const [dragPositionBlock, setDragPositionBlock] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), blockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSelected)(), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext);\n  useCoreBlockElementBehaviors({\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock\n  });\n  const legacySchemaType = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, (s) => s.context.getLegacySchema().blockObjects.find((blockObject) => blockObject.name === props.element._type));\n  legacySchemaType || console.error(`Block object type ${props.element._type} not found in Schema`);\n  const focused = selected && slateEditor.selection !== null && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(slateEditor.selection);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ...props.attributes, className: \"pt-block pt-object-block\", \"data-block-key\": props.element._key, \"data-block-name\": props.element._type, \"data-block-type\": \"object\", children: [\n    dragPositionBlock === \"start\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null,\n    props.children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: blockObjectRef, contentEditable: !1, draggable: !props.readOnly, children: props.renderBlock && legacySchemaType ? props.renderBlock({\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultBlockObject, { blockObject: props.blockObject }),\n      editorElementRef: blockObjectRef,\n      focused,\n      path: [{\n        _key: props.element._key\n      }],\n      schemaType: legacySchemaType,\n      selected,\n      type: legacySchemaType,\n      value: props.blockObject\n    }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultBlockObject, { blockObject: props.blockObject }) }),\n    dragPositionBlock === \"end\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null\n  ] });\n}\nfunction RenderInlineObject(props) {\n  const inlineObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSelected)(), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), legacySchemaType = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, (s) => s.context.getLegacySchema().inlineObjects.find((inlineObject) => inlineObject.name === props.element._type));\n  legacySchemaType || console.error(`Inline object type ${props.element._type} not found in Schema`);\n  const focused = selected && slateEditor.selection !== null && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(slateEditor.selection), path = slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.findPath(slateEditor, props.element), [block] = getPointBlock({\n    editor: slateEditor,\n    point: {\n      path,\n      offset: 0\n    }\n  });\n  return block || console.error(`Unable to find parent block of inline object ${props.element._key}`), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { ...props.attributes, draggable: !props.readOnly, className: \"pt-inline-object\", \"data-child-key\": props.inlineObject._key, \"data-child-name\": props.inlineObject._type, \"data-child-type\": \"object\", children: [\n    props.children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ref: inlineObjectRef, style: {\n      display: \"inline-block\"\n    }, children: props.renderChild && block && legacySchemaType ? props.renderChild({\n      annotations: [],\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultInlineObject, { inlineObject: props.inlineObject }),\n      editorElementRef: inlineObjectRef,\n      selected,\n      focused,\n      path: [{\n        _key: block._key\n      }, \"children\", {\n        _key: props.element._key\n      }],\n      schemaType: legacySchemaType,\n      value: props.inlineObject,\n      type: legacySchemaType\n    }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderDefaultInlineObject, { inlineObject: props.inlineObject }) })\n  ] });\n}\nfunction RenderTextBlock(props) {\n  const [dragPositionBlock, setDragPositionBlock] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSelected)(), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext);\n  useCoreBlockElementBehaviors({\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock\n  });\n  const legacySchema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, (s) => s.context.getLegacySchema()), focused = selected && slateEditor.selection !== null && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(slateEditor.selection);\n  let children = props.children;\n  const legacyBlockSchemaType = legacySchema.block;\n  if (props.renderStyle && props.textBlock.style) {\n    const legacyStyleSchemaType = props.textBlock.style !== void 0 ? legacySchema.styles.find((style) => style.value === props.textBlock.style) : void 0;\n    legacyStyleSchemaType ? children = props.renderStyle({\n      block: props.textBlock,\n      children,\n      editorElementRef: blockRef,\n      focused,\n      path: [{\n        _key: props.textBlock._key\n      }],\n      schemaType: legacyStyleSchemaType,\n      selected,\n      value: props.textBlock.style\n    }) : console.error(`Unable to find Schema type for text block style ${props.textBlock.style}`);\n  }\n  if (props.renderListItem && props.textBlock.listItem) {\n    const legacyListItemSchemaType = legacySchema.lists.find((list) => list.value === props.textBlock.listItem);\n    legacyListItemSchemaType ? children = props.renderListItem({\n      block: props.textBlock,\n      children,\n      editorElementRef: blockRef,\n      focused,\n      level: props.textBlock.level ?? 1,\n      path: [{\n        _key: props.textBlock._key\n      }],\n      selected,\n      value: props.textBlock.listItem,\n      schemaType: legacyListItemSchemaType\n    }) : console.error(`Unable to find Schema type for text block list item ${props.textBlock.listItem}`);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ...props.attributes, className: [\"pt-block\", \"pt-text-block\", ...props.textBlock.style ? [`pt-text-block-style-${props.textBlock.style}`] : [], ...props.textBlock.listItem ? [\"pt-list-item\", `pt-list-item-${props.textBlock.listItem}`, `pt-list-item-level-${props.textBlock.level ?? 1}`] : []].join(\" \"), spellCheck: props.spellCheck, \"data-block-key\": props.textBlock._key, \"data-block-name\": props.textBlock._type, \"data-block-type\": \"text\", children: [\n    dragPositionBlock === \"start\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: blockRef, children: props.renderBlock ? props.renderBlock({\n      children,\n      editorElementRef: blockRef,\n      focused,\n      level: props.textBlock.level,\n      listItem: props.textBlock.listItem,\n      path: [{\n        _key: props.textBlock._key\n      }],\n      selected,\n      schemaType: legacyBlockSchemaType,\n      style: props.textBlock.style,\n      type: legacyBlockSchemaType,\n      value: props.textBlock\n    }) : props.children }),\n    dragPositionBlock === \"end\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropIndicator, {}) : null\n  ] });\n}\nfunction RenderElement(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(45), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), schema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, _temp$1);\n  if (\"__inline\" in props.element && props.element.__inline === !0) {\n    let t02;\n    if ($[0] !== props.element || $[1] !== schema) {\n      let t13;\n      $[3] !== props.element ? (t13 = \"value\" in props.element && typeof props.element.value == \"object\" ? props.element.value : {}, $[3] = props.element, $[4] = t13) : t13 = $[4], t02 = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseInlineObject)({\n        context: {\n          keyGenerator: _temp2,\n          schema\n        },\n        options: {\n          refreshKeys: !1,\n          validateFields: !1\n        },\n        inlineObject: {\n          _key: props.element._key,\n          _type: props.element._type,\n          ...t13\n        }\n      }), $[0] = props.element, $[1] = schema, $[2] = t02;\n    } else\n      t02 = $[2];\n    const inlineObject = t02;\n    inlineObject || console.error(`Unable to find Inline Object \"${props.element._type}\" in Schema`);\n    let t12;\n    $[5] !== inlineObject || $[6] !== props.element._key || $[7] !== props.element._type ? (t12 = inlineObject ?? {\n      _key: props.element._key,\n      _type: props.element._type\n    }, $[5] = inlineObject, $[6] = props.element._key, $[7] = props.element._type, $[8] = t12) : t12 = $[8];\n    let t22;\n    return $[9] !== props.attributes || $[10] !== props.children || $[11] !== props.element || $[12] !== props.readOnly || $[13] !== props.renderChild || $[14] !== t12 ? (t22 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderInlineObject, { attributes: props.attributes, element: props.element, inlineObject: t12, readOnly: props.readOnly, renderChild: props.renderChild, children: props.children }), $[9] = props.attributes, $[10] = props.children, $[11] = props.element, $[12] = props.readOnly, $[13] = props.renderChild, $[14] = t12, $[15] = t22) : t22 = $[15], t22;\n  }\n  let t0;\n  $[16] !== props.element || $[17] !== schema ? (t0 = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseTextBlock)({\n    context: {\n      keyGenerator: _temp3,\n      schema\n    },\n    options: {\n      refreshKeys: !1,\n      validateFields: !1\n    },\n    block: props.element\n  }), $[16] = props.element, $[17] = schema, $[18] = t0) : t0 = $[18];\n  const textBlock = t0;\n  if (textBlock) {\n    let t12;\n    return $[19] !== props.attributes || $[20] !== props.children || $[21] !== props.element || $[22] !== props.readOnly || $[23] !== props.renderBlock || $[24] !== props.renderListItem || $[25] !== props.renderStyle || $[26] !== props.spellCheck || $[27] !== textBlock ? (t12 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderTextBlock, { attributes: props.attributes, element: props.element, readOnly: props.readOnly, renderBlock: props.renderBlock, renderListItem: props.renderListItem, renderStyle: props.renderStyle, spellCheck: props.spellCheck, textBlock, children: props.children }), $[19] = props.attributes, $[20] = props.children, $[21] = props.element, $[22] = props.readOnly, $[23] = props.renderBlock, $[24] = props.renderListItem, $[25] = props.renderStyle, $[26] = props.spellCheck, $[27] = textBlock, $[28] = t12) : t12 = $[28], t12;\n  }\n  let t1;\n  if ($[29] !== props.element || $[30] !== schema) {\n    let t22;\n    $[32] !== props.element ? (t22 = \"value\" in props.element && typeof props.element.value == \"object\" ? props.element.value : {}, $[32] = props.element, $[33] = t22) : t22 = $[33], t1 = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlockObject)({\n      context: {\n        keyGenerator: _temp4,\n        schema\n      },\n      options: {\n        refreshKeys: !1,\n        validateFields: !1\n      },\n      blockObject: {\n        _key: props.element._key,\n        _type: props.element._type,\n        ...t22\n      }\n    }), $[29] = props.element, $[30] = schema, $[31] = t1;\n  } else\n    t1 = $[31];\n  const blockObject = t1;\n  blockObject || console.error(`Unable to find Block Object \"${props.element._type}\" in Schema`);\n  let t2;\n  $[34] !== blockObject || $[35] !== props.element._key || $[36] !== props.element._type ? (t2 = blockObject ?? {\n    _key: props.element._key,\n    _type: props.element._type\n  }, $[34] = blockObject, $[35] = props.element._key, $[36] = props.element._type, $[37] = t2) : t2 = $[37];\n  let t3;\n  return $[38] !== props.attributes || $[39] !== props.children || $[40] !== props.element || $[41] !== props.readOnly || $[42] !== props.renderBlock || $[43] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderBlockObject, { attributes: props.attributes, blockObject: t2, element: props.element, readOnly: props.readOnly, renderBlock: props.renderBlock, children: props.children }), $[38] = props.attributes, $[39] = props.children, $[40] = props.element, $[41] = props.readOnly, $[42] = props.renderBlock, $[43] = t2, $[44] = t3) : t3 = $[44], t3;\n}\nfunction _temp4() {\n  return \"\";\n}\nfunction _temp3() {\n  return \"\";\n}\nfunction _temp2() {\n  return \"\";\n}\nfunction _temp$1(s) {\n  return s.context.schema;\n}\nconst PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n  return editor;\n};\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_28__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nconst forEachActor = (actorRef, callback) => {\n  callback(actorRef);\n  const children = actorRef.getSnapshot().children;\n  children && Object.values(children).forEach((child) => {\n    forEachActor(child, callback);\n  });\n};\nfunction stopActor(actorRef) {\n  const persistedSnapshots = [];\n  forEachActor(actorRef, (ref) => {\n    persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();\n  });\n  const systemSnapshot = actorRef.system.getSnapshot?.();\n  actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {\n    ref._processingStatus = 0, ref._snapshot = snapshot;\n  });\n}\nconst converterJson = {\n  mimeType: \"application/json\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === \"application/x-portable-text\");\n    return portableTextConverter ? {\n      ...portableTextConverter.serialize({\n        snapshot,\n        event\n      }),\n      mimeType: \"application/json\",\n      originEvent: event.originEvent\n    } : {\n      type: \"serialization.failure\",\n      mimeType: \"application/json\",\n      originEvent: event.originEvent,\n      reason: \"No application/x-portable-text Converter found\"\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === \"application/x-portable-text\");\n    return portableTextConverter ? {\n      ...portableTextConverter.deserialize({\n        snapshot,\n        event\n      }),\n      mimeType: \"application/json\"\n    } : {\n      type: \"deserialization.failure\",\n      mimeType: \"application/json\",\n      reason: \"No application/x-portable-text Converter found\"\n    };\n  }\n}, converterPortableText = {\n  mimeType: \"application/x-portable-text\",\n  serialize: ({\n    snapshot,\n    event\n  }) => {\n    const selection = snapshot.beta.internalDrag?.origin.selection ?? snapshot.context.selection;\n    if (!selection)\n      return {\n        type: \"serialization.failure\",\n        mimeType: \"application/x-portable-text\",\n        originEvent: event.originEvent,\n        reason: \"No selection\"\n      };\n    const blocks = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.sliceBlocks)({\n      context: {\n        selection,\n        schema: snapshot.context.schema\n      },\n      blocks: snapshot.context.value\n    });\n    return blocks.length === 0 ? {\n      type: \"serialization.failure\",\n      mimeType: \"application/x-portable-text\",\n      reason: \"No blocks serialized\",\n      originEvent: event.originEvent\n    } : {\n      type: \"serialization.success\",\n      data: JSON.stringify(blocks),\n      mimeType: \"application/x-portable-text\",\n      originEvent: event.originEvent\n    };\n  },\n  deserialize: ({\n    snapshot,\n    event\n  }) => {\n    const blocks = JSON.parse(event.data);\n    if (!Array.isArray(blocks))\n      return {\n        type: \"deserialization.failure\",\n        mimeType: \"application/x-portable-text\",\n        reason: \"Data is not an array\"\n      };\n    const parsedBlocks = blocks.flatMap((block) => {\n      const parsedBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n        context: snapshot.context,\n        block,\n        options: {\n          /**\n           * If we are dragging internally then we would like to keep the\n           * dropped portable text as is.\n           */\n          refreshKeys: !snapshot.beta.hasTag?.(\"dragging internally\"),\n          validateFields: !1\n        }\n      });\n      return parsedBlock ? [parsedBlock] : [];\n    });\n    return parsedBlocks.length === 0 && blocks.length > 0 ? {\n      type: \"deserialization.failure\",\n      mimeType: \"application/x-portable-text\",\n      reason: \"No blocks were parsed\"\n    } : {\n      type: \"deserialization.success\",\n      data: parsedBlocks,\n      mimeType: \"application/x-portable-text\"\n    };\n  }\n};\nfunction createConverterTextHtml(legacySchema) {\n  return {\n    mimeType: \"text/html\",\n    serialize: ({\n      snapshot,\n      event\n    }) => {\n      const selection = snapshot.beta.internalDrag?.origin.selection ?? snapshot.context.selection;\n      if (!selection)\n        return {\n          type: \"serialization.failure\",\n          mimeType: \"text/html\",\n          originEvent: event.originEvent,\n          reason: \"No selection\"\n        };\n      const blocks = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.sliceBlocks)({\n        context: {\n          selection,\n          schema: snapshot.context.schema\n        },\n        blocks: snapshot.context.value\n      }), html = (0,_portabletext_to_html__WEBPACK_IMPORTED_MODULE_29__.toHTML)(blocks, {\n        onMissingComponent: !1,\n        components: {\n          unknownType: ({\n            children\n          }) => children !== void 0 ? `${children}` : \"\"\n        }\n      });\n      return html === \"\" ? {\n        type: \"serialization.failure\",\n        mimeType: \"text/html\",\n        originEvent: event.originEvent,\n        reason: \"Serialized HTML is empty\"\n      } : {\n        type: \"serialization.success\",\n        data: html,\n        mimeType: \"text/html\",\n        originEvent: event.originEvent\n      };\n    },\n    deserialize: ({\n      snapshot,\n      event\n    }) => {\n      const parsedBlocks = (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_30__.htmlToBlocks)(event.data, legacySchema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator,\n        unstable_whitespaceOnPasteMode: legacySchema.block.options.unstable_whitespaceOnPasteMode\n      }).flatMap((block) => {\n        const parsedBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n          context: snapshot.context,\n          block,\n          options: {\n            refreshKeys: !1,\n            validateFields: !0\n          }\n        });\n        return parsedBlock ? [parsedBlock] : [];\n      });\n      return parsedBlocks.length === 0 ? {\n        type: \"deserialization.failure\",\n        mimeType: \"text/html\",\n        reason: \"No blocks deserialized\"\n      } : {\n        type: \"deserialization.success\",\n        data: parsedBlocks,\n        mimeType: \"text/html\"\n      };\n    }\n  };\n}\nfunction createConverterTextPlain(legacySchema) {\n  return {\n    mimeType: \"text/plain\",\n    serialize: ({\n      snapshot,\n      event\n    }) => {\n      const selection = snapshot.beta.internalDrag?.origin.selection ?? snapshot.context.selection;\n      return selection ? {\n        type: \"serialization.success\",\n        data: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.sliceBlocks)({\n          context: {\n            selection,\n            schema: snapshot.context.schema\n          },\n          blocks: snapshot.context.value\n        }).map((block) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, block) ? block.children.map((child) => child._type === snapshot.context.schema.span.name ? child.text : snapshot.beta.hasTag(\"dragging internally\") ? `[${snapshot.context.schema.inlineObjects.find((inlineObjectType) => inlineObjectType.name === child._type)?.title ?? \"Object\"}]` : \"\").join(\"\") : snapshot.beta.hasTag(\"dragging internally\") ? `[${snapshot.context.schema.blockObjects.find((blockObjectType) => blockObjectType.name === block._type)?.title ?? \"Object\"}]` : \"\").filter((block) => block !== \"\").join(`\n\n`),\n        mimeType: \"text/plain\",\n        originEvent: event.originEvent\n      } : {\n        type: \"serialization.failure\",\n        mimeType: \"text/plain\",\n        originEvent: event.originEvent,\n        reason: \"No selection\"\n      };\n    },\n    deserialize: ({\n      snapshot,\n      event\n    }) => {\n      const textToHtml = `<html><body>${escapeHtml(event.data).split(/\\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`, parsedBlocks = (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_30__.htmlToBlocks)(textToHtml, legacySchema.portableText, {\n        keyGenerator: snapshot.context.keyGenerator\n      }).flatMap((block) => {\n        const parsedBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n          context: snapshot.context,\n          block,\n          options: {\n            refreshKeys: !1,\n            validateFields: !0\n          }\n        });\n        return parsedBlock ? [parsedBlock] : [];\n      });\n      return parsedBlocks.length === 0 ? {\n        type: \"deserialization.failure\",\n        mimeType: \"text/plain\",\n        reason: \"No blocks deserialized\"\n      } : {\n        type: \"deserialization.success\",\n        data: parsedBlocks,\n        mimeType: \"text/plain\"\n      };\n    }\n  };\n}\nconst entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nfunction createCoreConverters(legacySchema) {\n  return [converterJson, converterPortableText, createConverterTextHtml(legacySchema), createConverterTextPlain(legacySchema)];\n}\nconst debug$h = debugWithName(\"operationToPatches\");\nfunction createOperationToPatches(editorActor) {\n  const textBlockName = editorActor.getSnapshot().context.schema.block.name;\n  function insertTextPatch(editor, operation, beforeValue) {\n    debug$h.enabled && debug$h(\"Operation\", JSON.stringify(operation, null, 2));\n    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.diffMatchPatch)(prevText, textChild.text, path);\n    return patch.value.length ? [patch] : [];\n  }\n  function removeTextPatch(editor, operation, beforeValue) {\n    const block = editor && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n    if (child && !textChild)\n      throw new Error(\"Expected span\");\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n    return patch.value ? [patch] : [];\n  }\n  function setNodePatch(editor, operation) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]];\n      if (typeof block._key != \"string\")\n        throw new Error(\"Expected block to have a _key\");\n      const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_9__({\n        ...editor.children[operation.path[0]],\n        ...operation.newProperties\n      }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_8__);\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(fromSlateValue([setNode], textBlockName)[0], [{\n        _key: block._key\n      }])];\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]];\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]];\n        if (child) {\n          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n          return keys.forEach((keyName) => {\n            if (keys.length === 1 && keyName === \"_key\") {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_7__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(val, [{\n                _key: blockKey\n              }, \"children\", block.children.indexOf(child), keyName]));\n            } else {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_7__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(val, [{\n                _key: blockKey\n              }, \"children\", {\n                _key: childKey\n              }, keyName]));\n            }\n          }), patches;\n        }\n        throw new Error(\"Could not find a valid child\");\n      }\n      throw new Error(\"Could not find a valid block\");\n    } else\n      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n  }\n  function insertNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]], isTextBlock2 = editor.isTextBlock(block);\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n      return targetKey ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([fromSlateValue([operation.node], textBlockName)[0]], position, [{\n        _key: targetKey\n      }])] : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.setIfMissing)(beforeValue, []), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([fromSlateValue([operation.node], textBlockName)[0]], \"before\", [operation.path[0]])];\n    } else if (isTextBlock2 && operation.path.length === 2 && editor.children[operation.path[0]]) {\n      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n        ...operation.node\n      };\n      !node._type && slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n      const child = fromSlateValue([{\n        _key: \"bogus\",\n        _type: textBlockName,\n        children: [node]\n      }], textBlockName)[0].children[0];\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([child], position, [{\n        _key: block._key\n      }, \"children\", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n        _key: block.children[operation.path[1] - 1]._key\n      }])];\n    }\n    return debug$h(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n  }\n  function splitNodePatch(editor, operation, beforeValue) {\n    const patches = [], splitBlock = editor.children[operation.path[0]];\n    if (!editor.isTextBlock(splitBlock))\n      throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]];\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];\n        targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([targetValue], \"after\", [{\n          _key: splitBlock._key\n        }])), oldBlock.children.slice(operation.position).forEach((span) => {\n          const path = [{\n            _key: oldBlock._key\n          }, \"children\", {\n            _key: span._key\n          }];\n          patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)(path));\n        }));\n      }\n      return patches;\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]];\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = fromSlateValue([{\n          ...splitBlock,\n          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n        }], textBlockName)[0].children;\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)(targetSpans, \"after\", [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(splitSpan.text, [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }, \"text\"]));\n      }\n      return patches;\n    }\n    return patches;\n  }\n  function removeNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]];\n    if (operation.path.length === 1) {\n      if (block && block._key)\n        return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n          _key: block._key\n        }])];\n      throw new Error(\"Block not found\");\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = block.children[operation.path[1]];\n      return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: spanToRemove._key\n      }])] : (debug$h(\"Span not found in editor trying to remove node\"), []);\n    } else\n      return debug$h(\"Not creating patch inside object block\"), [];\n  }\n  function mergeNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];\n    if (operation.path.length === 1)\n      if (block?._key) {\n        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(newBlock, [{\n          _key: newBlock._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n          _key: block._key\n        }]));\n      } else\n        throw new Error(\"Target key not found!\");\n    else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {\n      const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n      updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(updatedSpan.text, [{\n        _key: block._key\n      }, \"children\", {\n        _key: updatedSpan._key\n      }, \"text\"])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: removedSpan._key\n      }])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n    } else\n      debug$h(\"Void nodes can't be merged, not creating any patches\");\n    return patches;\n  }\n  function moveNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n    if (!targetBlock)\n      return patches;\n    if (operation.path.length === 1) {\n      const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n        _key: block._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([fromSlateValue([block], textBlockName)[0]], position, [{\n        _key: targetBlock._key\n      }]));\n    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: child._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([childToInsert], position, [{\n        _key: targetBlock._key\n      }, \"children\", {\n        _key: targetChild._key\n      }]));\n    }\n    return patches;\n  }\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch\n  };\n}\nconst insertTextOperationImplementation = ({\n  operation\n}) => {\n  operation.editor.marks ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(operation.editor, {\n    text: operation.text,\n    ...operation.editor.marks\n  }) : slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertText(operation.editor, operation.text), operation.editor.marks = null;\n};\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let previousSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, blockPath, {\n    reverse: !0\n  }))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_20__.Path.isBefore(childPath, spanPath)) {\n      previousSpan = child;\n      break;\n    }\n  return previousSpan;\n}\nfunction getNextSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let nextSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, blockPath))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_20__.Path.isAfter(childPath, spanPath)) {\n      nextSpan = child;\n      break;\n    }\n  return nextSpan;\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n  const prev = isUndoing(editor);\n  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n  return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n  IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n  const prev = isRedoing(editor);\n  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n  return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n  IS_REDOING.set(editor, isRedoing2);\n}\nconst debug$g = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor, decorators = editorActor.getSnapshot().context.schema.decorators.map((t) => t.name);\n    return editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry;\n      if (editor.isTextBlock(node)) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, path);\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1];\n          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {\n            debug$g(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: !0\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug$g(\"Adding .markDefs to block node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          markDefs: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug$g(\"Adding .marks to span node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          marks: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_20__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, blockPath), decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));\n        if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n          debug$g(\"Removing annotations from empty span node\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n            marks: node.marks?.filter((mark) => decorators2.includes(mark))\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name);\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, path))\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));\n            if (orphanedAnnotations.length > 0) {\n              debug$g(\"Removing orphaned annotations from span node\"), editorActor.send({\n                type: \"normalizing\"\n              }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n              }, {\n                at: childPath\n              }), editorActor.send({\n                type: \"done normalizing\"\n              });\n              return;\n            }\n          }\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_20__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, blockPath);\n        if (editor.isTextBlock(block)) {\n          const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));\n          if (orphanedAnnotations.length > 0) {\n            debug$g(\"Removing orphaned annotations from span node\"), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n            }, {\n              at: path\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n        for (const markDef of markDefs)\n          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n        if (markDefs.length !== newMarkDefs.length) {\n          debug$g(\"Removing duplicate markDefs\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(newMarkDefs, node.markDefs)) {\n          debug$g(\"Removing markDef not in use\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      normalizeNode(nodeEntry);\n    }, editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"set_selection\" && slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n        const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed({\n          anchor: op.properties.anchor,\n          focus: op.properties.focus\n        }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed({\n          anchor: op.newProperties.anchor,\n          focus: op.newProperties.focus\n        });\n        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n          const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.properties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.newProperties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n          if (movedToNextSpan || movedToPreviousSpan)\n            return;\n        }\n      }\n      if (op.type === \"insert_node\") {\n        const {\n          selection\n        } = editor;\n        if (selection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, selection, {\n            depth: 1\n          }), previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path\n          }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1]\n          }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation) => !nextSpanAnnotations?.includes(annotation)) ?? [], atTheEndOfAnnotation = annotationsEnding.length > 0;\n          if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsEnding.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: op.node.marks?.filter((mark) => !annotationsEnding.includes(mark)) ?? []\n            });\n            return;\n          }\n          const annotationsStarting = nextSpanAnnotations?.filter((annotation) => !previousSpanAnnotations?.includes(annotation)) ?? [], atTheStartOfAnnotation = annotationsStarting.length > 0;\n          if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsStarting.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: op.node.marks?.filter((mark) => !annotationsStarting.includes(mark)) ?? []\n            });\n            return;\n          }\n          const nextSpanDecorators = nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? [];\n          if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.length === 0) {\n            slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n              ...op.node,\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              marks: nextSpanDecorators\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"insert_text\") {\n        const {\n          selection\n        } = editor, collapsedSelection = selection ? slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(selection) : !1;\n        if (selection && collapsedSelection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: selection.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpanAnnotations = nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));\n          if (spanHasAnnotations && !spanIsEmpty) {\n            if (atTheBeginningOfSpan) {\n              if (previousSpanHasSameMarks) {\n                slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotation) {\n                apply2(op);\n                return;\n              } else if (!previousSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n            if (atTheEndOfSpan) {\n              if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: nextSpan?.marks ?? []\n                });\n                return;\n              }\n              if (!nextSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n          }\n          if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {\n            slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, {\n              _type: \"span\",\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              text: op.text,\n              marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark) => decorators.includes(mark))\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"remove_text\") {\n        const {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(selection)) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: {\n              path: op.path,\n              offset: op.offset\n            },\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0];\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), nextSpan = getNextSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;\n            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n              const marksWithoutAnnotationMarks = ({\n                ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {}\n              }.marks || []).filter((mark) => decorators.includes(mark));\n              slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(editor, () => {\n                apply2(op), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n                  marks: marksWithoutAnnotationMarks\n                }, {\n                  at: op.path\n                });\n              }), editor.onChange();\n              return;\n            }\n          }\n        }\n      }\n      if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === editorActor.getSnapshot().context.schema.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n        const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, [op.path[0] - 1]);\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__([...oldDefs, ...op.properties.markDefs]);\n          debug$g(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: targetPath,\n            voids: !1\n          }), apply2(op);\n          return;\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst removeDecoratorOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor, mark = operation.decorator, {\n    selection\n  } = editor;\n  if (selection) {\n    if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(selection))\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText,\n        split: !0,\n        hanging: !0\n      }), editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText\n      })].forEach(([node, path]) => {\n        const block = editor.children[path[0]];\n        slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),\n          _type: \"span\"\n        }, {\n          at: path\n        });\n      });\n    else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          marks: existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else {\n        const existingMarks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {}\n        }.marks || [], marks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {},\n          marks: existingMarks.filter((eMark) => eMark !== mark)\n        };\n        editor.marks = {\n          marks: marks.marks,\n          _type: \"span\"\n        };\n      }\n    }\n    if (editor.selection) {\n      const selection2 = editor.selection;\n      editor.selection = {\n        ...selection2\n      };\n    }\n  }\n};\nfunction isDecoratorActive({\n  editor,\n  decorator\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedTextNodes = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n    match: slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText,\n    at: editor.selection\n  }));\n  return selectedTextNodes.length === 0 ? !1 : slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(editor.selection) ? selectedTextNodes.every((n) => {\n    const [node] = n;\n    return node.marks?.includes(decorator);\n  }) : ({\n    ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {}\n  }.marks || []).includes(decorator);\n}\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0) return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2) return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1) return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++) v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); ) x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;\n      else if (y1 > text2Length) k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); ) x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;\n      else if (y2 > text2Length) k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0) return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length) return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2) return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch) throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++) text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--) diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1) return [[DIFF_INSERT, text2]];\n  if (!text2) return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1) return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1) return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null) throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2) return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++) diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two) return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; ) switch (diffs[pointer][0]) {\n    case DIFF_INSERT:\n      countInsert++, textInsert += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_DELETE:\n      countDelete++, textDelete += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_EQUAL:\n      countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n      break;\n    default:\n      throw new Error(\"Unknown diff operation\");\n  }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; ) diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1) throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; ) getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);\n        else break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold) break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation, options = {}) {\n  if (text === null || pattern === null || searchLocation === null) throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern) return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern) return loc;\n  } else return -1;\n  return bitap(text, pattern, loc, options);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, location) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++) lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\") throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\") return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target) throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches) adjusted.push({\n    diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n    start1: advanceTo(patch.start1),\n    start2: advanceTo(patch.start2),\n    utf8Start1: patch.utf8Start1,\n    utf8Start2: patch.utf8Start2,\n    length1: patch.length1,\n    length2: patch.length2,\n    utf8Length1: patch.utf8Length1,\n    utf8Length2: patch.utf8Length2\n  });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++) nullPadding += String.fromCharCode(x);\n  for (const p of patches) p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize) continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\") throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0) return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline) return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\") break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\") patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\") patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \") patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst CURRENT_UNDO_STEP = /* @__PURE__ */ new WeakMap();\nfunction withUndoStep(editor, fn) {\n  const current = CURRENT_UNDO_STEP.get(editor);\n  if (current) {\n    fn();\n    return;\n  }\n  CURRENT_UNDO_STEP.set(editor, current ?? {\n    undoStepId: defaultKeyGenerator()\n  }), fn(), CURRENT_UNDO_STEP.set(editor, void 0);\n}\nfunction getCurrentUndoStepId(editor) {\n  return CURRENT_UNDO_STEP.get(editor)?.undoStepId;\n}\nconst debug$f = debugWithName(\"plugin:withUndoRedo\"), SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const {\n    editorActor\n  } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name);\n    const remotePatches = getRemotePatches(editor);\n    let previousUndoStepId = getCurrentUndoStepId(editor);\n    options.subscriptions.push(() => {\n      debug$f(\"Subscribing to patches\");\n      const sub = editorActor.on(\"patches\", ({\n        patches,\n        snapshot\n      }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$f(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                undos: [],\n                redos: []\n              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({\n              patch,\n              time: /* @__PURE__ */ new Date(),\n              snapshot,\n              previousSnapshot\n            });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$f(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = {\n      undos: [],\n      redos: []\n    };\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      const {\n        operations,\n        history\n      } = editor, {\n        undos\n      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor), currentUndoStepId = getCurrentUndoStepId(editor);\n      let merge = currentUndoStepId !== void 0 && previousUndoStepId === void 0 ? !1 : currentUndoStepId !== void 0 && previousUndoStepId !== void 0 ? currentUndoStepId === previousUndoStepId : !0;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = currentUndoStepId === void 0 && previousUndoStepId === void 0 ? shouldMerge(op, lastOp) || overwrite : merge) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$f(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      previousUndoStepId = currentUndoStepId, apply2(op);\n    }, editor;\n  };\n}\nconst historyUndoOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor, {\n    undos\n  } = editor.history, remotePatches = getRemotePatches(editor);\n  if (undos.length > 0) {\n    const step = undos[undos.length - 1];\n    if (debug$f(\"Undoing\", step), step.operations.length > 0) {\n      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n      let transformedOperations = step.operations;\n      otherPatches.forEach((item) => {\n        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n      });\n      const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_20__.Operation.inverse).reverse();\n      try {\n        slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(editor, () => {\n          withUndoing(editor, () => {\n            withoutSaving(editor, () => {\n              reversedOperations.forEach((op) => {\n                editor.apply(op);\n              });\n            });\n          });\n        });\n      } catch (err) {\n        debug$f(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(editor), editor.history = {\n          undos: [],\n          redos: []\n        }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n        return;\n      }\n      editor.history.redos.push(step), editor.history.undos.pop();\n    }\n  }\n}, historyRedoOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor, {\n    redos\n  } = editor.history, remotePatches = getRemotePatches(editor);\n  if (redos.length > 0) {\n    const step = redos[redos.length - 1];\n    if (debug$f(\"Redoing\", step), step.operations.length > 0) {\n      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n      let transformedOperations = step.operations;\n      otherPatches.forEach((item) => {\n        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n      });\n      try {\n        slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(editor, () => {\n          withRedoing(editor, () => {\n            withoutSaving(editor, () => {\n              transformedOperations.forEach((op) => {\n                editor.apply(op);\n              });\n            });\n          });\n        });\n      } catch (err) {\n        debug$f(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(editor), editor.history = {\n          undos: [],\n          redos: []\n        }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n        return;\n      }\n      editor.history.undos.push(step), editor.history.redos.pop();\n    }\n  }\n};\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n      _key: blk._key\n    }, patch.path[0]));\n    return debug$f(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n      _key: blk._key\n    }, patch.path[0]));\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$f(\"Skipping transformation that targeted removed block\"), []) : [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$f(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__({\n      _key: operationTargetBlock._key\n    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const {\n        diffs\n      } = diffPatch;\n      if (diffs.forEach((diff2, index) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n          ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n          ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n          ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n          ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = transformedOperation.properties?.focus ? {\n      ...transformedOperation.properties.focus\n    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n      ...transformedOperation.properties.anchor\n    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n      ...transformedOperation.newProperties.focus\n    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n      ...transformedOperation.newProperties.anchor\n    } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_20__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_20__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: {\n      ...editor.selection\n    },\n    newProperties: {\n      ...editor.selection\n    }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst addAnnotationOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const parsedAnnotation = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseAnnotation)({\n    annotation: {\n      _type: operation.annotation.name,\n      ...operation.annotation.value\n    },\n    context,\n    options: {\n      refreshKeys: !1,\n      validateFields: !0\n    }\n  });\n  if (!parsedAnnotation)\n    throw new Error(`Failed to parse annotation ${JSON.stringify(operation.annotation)}`);\n  const editor = operation.editor;\n  if (!editor.selection || slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(editor.selection))\n    return;\n  let paths, spanPath, markDefPath;\n  const markDefPaths = [], selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node),\n    reverse: slate__WEBPACK_IMPORTED_MODULE_20__.Range.isBackward(editor.selection)\n  });\n  let blockIndex = 0;\n  for (const [block, blockPath] of selectedBlocks) {\n    if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\")\n      continue;\n    const annotationKey = blockIndex === 0 ? parsedAnnotation._key : context.keyGenerator(), markDefs = block.markDefs ?? [];\n    markDefs.find((markDef) => markDef._type === parsedAnnotation._type && markDef._key === annotationKey) === void 0 && (slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n      markDefs: [...markDefs, {\n        ...parsedAnnotation,\n        _key: annotationKey\n      }]\n    }, {\n      at: blockPath\n    }), markDefPath = [{\n      _key: block._key\n    }, \"markDefs\", {\n      _key: annotationKey\n    }], slate__WEBPACK_IMPORTED_MODULE_20__.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {}, {\n      match: slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText,\n      split: !0\n    });\n    const children = slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, blockPath);\n    for (const [span, path] of children) {\n      if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_20__.Range.includes(editor.selection, path))\n        continue;\n      const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark) => markDefs.some((markDef) => markDef._key === mark && markDef._type === parsedAnnotation._type));\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n        marks: [...marks.filter((mark) => !existingSameTypeAnnotations.includes(mark)), annotationKey]\n      }, {\n        at: path\n      }), spanPath = [{\n        _key: block._key\n      }, \"children\", {\n        _key: span._key\n      }];\n    }\n    blockIndex++;\n  }\n  return markDefPath && spanPath && (paths = {\n    markDefPath,\n    markDefPaths,\n    spanPath\n  }), paths;\n}, removeAnnotationOperationImplementation = ({\n  operation\n}) => {\n  const editor = operation.editor;\n  if (editor.selection)\n    if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(editor.selection)) {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, editor.selection, {\n        depth: 1\n      });\n      if (!editor.isTextBlock(block))\n        return;\n      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === operation.annotation.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, editor.selection, {\n        depth: 2\n      });\n      if (!editor.isTextSpan(selectedChild))\n        return;\n      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));\n      if (!annotationToRemove)\n        return;\n      const previousSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, blockPath, {\n        reverse: !0\n      }))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_20__.Path.isBefore(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            previousSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      const nextSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, blockPath))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_20__.Path.isAfter(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            nextSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove)\n        }, {\n          at: childPath\n        });\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {}, {\n        match: (node) => editor.isTextSpan(node),\n        split: !0,\n        hanging: !0\n      });\n      const blocks = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      });\n      for (const [block, blockPath] of blocks) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, blockPath);\n        for (const [child, childPath] of children) {\n          if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_20__.Range.includes(editor.selection, childPath))\n            continue;\n          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== operation.annotation.name);\n          marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n            marks: marksWithoutAnnotation\n          }, {\n            at: childPath\n          });\n        }\n      }\n    }\n}, blockSetOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const location = toSlateRange({\n    anchor: {\n      path: operation.at,\n      offset: 0\n    },\n    focus: {\n      path: operation.at,\n      offset: 0\n    }\n  }, operation.editor);\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`);\n  const block = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(operation.editor, location, {\n    depth: 1\n  })?.[0];\n  if (!block)\n    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);\n  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(operation.editor)).at(0);\n  if (!parsedBlock)\n    throw new Error(`Unable to parse block at ${JSON.stringify(operation.at)}`);\n  const {\n    _type,\n    ...filteredProps\n  } = operation.props, updatedBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n    context,\n    block: {\n      ...parsedBlock,\n      ...filteredProps\n    },\n    options: {\n      refreshKeys: !1,\n      validateFields: !0\n    }\n  });\n  if (!updatedBlock)\n    throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`);\n  const slateBlock = toSlateValue([updatedBlock], {\n    schemaTypes: context.schema\n  })?.at(0);\n  if (!slateBlock)\n    throw new Error(\"Unable to convert block to Slate value\");\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(operation.editor, slateBlock, {\n    at: location\n  });\n}, blockUnsetOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const location = toSlateRange({\n    anchor: {\n      path: operation.at,\n      offset: 0\n    },\n    focus: {\n      path: operation.at,\n      offset: 0\n    }\n  }, operation.editor);\n  if (!location)\n    throw new Error(`Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`);\n  const block = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(operation.editor, location, {\n    depth: 1\n  })?.[0];\n  if (!block)\n    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);\n  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(operation.editor)).at(0);\n  if (!parsedBlock)\n    throw new Error(`Unable to parse block at ${JSON.stringify(operation.at)}`);\n  if ((0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(context, parsedBlock)) {\n    const propsToRemove = operation.props.filter((prop) => prop !== \"_type\"), updatedTextBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n      context,\n      block: lodash_omit_js__WEBPACK_IMPORTED_MODULE_11__(parsedBlock, propsToRemove),\n      options: {\n        refreshKeys: !1,\n        validateFields: !0\n      }\n    });\n    if (!updatedTextBlock)\n      throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`);\n    const propsToSet = {};\n    for (const prop of propsToRemove)\n      prop in updatedTextBlock ? propsToSet[prop] = updatedTextBlock[prop] : propsToSet[prop] = void 0;\n    slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(operation.editor, propsToSet, {\n      at: location\n    });\n    return;\n  }\n  const updatedBlockObject = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n    context,\n    block: lodash_omit_js__WEBPACK_IMPORTED_MODULE_11__(parsedBlock, operation.props.filter((prop) => prop !== \"_type\")),\n    options: {\n      refreshKeys: !1,\n      validateFields: !0\n    }\n  });\n  if (!updatedBlockObject)\n    throw new Error(`Unable to update block at ${JSON.stringify(operation.at)}`);\n  const {\n    _type,\n    _key,\n    ...props\n  } = updatedBlockObject;\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(operation.editor, {\n    _type,\n    _key,\n    value: props\n  }, {\n    at: location\n  });\n}, decoratorAddOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const editor = operation.editor, mark = operation.decorator, value = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), manualAnchor = operation.at?.anchor ? (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.blockOffsetToSpanSelectionPoint)({\n    context: {\n      ...context,\n      value\n    },\n    blockOffset: operation.at.anchor,\n    direction: \"backward\"\n  }) : void 0, manualFocus = operation.at?.focus ? (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.blockOffsetToSpanSelectionPoint)({\n    context: {\n      ...context,\n      value\n    },\n    blockOffset: operation.at.focus,\n    direction: \"forward\"\n  }) : void 0, manualSelection = manualAnchor && manualFocus ? {\n    anchor: manualAnchor,\n    focus: manualFocus\n  } : void 0, selection = manualSelection ? toSlateRange(manualSelection, operation.editor) ?? editor.selection : editor.selection;\n  if (!selection)\n    return;\n  const editorSelection = slateRangeToSelection({\n    schema: context.schema,\n    editor,\n    range: selection\n  }), anchorOffset = editorSelection ? (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.selectionPointToBlockOffset)({\n    context: {\n      ...context,\n      value\n    },\n    selectionPoint: editorSelection.anchor\n  }) : void 0, focusOffset = editorSelection ? (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.selectionPointToBlockOffset)({\n    context: {\n      ...context,\n      value\n    },\n    selectionPoint: editorSelection.focus\n  }) : void 0;\n  if (!anchorOffset || !focusOffset)\n    throw new Error(\"Unable to find anchor or focus offset\");\n  if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(selection)) {\n    slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {}, {\n      at: selection,\n      match: slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText,\n      split: !0,\n      hanging: !0\n    });\n    const newValue = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), newSelection = (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_32__.blockOffsetsToSelection)({\n      context: {\n        ...context,\n        value: newValue\n      },\n      offsets: {\n        anchor: anchorOffset,\n        focus: focusOffset\n      },\n      backward: editorSelection?.backward\n    }), trimmedSelection = (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getTrimmedSelection)({\n      context: {\n        activeDecorators: [],\n        converters: [],\n        keyGenerator: context.keyGenerator,\n        readOnly: !1,\n        schema: context.schema,\n        selection: newSelection,\n        value: newValue\n      }\n    });\n    if (!trimmedSelection)\n      throw new Error(\"Unable to find trimmed selection\");\n    const newRange = toSlateRange(trimmedSelection, editor);\n    if (!newRange)\n      throw new Error(\"Unable to find new selection\");\n    const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_20__.Range.isRange(newRange) ? [...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n      at: newRange,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(node)\n    })] : [];\n    for (const [node, path] of splitTextNodes) {\n      const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n        marks\n      }, {\n        at: path,\n        match: slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText,\n        split: !0,\n        hanging: !0\n      });\n    }\n  } else {\n    if (!Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n      at: selection,\n      match: (node) => editor.isTextSpan(node)\n    }))?.at(0))\n      return;\n    const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, selection, {\n      depth: 1\n    }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n    if (lonelyEmptySpan) {\n      const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n        marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator\n      }, {\n        at: blockPath,\n        match: (node) => editor.isTextSpan(node)\n      });\n    } else {\n      const existingMarks = {\n        ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {}\n      }.marks || [], marks = {\n        ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {},\n        marks: [...existingMarks, mark]\n      };\n      editor.marks = marks;\n    }\n  }\n  if (editor.selection) {\n    const selection2 = editor.selection;\n    editor.selection = {\n      ...selection2\n    };\n  }\n}, deleteOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const range = toSlateRange(operation.at, operation.editor);\n  if (!range)\n    throw new Error(`Failed to get Slate Range for selection ${JSON.stringify(operation.at)}`);\n  if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(range)) {\n    const [focusBlock] = getFocusBlock({\n      editor: {\n        ...operation.editor,\n        selection: range\n      }\n    }), [focusChild] = getFocusChild({\n      editor: {\n        ...operation.editor,\n        selection: range\n      }\n    });\n    if (focusBlock && focusBlock._type === context.schema.block.name && focusChild && focusChild._type === context.schema.span.name)\n      return;\n  }\n  operation.editor.delete({\n    at: range\n  });\n}, deleteBackwardOperationImplementation = ({\n  operation\n}) => {\n  (0,slate__WEBPACK_IMPORTED_MODULE_20__.deleteBackward)(operation.editor, operation.unit);\n}, deleteBlockOperationImplementation = ({\n  operation\n}) => {\n  const range = toSlateRange({\n    anchor: {\n      path: operation.at,\n      offset: 0\n    },\n    focus: {\n      path: operation.at,\n      offset: 0\n    }\n  }, operation.editor);\n  if (!range) {\n    console.error(\"Unable to find Slate range from selection points\");\n    return;\n  }\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(operation.editor, {\n    at: range\n  });\n}, deleteForwardOperationImplementation = ({\n  operation\n}) => {\n  (0,slate__WEBPACK_IMPORTED_MODULE_20__.deleteForward)(operation.editor, operation.unit);\n}, insertInlineObjectOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const parsedInlineObject = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseInlineObject)({\n    context,\n    inlineObject: {\n      _type: operation.inlineObject.name,\n      ...operation.inlineObject.value ?? {}\n    },\n    options: {\n      refreshKeys: !1,\n      validateFields: !0\n    }\n  });\n  if (!parsedInlineObject)\n    throw new Error(`Failed to parse inline object ${JSON.stringify(operation.inlineObject)}`);\n  if (!operation.editor.selection) {\n    console.error(\"Unable to insert inline object without selection\");\n    return;\n  }\n  const [focusTextBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(operation.editor, {\n    at: operation.editor.selection.focus.path,\n    match: (node) => operation.editor.isTextBlock(node)\n  })).at(0) ?? [void 0, void 0];\n  if (!focusTextBlock) {\n    console.error(\"Unable to perform action without focus text block\");\n    return;\n  }\n  const child = toSlateValue([{\n    _type: context.schema.block.name,\n    _key: context.keyGenerator(),\n    children: [parsedInlineObject]\n  }], {\n    schemaTypes: context.schema\n  }).at(0)?.children.at(0);\n  if (!child) {\n    console.error(\"Unable to insert inline object\");\n    return;\n  }\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(operation.editor, child);\n}, insertSpanOperationImplementation = ({\n  context,\n  operation\n}) => {\n  if (!operation.editor.selection) {\n    console.error(\"Unable to perform action without selection\", operation);\n    return;\n  }\n  const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(operation.editor, {\n    at: operation.editor.selection.focus.path,\n    match: (node) => operation.editor.isTextBlock(node)\n  }))[0] ?? [void 0, void 0];\n  if (!focusBlock || !focusBlockPath) {\n    console.error(\"Unable to perform action without focus block\", operation);\n    return;\n  }\n  const markDefs = focusBlock.markDefs ?? [], annotations = operation.annotations ? operation.annotations.map((annotation) => ({\n    _type: annotation.name,\n    _key: context.keyGenerator(),\n    ...annotation.value\n  })) : void 0;\n  annotations && annotations.length > 0 && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(operation.editor, {\n    markDefs: [...markDefs, ...annotations]\n  }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(operation.editor, {\n    _type: \"span\",\n    _key: context.keyGenerator(),\n    text: operation.text,\n    marks: [...annotations?.map((annotation) => annotation._key) ?? [], ...operation.decorators ?? []]\n  });\n}, insertBlockOperationImplementation = ({\n  context,\n  operation\n}) => {\n  const parsedBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n    block: operation.block,\n    context,\n    options: {\n      refreshKeys: !1,\n      validateFields: !0\n    }\n  });\n  if (!parsedBlock)\n    throw new Error(`Failed to parse block ${JSON.stringify(operation.block)}`);\n  const fragment = toSlateValue([parsedBlock], {\n    schemaTypes: context.schema\n  })[0];\n  if (!fragment)\n    throw new Error(`Failed to convert block to Slate fragment ${JSON.stringify(parsedBlock)}`);\n  insertBlock({\n    block: fragment,\n    placement: operation.placement,\n    select: operation.select ?? \"start\",\n    editor: operation.editor,\n    schema: context.schema\n  });\n};\nfunction insertBlock({\n  block,\n  placement,\n  select,\n  editor,\n  schema\n}) {\n  const [startBlock, startBlockPath] = getSelectionStartBlock({\n    editor\n  }), [endBlock, endBlockPath] = getSelectionEndBlock({\n    editor\n  });\n  if (!editor.selection || !startBlock || !startBlockPath || !endBlock || !endBlockPath) {\n    select !== \"none\" && slate_dom__WEBPACK_IMPORTED_MODULE_22__.DOMEditor.focus(editor);\n    const [lastBlock, lastBlockPath] = getLastBlock({\n      editor\n    });\n    if (placement === \"before\")\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n        at: [0]\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, [0])) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, [0]));\n    else if (placement === \"after\") {\n      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0];\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n        at: nextPath,\n        select: !1\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, nextPath));\n    } else {\n      if (lastBlock && isEqualToEmptyEditor([lastBlock], schema)) {\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n          at: lastBlockPath\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n          at: lastBlockPath,\n          select: !1\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(editor), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, lastBlockPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, lastBlockPath));\n        return;\n      }\n      if (editor.isTextBlock(block) && lastBlock && editor.isTextBlock(lastBlock)) {\n        const selectionBefore = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, lastBlockPath);\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n          at: slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, lastBlockPath)\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, selectionBefore) : select === \"none\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(editor);\n        return;\n      }\n      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0];\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n        at: nextPath,\n        select: !1\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, nextPath));\n    }\n  } else if (placement === \"before\") {\n    const currentSelection = editor.selection, selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Range.start(currentSelection);\n    slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n      at: [selectionStartPoint.path[0]],\n      select: !1\n    }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, [selectionStartPoint.path[0]])) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, [selectionStartPoint.path[0]]));\n  } else if (placement === \"after\") {\n    const currentSelection = editor.selection, nextPath = [slate__WEBPACK_IMPORTED_MODULE_20__.Range.end(currentSelection).path[0] + 1];\n    slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n      at: nextPath,\n      select: !1\n    }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, nextPath));\n  } else {\n    const currentSelection = editor.selection, endBlockEndPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, endBlockPath);\n    if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(currentSelection) && !editor.isTextBlock(block)) {\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.delete(editor, {\n        at: currentSelection\n      });\n      const newSelection = editor.selection, [focusBlock, focusBlockPath] = getFocusBlock({\n        editor\n      });\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n        voids: !0\n      });\n      const adjustedSelection = newSelection.anchor.offset === 0 ? slate__WEBPACK_IMPORTED_MODULE_20__.Range.transform(newSelection, {\n        type: \"insert_node\",\n        node: block,\n        path: [newSelection.anchor.path[0]]\n      }) : newSelection;\n      select === \"none\" && adjustedSelection && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, adjustedSelection), focusBlock && isEqualToEmptyEditor([focusBlock], schema) && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n        at: focusBlockPath\n      });\n      return;\n    }\n    if (editor.isTextBlock(endBlock) && editor.isTextBlock(block)) {\n      const selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Range.start(currentSelection);\n      if (select === \"end\") {\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n          voids: !0\n        });\n        return;\n      }\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n        at: currentSelection,\n        voids: !0\n      }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, selectionStartPoint) : slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionStartPoint, endBlockEndPoint) || slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, selectionStartPoint);\n    } else if (editor.isTextBlock(endBlock)) {\n      const endBlockStartPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, endBlockPath), endBlockEndPoint2 = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, endBlockPath), selectionStartPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Range.start(currentSelection), selectionEndPoint = slate__WEBPACK_IMPORTED_MODULE_20__.Range.end(currentSelection);\n      if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionStartPoint, endBlockStartPoint))\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n          at: endBlockPath,\n          select: !1\n        }), (select === \"start\" || select === \"end\") && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, endBlockPath)), isEqualToEmptyEditor([endBlock], schema) && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n          at: slate__WEBPACK_IMPORTED_MODULE_20__.Path.next(endBlockPath)\n        });\n      else if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionEndPoint, endBlockEndPoint2)) {\n        const nextPath = [endBlockPath[0] + 1];\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n          at: nextPath,\n          select: !1\n        }), (select === \"start\" || select === \"end\") && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, nextPath));\n      } else if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionStartPoint, endBlockStartPoint) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionEndPoint, endBlockEndPoint2))\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n          at: currentSelection\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, endBlockPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, endBlockPath));\n      else if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionStartPoint, endBlockStartPoint))\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n          at: currentSelection\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, endBlockPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, endBlockPath));\n      else if (slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(currentSelection) && slate__WEBPACK_IMPORTED_MODULE_20__.Point.equals(selectionEndPoint, endBlockEndPoint2))\n        slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n          at: currentSelection\n        }), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Path.next(endBlockPath))) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Path.next(endBlockPath)));\n      else {\n        const currentSelection2 = editor.selection, [focusChild] = getFocusChild({\n          editor\n        });\n        if (focusChild && editor.isTextSpan(focusChild))\n          slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertFragment(editor, [block], {\n            at: currentSelection2\n          }), select === \"start\" || select === \"end\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, [endBlockPath[0] + 1]) : slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, currentSelection2);\n        else {\n          const nextPath = [endBlockPath[0] + 1];\n          slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n            at: nextPath,\n            select: !1\n          }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, currentSelection2), select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, nextPath));\n        }\n      }\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, [block], {\n        select: !1\n      });\n      const nextPath = [endBlockPath[0] + 1];\n      select === \"start\" ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(editor, nextPath)) : select === \"end\" && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.end(editor, nextPath));\n    }\n  }\n}\nconst moveBackwardOperationImplementation = ({\n  operation\n}) => {\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.move(operation.editor, {\n    unit: \"character\",\n    distance: operation.distance,\n    reverse: !0\n  });\n}, moveBlockOperationImplementation = ({\n  operation\n}) => {\n  const at = [toSlatePath(operation.at, operation.editor)[0]], to = [toSlatePath(operation.to, operation.editor)[0]];\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.moveNodes(operation.editor, {\n    at,\n    to,\n    mode: \"highest\"\n  });\n}, moveForwardOperationImplementation = ({\n  operation\n}) => {\n  slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.move(operation.editor, {\n    unit: \"character\",\n    distance: operation.distance\n  });\n}, selectOperationImplementation = ({\n  operation\n}) => {\n  const newSelection = toSlateRange(operation.at, operation.editor);\n  newSelection ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(operation.editor, newSelection) : slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(operation.editor);\n}, behaviorOperationImplementations = {\n  \"annotation.add\": addAnnotationOperationImplementation,\n  \"annotation.remove\": removeAnnotationOperationImplementation,\n  \"block.set\": blockSetOperationImplementation,\n  \"block.unset\": blockUnsetOperationImplementation,\n  \"decorator.add\": decoratorAddOperationImplementation,\n  \"decorator.remove\": removeDecoratorOperationImplementation,\n  delete: deleteOperationImplementation,\n  \"delete.backward\": deleteBackwardOperationImplementation,\n  \"delete.forward\": deleteForwardOperationImplementation,\n  \"delete.block\": deleteBlockOperationImplementation,\n  \"history.redo\": historyRedoOperationImplementation,\n  \"history.undo\": historyUndoOperationImplementation,\n  \"insert.block\": insertBlockOperationImplementation,\n  \"insert.inline object\": insertInlineObjectOperationImplementation,\n  \"insert.span\": insertSpanOperationImplementation,\n  \"insert.text\": insertTextOperationImplementation,\n  \"move.backward\": moveBackwardOperationImplementation,\n  \"move.block\": moveBlockOperationImplementation,\n  \"move.forward\": moveForwardOperationImplementation,\n  select: selectOperationImplementation\n};\nfunction performOperation({\n  context,\n  operation\n}) {\n  try {\n    switch (operation.type) {\n      case \"annotation.add\": {\n        behaviorOperationImplementations[\"annotation.add\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"annotation.remove\": {\n        behaviorOperationImplementations[\"annotation.remove\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"block.set\": {\n        behaviorOperationImplementations[\"block.set\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"block.unset\": {\n        behaviorOperationImplementations[\"block.unset\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"decorator.add\": {\n        behaviorOperationImplementations[\"decorator.add\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"decorator.remove\": {\n        behaviorOperationImplementations[\"decorator.remove\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"delete\": {\n        behaviorOperationImplementations.delete({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"delete.backward\": {\n        behaviorOperationImplementations[\"delete.backward\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"delete.block\": {\n        behaviorOperationImplementations[\"delete.block\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"delete.forward\": {\n        behaviorOperationImplementations[\"delete.forward\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"history.redo\": {\n        behaviorOperationImplementations[\"history.redo\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"history.undo\": {\n        behaviorOperationImplementations[\"history.undo\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"insert.block\": {\n        behaviorOperationImplementations[\"insert.block\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"insert.inline object\": {\n        behaviorOperationImplementations[\"insert.inline object\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"insert.span\": {\n        behaviorOperationImplementations[\"insert.span\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"insert.text\": {\n        behaviorOperationImplementations[\"insert.text\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"move.backward\": {\n        behaviorOperationImplementations[\"move.backward\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"move.block\": {\n        behaviorOperationImplementations[\"move.block\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      case \"move.forward\": {\n        behaviorOperationImplementations[\"move.forward\"]({\n          context,\n          operation\n        });\n        break;\n      }\n      default: {\n        behaviorOperationImplementations.select({\n          context,\n          operation\n        });\n        break;\n      }\n    }\n  } catch (error) {\n    console.error(new Error(`Executing \"${operation.type}\" failed due to: ${error.message}`));\n  }\n}\nconst CURRENT_OPERATION_ID = /* @__PURE__ */ new WeakMap();\nfunction withApplyingBehaviorOperations(editor, fn) {\n  CURRENT_OPERATION_ID.set(editor, defaultKeyGenerator()), slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(editor, fn), CURRENT_OPERATION_ID.set(editor, void 0);\n}\nfunction getCurrentOperationId(editor) {\n  return CURRENT_OPERATION_ID.get(editor);\n}\nfunction isApplyingBehaviorOperations(editor) {\n  return getCurrentOperationId(editor) !== void 0;\n}\nfunction createWithEventListeners(editorActor) {\n  return function(editor) {\n    if (editorActor.getSnapshot().context.maxBlocks !== void 0)\n      return editor;\n    const {\n      insertText,\n      select\n    } = editor;\n    return editor.deleteBackward = (unit) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error(\"Unexpected call to .deleteBackward(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.backward\",\n          unit\n        },\n        editor\n      });\n    }, editor.deleteForward = (unit) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error(\"Unexpected call to .deleteForward(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.forward\",\n          unit\n        },\n        editor\n      });\n    }, editor.insertBreak = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error(\"Unexpected call to .insertBreak(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.break\"\n        },\n        editor\n      });\n    }, editor.insertData = (dataTransfer) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        console.error(\"Unexpected call to .insertData(...)\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"input.*\",\n          originEvent: {\n            dataTransfer\n          }\n        },\n        editor\n      });\n    }, editor.insertSoftBreak = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        insertTextOperationImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            text: `\n`,\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.soft break\"\n        },\n        editor\n      });\n    }, editor.insertText = (text, options) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        insertText(text, options);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.text\",\n          text\n        },\n        editor\n      });\n    }, editor.redo = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            type: \"history.redo\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.redo\"\n        },\n        editor\n      });\n    }, editor.select = (location) => {\n      if (isApplyingBehaviorOperations(editor)) {\n        select(location);\n        return;\n      }\n      const range = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.range(editor, location);\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"select\",\n          at: slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor,\n            range\n          })\n        },\n        editor\n      });\n    }, editor.setFragmentData = () => {\n      console.error(\"Unexpected call to .setFragmentData(...)\");\n    }, editor.undo = () => {\n      if (isApplyingBehaviorOperations(editor)) {\n        performOperation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: editorActor.getSnapshot().context.schema\n          },\n          operation: {\n            type: \"history.undo\",\n            editor\n          }\n        });\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.undo\"\n        },\n        editor\n      });\n    }, editor;\n  };\n}\nfunction createWithMaxBlocks(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (operation) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(operation);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nfunction createWithObjectKeys(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (operation.type === \"split_node\") {\n        const existingKeys = [...slate__WEBPACK_IMPORTED_MODULE_20__.Node.descendants(editor)].map(([node]) => node._key);\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: operation.properties._key === void 0 || existingKeys.includes(operation.properties._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.properties._key\n          }\n        });\n        return;\n      }\n      if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isEditor(operation.node)) {\n        const existingKeys = [...slate__WEBPACK_IMPORTED_MODULE_20__.Node.descendants(editor)].map(([node]) => node._key);\n        apply2({\n          ...operation,\n          node: {\n            ...operation.node,\n            _key: operation.node._key === void 0 || existingKeys.includes(operation.node._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.node._key\n          }\n        });\n        return;\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(node) && node._type === editorActor.getSnapshot().context.schema.block.name) {\n        if (!node._key) {\n          editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, path))\n          if (!child._key) {\n            editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n              _key: editorActor.getSnapshot().context.keyGenerator()\n            }, {\n              at: childPath\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$e = debugWithName(\"applyPatches\"), debugVerbose = debug$e.enabled && !0;\nfunction createApplyPatch(schema) {\n  return (editor, patch) => {\n    let changed = !1;\n    debugVerbose && (debug$e(`\n\nNEW PATCH =============================================================`), debug$e(JSON.stringify(patch, null, 2)));\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schema);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n        default:\n          debug$e(\"Unhandled patch\", patch.type);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const {\n    block,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$e(\"Block not found\"), !1;\n  if (!child || !childPath)\n    return debug$e(\"Child not found\"), !1;\n  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(child))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.text, {\n    allowExceedingIndices: !0\n  }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n  debugState(editor, \"before\");\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({\n      type: \"insert_text\",\n      path: childPath,\n      offset,\n      text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset,\n      text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n  return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schema) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!targetBlock || !targetBlockPath)\n    return debug$e(\"Block not found\"), !1;\n  if (patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$e(\"Ignoring patch targeting void value\"), !1;\n  if (patch.path.length === 1) {\n    const {\n      items: items2,\n      position: position2\n    } = patch, blocksToInsert = toSlateValue(items2, {\n      schemaTypes: schema\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n    debug$e(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\");\n    const editorWasEmptyBefore = isEqualToEmptyEditor(editor.children, schema);\n    return slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, blocksToInsert, {\n      at: [normalizedIdx2]\n    }), editorWasEmptyBefore && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n      at: [position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex]\n    }), debugState(editor, \"after\"), !0;\n  }\n  const {\n    items,\n    position\n  } = patch;\n  if (!targetChild || !targetChildPath)\n    return debug$e(\"Child not found\"), !1;\n  const childrenToInsert = targetBlock && toSlateValue([{\n    ...targetBlock,\n    children: items\n  }], {\n    schemaTypes: schema\n  }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];\n  return debug$e(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n    at: childInsertPath\n  }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$e(\"Block not found\"), !1;\n  const isTextBlock2 = editor.isTextBlock(block);\n  if (isTextBlock2 && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$e(\"Ignoring setting void value\"), !1;\n  if (debugState(editor, \"before\"), isTextBlock2 && child && childPath) {\n    if (slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(child)) {\n      const newText = child.text;\n      value.text !== newText && (debug$e(\"Setting text property\"), editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset: 0,\n        text: newText\n      }), editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset: 0,\n        text: value.text\n      }), editor.onChange());\n    } else\n      debug$e(\"Setting non-text property\"), editor.apply({\n        type: \"set_node\",\n        path: childPath,\n        properties: {},\n        newProperties: value\n      });\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug$e(\"Setting block property\");\n    const {\n      children,\n      ...nextRest\n    } = value, {\n      children: prevChildren,\n      ...prevRest\n    } = block || {\n      children: void 0\n    };\n    editor.apply({\n      type: \"set_node\",\n      path: blockPath,\n      properties: {\n        ...prevRest\n      },\n      newProperties: nextRest\n    }), debug$e(\"Setting children\"), block.children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c2\n      });\n    }), Array.isArray(children) && children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: blockPath.concat(cIndex),\n        node: c2\n      });\n    });\n  } else if (block && \"value\" in block)\n    if (patch.path.length > 1 && patch.path[1] !== \"children\") {\n      const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.applyAll)(block.value, [{\n        ...patch,\n        path: patch.path.slice(1)\n      }]);\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n        ...block,\n        value: newVal\n      }, {\n        at: blockPath\n      });\n    } else\n      return !1;\n  return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch) {\n  if (patch.path.length === 0) {\n    debug$e(\"Removing everything\"), debugState(editor, \"before\");\n    const previousSelection = editor.selection;\n    slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(editor);\n    const children = slate__WEBPACK_IMPORTED_MODULE_20__.Node.children(editor, [], {\n      reverse: !0\n    });\n    for (const [_, path] of children)\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n        at: path\n      });\n    return slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n      decorators: []\n    })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), editor.onChange(), debugState(editor, \"after\"), !0;\n  }\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (patch.path.length === 1) {\n    if (!block || !blockPath)\n      return debug$e(\"Block not found\"), !1;\n    const blockIndex = blockPath[0];\n    return debug$e(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n      at: [blockIndex]\n    }), debugState(editor, \"after\"), !0;\n  }\n  return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$e(\"Child not found\"), !1) : (debug$e(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose && debug$e(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n    at: childPath\n  }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n  debugVerbose && (debug$e(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$e(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n  let blockIndex = -1;\n  const block = editor.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];\n    return isMatch && (blockIndex = index), isMatch;\n  });\n  return block ? {\n    block,\n    path: [blockIndex]\n  } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n  const {\n    block,\n    path: blockPath\n  } = findBlockFromPath(editor, path);\n  if (!(slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(block) && path[1] === \"children\"))\n    return {\n      block,\n      blockPath,\n      child: void 0,\n      childPath: void 0\n    };\n  let childIndex = -1;\n  const child = block.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];\n    return isMatch && (childIndex = index), isMatch;\n  });\n  return child ? {\n    block,\n    child,\n    blockPath,\n    childPath: blockPath?.concat(childIndex)\n  } : {\n    block,\n    blockPath,\n    child: void 0,\n    childPath: void 0\n  };\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nconst debug$d = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  editorActor,\n  patchFunctions,\n  subscriptions\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(editorActor.getSnapshot().context.schema);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const {\n      apply: apply2\n    } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              for (const patch of patches) {\n                debug$d.enabled && debug$d(`Handling remote patch ${JSON.stringify(patch)}`);\n                try {\n                  changed = applyPatch(editor, patch);\n                } catch (error) {\n                  console.error(`Applying patch ${JSON.stringify(patch)} failed due to: ${error.message}`);\n                }\n              }\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({\n      patches\n    }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return subscriptions.push(() => {\n      debug$d(\"Subscribing to remote patches\");\n      const sub = editorActor.on(\"patches\", handlePatches);\n      return () => {\n        debug$d(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, editorActor.getSnapshot().context.schema);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, editorActor.getSnapshot().context.schema);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_text\":\n          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_node\":\n          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"split_node\":\n          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"insert_node\":\n          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"set_node\":\n          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"merge_node\":\n          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"move_node\":\n          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];\n          break;\n      }\n      if (!editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([])], editorActor.send({\n        type: \"notify.unset\",\n        previousValue: fromSlateValue(previousChildren, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.setIfMissing)([], []), ...patches]), patches.length > 0)\n        for (const patch of patches)\n          editorActor.send({\n            type: \"internal.patch\",\n            patch: {\n              ...patch,\n              origin: \"local\"\n            },\n            operationId: getCurrentOperationId(editor),\n            value: fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n          });\n      return editor;\n    }, editor;\n  };\n}\nconst debug$c = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"remove_node\") {\n        const node = op.node;\n        if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isVoid(editor, node)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_20__.Path.next(op.path);\n          editor.children[nextPath[0]] || (debug$c(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_20__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n            decorators: []\n          })));\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$b = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(editorActor) {\n  const defaultStyle = editorActor.getSnapshot().context.schema.styles[0].name;\n  return function(editor) {\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry;\n      for (const op of editor.operations)\n        if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_20__.Path.equals(path, op.path)) {\n          const [child] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, [op.path[0] + 1, 0]);\n          if (slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(child) && child.text === \"\") {\n            debug$b(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n              style: defaultStyle\n            }, {\n              at: [op.path[0] + 1],\n              voids: !1\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      normalizeNode(nodeEntry);\n    }, editor;\n  };\n}\ndebugWithName(\"plugin:withPortableTextSelections\");\nfunction createWithPortableTextSelections(editorActor) {\n  let prevSelection = null;\n  return function(editor) {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          existing ? ptRange = existing : (ptRange = slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor,\n            range: editor.selection\n          }), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange));\n        }\n        ptRange ? editorActor.send({\n          type: \"notify.selection\",\n          selection: ptRange\n        }) : editorActor.send({\n          type: \"notify.selection\",\n          selection: null\n        });\n      }\n      prevSelection = editor.selection;\n    }, {\n      onChange\n    } = editor;\n    return editor.onChange = () => {\n      onChange(), editorActor.getSnapshot().matches({\n        setup: \"setting up\"\n      }) || emitPortableTextSelection();\n    }, editor;\n  };\n}\nconst debug$a = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  editorActor\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(editorActor.getSnapshot().context, value), editor.isTextSpan = (value) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isSpan$1)(editorActor.getSnapshot().context, value), editor.isListBlock = (value) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isListBlock)(editorActor.getSnapshot().context, value), editor.isVoid = (element) => editorActor.getSnapshot().context.schema.block.name !== element._type && (editorActor.getSnapshot().context.schema.blockObjects.map((obj) => obj.name).includes(element._type) || editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$a(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          ...span,\n          _type: editorActor.getSnapshot().context.schema.span.name,\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$a(\"Setting missing key on child node without a key\");\n        const key = editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(editor, {\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nfunction createWithUtils({\n  editorActor\n}) {\n  return function(editor) {\n    return editor.pteCreateTextBlock = (options) => toSlateValue([{\n      _type: editorActor.getSnapshot().context.schema.block.name,\n      _key: editorActor.getSnapshot().context.keyGenerator(),\n      style: editorActor.getSnapshot().context.schema.styles[0].name || \"normal\",\n      ...options.listItem ? {\n        listItem: options.listItem\n      } : {},\n      ...options.level ? {\n        level: options.level\n      } : {},\n      markDefs: [],\n      children: [{\n        _type: \"span\",\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        text: \"\",\n        marks: options.decorators.filter((decorator) => editorActor.getSnapshot().context.schema.decorators.find(({\n          name\n        }) => name === decorator))\n      }]\n    }], {\n      schemaTypes: editorActor.getSnapshot().context.schema\n    })[0], editor;\n  };\n}\nconst withPlugins = (editor, options) => {\n  const e = editor, {\n    editorActor\n  } = options, operationToPatches = createOperationToPatches(editorActor), withObjectKeys = createWithObjectKeys(editorActor), withSchemaTypes = createWithSchemaTypes({\n    editorActor\n  }), withPatches = createWithPatches({\n    editorActor,\n    patchFunctions: operationToPatches,\n    subscriptions: options.subscriptions\n  }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({\n    editorActor,\n    subscriptions: options.subscriptions\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({\n    editorActor\n  }), withPortableTextSelections = createWithPortableTextSelections(editorActor);\n  return createWithEventListeners(editorActor)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e)))))))))));\n}, debug$9 = debugWithName(\"setup\");\nfunction createSlateEditor(config) {\n  debug$9(\"Creating new Slate editor instance\");\n  const instance = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_26__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_20__.createEditor)()), {\n    editorActor: config.editorActor,\n    subscriptions: config.subscriptions\n  });\n  KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {});\n  const initialValue = [instance.pteCreateTextBlock({\n    decorators: []\n  })];\n  return {\n    instance,\n    initialValue\n  };\n}\nconst addAnnotationOnCollapsedSelection = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"annotation.add\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const caretWordSelection = (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getCaretWordSelection)(snapshot);\n    return !caretWordSelection || !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionExpanded)({\n      context: {\n        ...snapshot.context,\n        selection: caretWordSelection\n      }\n    }) ? !1 : {\n      caretWordSelection\n    };\n  },\n  actions: [({\n    event\n  }, {\n    caretWordSelection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: caretWordSelection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"annotation.add\",\n    annotation: event.annotation\n  })]]\n}), coreAnnotationBehaviors = {\n  addAnnotationOnCollapsedSelection\n}, IS_MAC = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {\n  alt: \"altKey\",\n  control: \"ctrlKey\",\n  meta: \"metaKey\",\n  shift: \"shiftKey\"\n}, aliases = {\n  add: \"+\",\n  break: \"pause\",\n  cmd: \"meta\",\n  command: \"meta\",\n  ctl: \"control\",\n  ctrl: \"control\",\n  del: \"delete\",\n  down: \"arrowdown\",\n  esc: \"escape\",\n  ins: \"insert\",\n  left: \"arrowleft\",\n  mod: IS_MAC ? \"meta\" : \"control\",\n  opt: \"alt\",\n  option: \"alt\",\n  return: \"enter\",\n  right: \"arrowright\",\n  space: \" \",\n  spacebar: \" \",\n  up: \"arrowup\",\n  win: \"meta\",\n  windows: \"meta\"\n}, keyCodes = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  \" \": 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  \";\": 186,\n  \"=\": 187,\n  \",\": 188,\n  \"-\": 189,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"[\": 219,\n  \"\\\\\": 220,\n  \"]\": 221,\n  \"'\": 222,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  f13: 124,\n  f14: 125,\n  f15: 126,\n  f16: 127,\n  f17: 128,\n  f18: 129,\n  f19: 130,\n  f20: 131\n};\nfunction isHotkey(hotkey, event) {\n  return compareHotkey(parseHotkey(hotkey), event);\n}\nfunction parseHotkey(hotkey) {\n  const parsedHotkey = {\n    altKey: !1,\n    ctrlKey: !1,\n    metaKey: !1,\n    shiftKey: !1\n  }, hotkeySegments = hotkey.replace(\"++\", \"+add\").split(\"+\");\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional = rawHotkeySegment.endsWith(\"?\") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];\n    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`);\n    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);\n  }\n  return parsedHotkey;\n}\nfunction compareHotkey(parsedHotkey, event) {\n  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;\n}\nfunction toKeyCode(name) {\n  const keyName = toKeyName(name);\n  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);\n}\nfunction toKeyName(name) {\n  const keyName = name.toLowerCase();\n  return aliases[keyName] ?? keyName;\n}\nconst arrowDownOnLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!isHotkey(\"ArrowDown\", event.originEvent) || !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlockObject)(snapshot), nextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getNextBlock)(snapshot);\n    return focusBlockObject && !nextBlock;\n  },\n  actions: [({\n    snapshot\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"after\"\n  })]]\n}), arrowUpOnLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!isHotkey(\"ArrowUp\", event.originEvent) || !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlockObject)(snapshot), previousBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getPreviousBlock)(snapshot);\n    return focusBlockObject && !previousBlock;\n  },\n  actions: [({\n    snapshot\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"before\"\n  })]]\n}), breakingBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusBlockObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlockObject)(snapshot);\n    return (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot) && focusBlockObject !== void 0;\n  },\n  actions: [({\n    snapshot\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"after\"\n  })]]\n}), clickingAboveLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"mouse.click\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (snapshot.context.readOnly || snapshot.context.selection && !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlockObject)({\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    }), previousBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getPreviousBlock)({\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    });\n    return event.position.isEditor && event.position.block === \"start\" && focusBlockObject && !previousBlock;\n  },\n  actions: [({\n    snapshot,\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: event.position.selection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"before\",\n    select: \"start\"\n  })]]\n}), clickingBelowLonelyBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"mouse.click\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (snapshot.context.readOnly || snapshot.context.selection && !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot))\n      return !1;\n    const focusBlockObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlockObject)({\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    }), nextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getNextBlock)({\n      context: {\n        ...snapshot.context,\n        selection: event.position.selection\n      }\n    });\n    return event.position.isEditor && event.position.block === \"end\" && focusBlockObject && !nextBlock;\n  },\n  actions: [({\n    snapshot,\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: event.position.selection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name\n    },\n    placement: \"after\",\n    select: \"start\"\n  })]]\n}), deletingEmptyTextBlockAfterBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot), previousBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getPreviousBlock)(snapshot);\n    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node) && !(0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, previousBlock.node) ? {\n      focusTextBlock,\n      previousBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: {\n      anchor: {\n        path: previousBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: previousBlock.path,\n        offset: 0\n      }\n    }\n  })]]\n}), deletingEmptyTextBlockBeforeBlockObject = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"delete.forward\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot), nextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getNextBlock)(snapshot);\n    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node) && !(0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, nextBlock.node) ? {\n      focusTextBlock,\n      nextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"delete.block\",\n    at: focusTextBlock.path\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: {\n      anchor: {\n        path: nextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: nextBlock.path,\n        offset: 0\n      }\n    }\n  })]]\n}), coreBlockObjectBehaviors = {\n  arrowDownOnLonelyBlockObject,\n  arrowUpOnLonelyBlockObject,\n  breakingBlockObject,\n  clickingAboveLonelyBlockObject,\n  clickingBelowLonelyBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject\n}, coreDecoratorBehaviors = {\n  strongShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+b\", event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"strong\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"strong\"\n    })]]\n  }),\n  emShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+i\", event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"em\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"em\"\n    })]]\n  }),\n  underlineShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+u\", event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"underline\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"underline\"\n    })]]\n  }),\n  codeShortcut: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      snapshot,\n      event\n    }) => isHotkey(\"mod+'\", event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === \"code\"),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"decorator.toggle\",\n      decorator: \"code\"\n    })]]\n  })\n}, coreDndBehaviors = [\n  /**\n   * When dragging over the drag origin, we don't want to show the caret in the\n   * text.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"drag.dragover\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const dragOrigin = snapshot.beta.internalDrag?.origin;\n      return dragOrigin ? (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isOverlappingSelection)(event.position.selection)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      }) : !1;\n    },\n    actions: []\n  })\n], breakingAtTheEndOfTextBlock = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot);\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)\n      return !1;\n    const atTheEndOfBlock = (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isAtTheEndOfBlock)(focusTextBlock)(snapshot), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;\n    return atTheEndOfBlock ? {\n      focusListItem,\n      focusLevel\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    focusListItem,\n    focusLevel\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }],\n      markDefs: [],\n      listItem: focusListItem,\n      level: focusLevel,\n      style: snapshot.context.schema.styles[0]?.name\n    },\n    placement: \"after\"\n  })]]\n}), breakingAtTheStartOfTextBlock = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot);\n    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)\n      return !1;\n    const focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusSpan)(snapshot), focusDecorators = focusSpan?.node.marks?.filter((mark) => snapshot.context.schema.decorators.some((decorator) => decorator.name === mark) ?? []), focusAnnotations = focusSpan?.node.marks?.filter((mark) => !snapshot.context.schema.decorators.some((decorator) => decorator.name === mark)) ?? [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;\n    return (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isAtTheStartOfBlock)(focusTextBlock)(snapshot) ? {\n      focusAnnotations,\n      focusDecorators,\n      focusListItem,\n      focusLevel\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    focusAnnotations,\n    focusDecorators,\n    focusListItem,\n    focusLevel\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        marks: focusAnnotations.length === 0 ? focusDecorators : [],\n        text: \"\"\n      }],\n      listItem: focusListItem,\n      level: focusLevel,\n      style: snapshot.context.schema.styles[0]?.name\n    },\n    placement: \"before\",\n    select: \"none\"\n  })]]\n}), breakingEntireDocument = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!snapshot.context.selection || !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionExpanded)(snapshot))\n      return !1;\n    const firstBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFirstBlock)(snapshot), lastBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getLastBlock)(snapshot);\n    if (!firstBlock || !lastBlock)\n      return !1;\n    const firstBlockStartPoint = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: firstBlock\n    }), selectionStartPoint = (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionStartPoint)(snapshot.context.selection), lastBlockEndPoint = (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: lastBlock\n    }), selectionEndPoint = (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionEndPoint)(snapshot.context.selection);\n    return (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEqualSelectionPoints)(firstBlockStartPoint, selectionStartPoint) && (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEqualSelectionPoints)(lastBlockEndPoint, selectionEndPoint) ? {\n      selection: snapshot.context.selection\n    } : !1;\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"delete\",\n    at: selection\n  })]]\n}), breakingEntireBlocks = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!snapshot.context.selection || !(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionExpanded)(snapshot))\n      return !1;\n    const selectedBlocks = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectedBlocks)(snapshot), selectionStartBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectionStartBlock)(snapshot), selectionEndBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectionEndBlock)(snapshot);\n    if (!selectionStartBlock || !selectionEndBlock)\n      return !1;\n    const startBlockStartPoint = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: selectionStartBlock\n    }), selectionStartPoint = (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionStartPoint)(snapshot.context.selection), endBlockEndPoint = (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: selectionEndBlock\n    }), selectionEndPoint = (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionEndPoint)(snapshot.context.selection);\n    return (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEqualSelectionPoints)(selectionStartPoint, startBlockStartPoint) && (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEqualSelectionPoints)(selectionEndPoint, endBlockEndPoint) ? {\n      selectedBlocks\n    } : !1;\n  },\n  actions: [({\n    snapshot\n  }, {\n    selectedBlocks\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: {\n      _type: snapshot.context.schema.block.name,\n      children: [{\n        _type: snapshot.context.schema.span.name,\n        text: \"\",\n        marks: []\n      }]\n    },\n    placement: \"before\",\n    select: \"start\"\n  }), ...selectedBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"delete.block\",\n    at: block.path\n  }))]]\n}), coreInsertBreakBehaviors = {\n  breakingAtTheEndOfTextBlock,\n  breakingAtTheStartOfTextBlock,\n  breakingEntireDocument,\n  breakingEntireBlocks\n}, MAX_LIST_LEVEL = 10, clearListOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusSpan)(snapshot);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {\n      focusTextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusTextBlock.path\n  })]]\n}), unindentListOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"delete.backward\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusSpan)(snapshot);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n      focusTextBlock,\n      level: focusTextBlock.node.level - 1\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    level\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.set\",\n    props: {\n      level\n    },\n    at: focusTextBlock.path\n  })]]\n}), clearListOnEnter = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  guard: ({\n    snapshot\n  }) => {\n    const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot), focusListBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusListBlock)(snapshot);\n    return !selectionCollapsed || !focusListBlock || !(0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEmptyTextBlock)(snapshot.context, focusListBlock.node) ? !1 : {\n      focusListBlock\n    };\n  },\n  actions: [(_, {\n    focusListBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusListBlock.path\n  })]]\n}), indentListOnTab = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!isHotkey(\"Tab\", event.originEvent))\n      return !1;\n    const selectedBlocks = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectedBlocks)(snapshot), selectedListBlocks = selectedBlocks.flatMap((block) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isListBlock)(snapshot.context, block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.set\",\n    props: {\n      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1))\n    },\n    at: selectedListBlock.path\n  }))]\n}), unindentListOnShiftTab = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"keyboard.keydown\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (!isHotkey(\"Shift+Tab\", event.originEvent))\n      return !1;\n    const selectedBlocks = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectedBlocks)(snapshot), selectedListBlocks = selectedBlocks.flatMap((block) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isListBlock)(snapshot.context, block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.set\",\n    props: {\n      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1))\n    },\n    at: selectedListBlock.path\n  }))]\n}), coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace,\n  clearListOnEnter,\n  indentListOnTab,\n  unindentListOnShiftTab\n}, coreBehaviorsConfig = [coreAnnotationBehaviors.addAnnotationOnCollapsedSelection, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, ...coreDndBehaviors, coreBlockObjectBehaviors.clickingAboveLonelyBlockObject, coreBlockObjectBehaviors.clickingBelowLonelyBlockObject, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab, coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock, coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock, coreInsertBreakBehaviors.breakingEntireDocument, coreInsertBreakBehaviors.breakingEntireBlocks].map((behavior) => ({\n  behavior,\n  priority: corePriority\n})), abstractAnnotationBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"annotation.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveAnnotation)(event.annotation.name)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"annotation.remove\",\n    annotation: event.annotation\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"annotation.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveAnnotation)(event.annotation.name)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"annotation.add\",\n    annotation: event.annotation\n  })]]\n})], abstractDecoratorBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"decorator.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveDecorator)(event.decorator)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"decorator.remove\",\n    decorator: event.decorator\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"decorator.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const manualSelection = event.at ? (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_32__.blockOffsetsToSelection)({\n      context: snapshot.context,\n      offsets: event.at\n    }) : null;\n    return manualSelection ? !(0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveDecorator)(event.decorator)({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: manualSelection\n      }\n    }) : !(0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveDecorator)(event.decorator)(snapshot);\n  },\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    ...event,\n    type: \"decorator.add\"\n  })]]\n})], abstractDeleteBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"delete.text\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const selection = (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_32__.blockOffsetsToSelection)({\n      context: snapshot.context,\n      offsets: event.at\n    });\n    if (!selection)\n      return !1;\n    const trimmedSelection = (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getTrimmedSelection)({\n      context: {\n        converters: [],\n        schema: snapshot.context.schema,\n        keyGenerator: snapshot.context.keyGenerator,\n        activeDecorators: [],\n        readOnly: !1,\n        value: snapshot.context.value,\n        selection\n      }\n    });\n    return trimmedSelection ? {\n      selection: trimmedSelection\n    } : !1;\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"delete\",\n    at: selection\n  })]]\n})], abstractInsertBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    event\n  }) => event.placement === \"before\",\n  actions: [({\n    event\n  }) => event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: index === 0 ? \"before\" : \"after\",\n    select: \"end\"\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    event\n  }) => event.placement === \"after\",\n  actions: [({\n    event\n  }) => event.blocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"after\",\n    select: \"end\"\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (event.placement !== \"auto\")\n      return !1;\n    const focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot);\n    return focusTextBlock ? {\n      focusTextBlock\n    } : !1;\n  },\n  actions: [({\n    snapshot,\n    event\n  }, {\n    focusTextBlock\n  }) => event.blocks.length === 1 ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: event.blocks[0],\n    placement: \"auto\",\n    select: \"end\"\n  })] : (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.isEmptyTextBlock)(snapshot.context, focusTextBlock.node) ? event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: index === 0 ? \"auto\" : \"after\",\n    select: \"end\"\n  })) : event.blocks.flatMap((block, index) => index === 0 ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"split\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select.previous block\",\n    select: \"end\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"auto\",\n    select: \"end\"\n  })] : index === event.blocks.length - 1 ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select.next block\",\n    select: \"start\"\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"auto\",\n    select: \"end\"\n  })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: \"after\",\n    select: \"end\"\n  })])]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.blocks\",\n  guard: ({\n    event\n  }) => event.placement === \"auto\",\n  actions: [({\n    event\n  }) => event.blocks.map((block, index) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block,\n    placement: index === 0 ? \"auto\" : \"after\",\n    select: \"end\"\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.break\",\n  actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"split\"\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"insert.soft break\",\n  actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.text\",\n    text: `\n`\n  })]]\n})], keyIs = {\n  lineBreak: (event) => event.key === \"Enter\" && event.shiftKey\n}, abstractKeyboardBehaviors = [\n  /**\n   * On WebKit, Shift+Enter results in an `insertParagraph` input event rather\n   * than an `insertLineBreak` input event. This Behavior makes sure we catch\n   * that `keyboard.keydown` event beforehand and raise an `insert.soft break` manually.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"keyboard.keydown\",\n    guard: ({\n      event\n    }) => keyIs.lineBreak(event.originEvent),\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"insert.soft break\"\n    })]]\n  })\n], abstractListItemBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"list item.add\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [({\n    event\n  }, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.set\",\n    at: block.path,\n    props: {\n      level: 1,\n      listItem: event.listItem\n    }\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"list item.remove\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [(_, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.unset\",\n    at: block.path,\n    props: [\"level\", \"listItem\"]\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"list item.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveListItem)(event.listItem)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"list item.remove\",\n    listItem: event.listItem\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"list item.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveListItem)(event.listItem)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"list item.add\",\n    listItem: event.listItem\n  })]]\n})], abstractMoveBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"move.block up\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const previousBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getPreviousBlock)({\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: event.at,\n            offset: 0\n          },\n          focus: {\n            path: event.at,\n            offset: 0\n          }\n        }\n      }\n    });\n    return previousBlock ? {\n      previousBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    previousBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"move.block\",\n    at: event.at,\n    to: previousBlock.path\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"move.block down\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const nextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getNextBlock)({\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: event.at,\n            offset: 0\n          },\n          focus: {\n            path: event.at,\n            offset: 0\n          }\n        }\n      }\n    });\n    return nextBlock ? {\n      nextBlock\n    } : !1;\n  },\n  actions: [({\n    event\n  }, {\n    nextBlock\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"move.block\",\n    at: event.at,\n    to: nextBlock.path\n  })]]\n})], abstractSelectBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"select.previous block\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const previousBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getPreviousBlock)(snapshot);\n    if (!previousBlock)\n      return !1;\n    const point = event.select === \"end\" ? (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: previousBlock\n    }) : (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: previousBlock\n    });\n    return {\n      selection: {\n        anchor: point,\n        focus: point\n      }\n    };\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: selection\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"select.next block\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    const nextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getNextBlock)(snapshot);\n    if (!nextBlock)\n      return !1;\n    const point = event.select === \"end\" ? (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n      context: snapshot.context,\n      block: nextBlock\n    }) : (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getBlockStartPoint)({\n      context: snapshot.context,\n      block: nextBlock\n    });\n    return {\n      selection: {\n        anchor: point,\n        focus: point\n      }\n    };\n  },\n  actions: [(_, {\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"select\",\n    at: selection\n  })]]\n})], abstractSplitBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"split\",\n  guard: ({\n    snapshot\n  }) => {\n    if (!snapshot.context.selection)\n      return !1;\n    const selectionStartPoint = (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionStartPoint)(snapshot.context.selection), selectionEndPoint = (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionEndPoint)(snapshot.context.selection), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)({\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionEndPoint\n        }\n      }\n    });\n    if (focusTextBlock) {\n      const blockEndPoint = (0,_chunks_es_util_is_equal_selection_points_js__WEBPACK_IMPORTED_MODULE_19__.getBlockEndPoint)({\n        context: snapshot.context,\n        block: focusTextBlock\n      }), newTextBlockSelection = {\n        anchor: selectionEndPoint,\n        focus: blockEndPoint\n      }, newTextBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n        block: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.sliceBlocks)({\n          context: {\n            ...snapshot.context,\n            selection: newTextBlockSelection\n          },\n          blocks: [focusTextBlock.node]\n        }).at(0),\n        context: snapshot.context,\n        options: {\n          refreshKeys: !0,\n          validateFields: !0\n        }\n      });\n      return !newTextBlock || !(0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, newTextBlock) ? !1 : {\n        newTextBlock,\n        newTextBlockSelection,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: blockEndPoint\n        }\n      };\n    }\n    if ((0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusBlockObject)({\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionEndPoint\n        }\n      }\n    })) {\n      const newTextBlock = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlock)({\n        block: {\n          _type: snapshot.context.schema.block.name,\n          children: []\n        },\n        context: snapshot.context,\n        options: {\n          refreshKeys: !0,\n          validateFields: !0\n        }\n      });\n      return newTextBlock ? {\n        newTextBlock,\n        newTextBlockSelection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint\n        },\n        selection: snapshot.context.selection\n      } : !1;\n    }\n    return !1;\n  },\n  actions: [(_, {\n    newTextBlock,\n    selection\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"delete\",\n    at: selection\n  }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"insert.block\",\n    block: newTextBlock,\n    placement: \"after\",\n    select: \"start\"\n  })]]\n})], abstractStyleBehaviors = [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"style.add\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [({\n    event\n  }, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.set\",\n    at: block.path,\n    props: {\n      style: event.style\n    }\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"style.remove\",\n  guard: ({\n    snapshot\n  }) => ({\n    selectedTextBlocks: (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getSelectedTextBlocks)(snapshot)\n  }),\n  actions: [(_, {\n    selectedTextBlocks\n  }) => selectedTextBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"block.unset\",\n    at: block.path,\n    props: [\"style\"]\n  }))]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"style.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveStyle)(event.style)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"style.remove\",\n    style: event.style\n  })]]\n}), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"style.toggle\",\n  guard: ({\n    snapshot,\n    event\n  }) => !(0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isActiveStyle)(event.style)(snapshot),\n  actions: [({\n    event\n  }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    type: \"style.add\",\n    style: event.style\n  })]]\n})], raiseDeserializationSuccessOrFailure = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"deserialize\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    let success;\n    const failures = [];\n    for (const converter of snapshot.context.converters) {\n      const data = event.originEvent.originEvent.dataTransfer.getData(converter.mimeType);\n      if (!data)\n        continue;\n      const deserializeEvent = converter.deserialize({\n        snapshot,\n        event: {\n          type: \"deserialize\",\n          data\n        }\n      });\n      if (deserializeEvent.type === \"deserialization.success\") {\n        success = deserializeEvent;\n        break;\n      } else\n        failures.push(deserializeEvent);\n    }\n    return success || {\n      type: \"deserialization.failure\",\n      mimeType: \"*/*\",\n      reason: failures.map((failure) => failure.reason).join(\", \")\n    };\n  },\n  actions: [({\n    event\n  }, deserializeEvent) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    ...deserializeEvent,\n    originEvent: event.originEvent\n  })]]\n}), raiseSerializationSuccessOrFailure = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n  on: \"serialize\",\n  guard: ({\n    snapshot,\n    event\n  }) => {\n    if (snapshot.context.converters.length === 0)\n      return !1;\n    const serializeEvents = snapshot.context.converters.map((converter) => converter.serialize({\n      snapshot,\n      event: {\n        ...event,\n        originEvent: event.originEvent.type\n      }\n    }));\n    return serializeEvents.length === 0 ? !1 : serializeEvents;\n  },\n  actions: [({\n    event\n  }, serializeEvents) => serializeEvents.map((serializeEvent) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n    ...serializeEvent,\n    originEvent: event.originEvent\n  }))]\n}), abstractBehaviors = [\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"clipboard.copy\",\n    guard: ({\n      snapshot\n    }) => {\n      const focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusSpan)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot);\n      return focusSpan && selectionCollapsed;\n    },\n    actions: []\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"clipboard.copy\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"serialize\",\n      originEvent: event\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"clipboard.cut\",\n    guard: ({\n      snapshot\n    }) => {\n      const focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusSpan)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionCollapsed)(snapshot);\n      return focusSpan && selectionCollapsed;\n    },\n    actions: []\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"clipboard.cut\",\n    guard: ({\n      snapshot\n    }) => snapshot.context.selection ? {\n      selection: snapshot.context.selection\n    } : !1,\n    actions: [({\n      event\n    }, {\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"serialize\",\n      originEvent: event\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"delete\",\n      at: selection\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"drag.dragstart\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"serialize\",\n      originEvent: event\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"serialization.success\",\n    actions: [({\n      event\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        event.originEvent.originEvent.dataTransfer.setData(event.mimeType, event.data);\n      }\n    }]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"serialization.failure\",\n    actions: [({\n      event\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        console.warn(`Serialization of ${event.mimeType} failed with reason \"${event.reason}\"`);\n      }\n    }]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"drag.drop\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const dragOrigin = snapshot.beta.internalDrag?.origin, dropPosition = event.position.selection;\n      return dragOrigin ? (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isOverlappingSelection)(dropPosition)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      }) : !1;\n    },\n    actions: []\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"drag.drop\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"select\",\n      at: event.position.selection\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"deserialize\",\n      originEvent: event\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"deserialization.success\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.originEvent.type !== \"drag.drop\" || snapshot.beta.internalDrag === void 0)\n        return !1;\n      const dragOrigin = snapshot.beta.internalDrag.origin, dropPosition = event.originEvent.position.selection, droppingOnDragOrigin = dragOrigin ? (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isOverlappingSelection)(dropPosition)({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      }) : !1, draggingEntireBlocks = (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isSelectingEntireBlocks)({\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      }), draggedBlocks = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getSelectedBlocks)({\n        context: {\n          ...snapshot.context,\n          selection: dragOrigin.selection\n        }\n      });\n      return droppingOnDragOrigin ? !1 : {\n        draggingEntireBlocks,\n        draggedBlocks,\n        dragOrigin,\n        originEvent: event.originEvent\n      };\n    },\n    actions: [({\n      event\n    }, {\n      draggingEntireBlocks,\n      draggedBlocks,\n      dragOrigin,\n      originEvent\n    }) => [...draggingEntireBlocks ? draggedBlocks.map((block) => (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"delete.block\",\n      at: block.path\n    })) : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"delete\",\n      at: dragOrigin.selection\n    })], (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"insert.blocks\",\n      blocks: event.data,\n      placement: draggingEntireBlocks ? originEvent.position.block === \"start\" ? \"before\" : originEvent.position.block === \"end\" ? \"after\" : \"auto\" : \"auto\"\n    })]]\n  }),\n  /**\n   * If we are pasting text/plain into a text block then we can probably\n   * assume that the intended behavior is that the pasted text inherits\n   * formatting from the text it's pasted into.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"deserialization.success\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if ((0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.getFocusTextBlock)(snapshot) && event.mimeType === \"text/plain\" && event.originEvent.type === \"clipboard.paste\") {\n        const activeDecorators = snapshot.context.activeDecorators;\n        return {\n          activeAnnotations: (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.getActiveAnnotations)(snapshot),\n          activeDecorators,\n          textRuns: event.data.flatMap((block) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)(snapshot.context, block) ? [(0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.getTextBlockText)(block)] : [])\n        };\n      }\n      return !1;\n    },\n    actions: [(_, {\n      activeAnnotations,\n      activeDecorators,\n      textRuns\n    }) => textRuns.flatMap((textRun, index) => index !== textRuns.length - 1 ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"insert.span\",\n      text: textRun,\n      decorators: activeDecorators,\n      annotations: activeAnnotations.map(({\n        _key,\n        _type,\n        ...value\n      }) => ({\n        name: _type,\n        value\n      }))\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"insert.break\"\n    })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"insert.span\",\n      text: textRun,\n      decorators: activeDecorators,\n      annotations: activeAnnotations.map(({\n        _key,\n        _type,\n        ...value\n      }) => ({\n        name: _type,\n        value\n      }))\n    })])]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"deserialization.success\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"insert.blocks\",\n      blocks: event.data,\n      placement: \"auto\"\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"deserialization.failure\",\n    actions: [({\n      event\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        console.warn(`Deserialization of ${event.mimeType} failed with reason \"${event.reason}\"`);\n      }\n    }]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"clipboard.paste\",\n    guard: ({\n      snapshot\n    }) => snapshot.context.selection && (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_17__.isSelectionExpanded)(snapshot) ? {\n      selection: snapshot.context.selection\n    } : !1,\n    actions: [({\n      event\n    }, {\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"delete\",\n      at: selection\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"deserialize\",\n      originEvent: event\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"clipboard.paste\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"deserialize\",\n      originEvent: event\n    })]]\n  }),\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.defineBehavior)({\n    on: \"input.*\",\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_25__.raise)({\n      type: \"deserialize\",\n      originEvent: event\n    })]]\n  }),\n  ...abstractAnnotationBehaviors,\n  ...abstractDecoratorBehaviors,\n  ...abstractDeleteBehaviors,\n  ...abstractInsertBehaviors,\n  ...abstractKeyboardBehaviors,\n  ...abstractListItemBehaviors,\n  ...abstractMoveBehaviors,\n  ...abstractStyleBehaviors,\n  ...abstractSelectBehaviors,\n  ...abstractSplitBehaviors,\n  raiseDeserializationSuccessOrFailure,\n  raiseSerializationSuccessOrFailure\n];\nfunction isSyntheticBehaviorEvent(event) {\n  return !isCustomBehaviorEvent(event) && !isNativeBehaviorEvent(event) && !isAbstractBehaviorEvent(event);\n}\nconst abstractBehaviorEventTypes = [\"annotation.toggle\", \"decorator.toggle\", \"delete.text\", \"deserialize\", \"deserialization.success\", \"deserialization.failure\", \"insert.blocks\", \"insert.break\", \"insert.soft break\", \"list item.add\", \"list item.remove\", \"list item.toggle\", \"move.block down\", \"move.block up\", \"select.previous block\", \"select.next block\", \"serialize\", \"serialization.success\", \"serialization.failure\", \"split\", \"style.add\", \"style.remove\", \"style.toggle\"];\nfunction isAbstractBehaviorEvent(event) {\n  return abstractBehaviorEventTypes.includes(event.type);\n}\nconst nativeBehaviorEventTypes = [\"clipboard.copy\", \"clipboard.cut\", \"clipboard.paste\", \"drag.dragstart\", \"drag.drag\", \"drag.dragend\", \"drag.dragenter\", \"drag.dragover\", \"drag.dragleave\", \"drag.drop\", \"input.*\", \"keyboard.keydown\", \"keyboard.keyup\", \"mouse.click\"];\nfunction isNativeBehaviorEvent(event) {\n  return nativeBehaviorEventTypes.includes(event.type);\n}\nfunction isCustomBehaviorEvent(event) {\n  return event.type.startsWith(\"custom.\");\n}\nconst debug$8 = debugWithName(\"behaviors:event\");\nfunction eventCategory(event) {\n  return isNativeBehaviorEvent(event) ? \"native\" : isAbstractBehaviorEvent(event) ? \"synthetic\" : isCustomBehaviorEvent(event) ? \"custom\" : \"synthetic\";\n}\nfunction performEvent({\n  mode,\n  behaviors,\n  remainingEventBehaviors,\n  event,\n  editor,\n  keyGenerator,\n  schema,\n  getSnapshot,\n  nativeEvent\n}) {\n  debug$8(`(${mode}:${eventCategory(event)})`, JSON.stringify(event, null, 2));\n  const eventBehaviors = [...remainingEventBehaviors, ...abstractBehaviors].filter((behavior) => {\n    if (behavior.on === \"*\")\n      return !0;\n    const [listenedNamespace] = behavior.on.includes(\"*\") && behavior.on.includes(\".\") ? behavior.on.split(\".\") : [void 0], [eventNamespace] = event.type.includes(\".\") ? event.type.split(\".\") : [void 0];\n    return listenedNamespace !== void 0 && eventNamespace !== void 0 && listenedNamespace === eventNamespace || listenedNamespace !== void 0 && eventNamespace === void 0 && listenedNamespace === event.type ? !0 : behavior.on === event.type;\n  });\n  if (eventBehaviors.length === 0 && isSyntheticBehaviorEvent(event)) {\n    nativeEvent?.preventDefault(), withApplyingBehaviorOperations(editor, () => {\n      debug$8(`(execute:${eventCategory(event)})`, JSON.stringify(event, null, 2)), performOperation({\n        context: {\n          keyGenerator,\n          schema\n        },\n        operation: {\n          ...event,\n          editor\n        }\n      });\n    }), editor.onChange();\n    return;\n  }\n  const guardSnapshot = getSnapshot();\n  let nativeEventPrevented = !1, defaultBehaviorOverwritten = !1, eventBehaviorIndex = -1;\n  for (const eventBehavior of eventBehaviors) {\n    eventBehaviorIndex++;\n    let shouldRun = !1;\n    try {\n      shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({\n        snapshot: guardSnapshot,\n        event\n      });\n    } catch (error) {\n      console.error(new Error(`Evaluating guard for \"${event.type}\" failed due to: ${error.message}`));\n    }\n    if (shouldRun) {\n      defaultBehaviorOverwritten = !0;\n      for (const actionSet of eventBehavior.actions) {\n        const actionsSnapshot = getSnapshot();\n        let actions = [];\n        try {\n          actions = actionSet({\n            snapshot: actionsSnapshot,\n            event\n          }, shouldRun);\n        } catch (error) {\n          console.error(new Error(`Evaluating actions for \"${event.type}\" failed due to: ${error.message}`));\n        }\n        if (actions.length !== 0) {\n          if (actions.some((action) => action.type === \"execute\")) {\n            withUndoStep(editor, () => {\n              for (const action of actions) {\n                if (action.type === \"effect\") {\n                  nativeEventPrevented = !0;\n                  try {\n                    action.effect();\n                  } catch (error) {\n                    console.error(new Error(`Executing effect as a result of \"${event.type}\" failed due to: ${error.message}`));\n                  }\n                  continue;\n                }\n                if (action.type === \"forward\") {\n                  const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);\n                  performEvent({\n                    mode: \"forward\",\n                    behaviors,\n                    remainingEventBehaviors: remainingEventBehaviors2,\n                    event: action.event,\n                    editor,\n                    keyGenerator,\n                    schema,\n                    getSnapshot,\n                    nativeEvent\n                  });\n                  continue;\n                }\n                if (action.type === \"raise\") {\n                  nativeEventPrevented = !0, performEvent({\n                    mode: \"raise\",\n                    behaviors,\n                    remainingEventBehaviors: behaviors,\n                    event: action.event,\n                    editor,\n                    keyGenerator,\n                    schema,\n                    getSnapshot,\n                    nativeEvent\n                  });\n                  continue;\n                }\n                nativeEventPrevented = !0, performEvent({\n                  mode: \"execute\",\n                  behaviors,\n                  remainingEventBehaviors: isAbstractBehaviorEvent(action.event) ? behaviors : [],\n                  event: action.event,\n                  editor,\n                  keyGenerator,\n                  schema,\n                  getSnapshot,\n                  nativeEvent: void 0\n                });\n              }\n            });\n            continue;\n          }\n          for (const action of actions) {\n            if (action.type === \"effect\") {\n              nativeEventPrevented = !0;\n              try {\n                action.effect();\n              } catch (error) {\n                console.error(new Error(`Executing effect as a result of \"${event.type}\" failed due to: ${error.message}`));\n              }\n              continue;\n            }\n            if (action.type === \"forward\") {\n              const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);\n              performEvent({\n                mode: \"forward\",\n                behaviors,\n                remainingEventBehaviors: remainingEventBehaviors2,\n                event: action.event,\n                editor,\n                keyGenerator,\n                schema,\n                getSnapshot,\n                nativeEvent\n              });\n              continue;\n            }\n            if (action.type === \"raise\") {\n              nativeEventPrevented = !0, performEvent({\n                mode: \"raise\",\n                behaviors,\n                remainingEventBehaviors: behaviors,\n                event: action.event,\n                editor,\n                keyGenerator,\n                schema,\n                getSnapshot,\n                nativeEvent\n              });\n              continue;\n            }\n            action.type === \"execute\" && console.error(\"Unexpected action type: `execute`\");\n          }\n        }\n      }\n      break;\n    }\n  }\n  !defaultBehaviorOverwritten && isSyntheticBehaviorEvent(event) ? (nativeEvent?.preventDefault(), withApplyingBehaviorOperations(editor, () => {\n    debug$8(`(execute:${eventCategory(event)})`, JSON.stringify(event, null, 2)), performOperation({\n      context: {\n        keyGenerator,\n        schema\n      },\n      operation: {\n        ...event,\n        editor\n      }\n    });\n  }), editor.onChange()) : nativeEventPrevented && nativeEvent?.preventDefault();\n}\nfunction sortByPriority(items) {\n  if (items.length === 0)\n    return [];\n  const itemsWithPriority = items.filter((item) => item.priority !== void 0), itemsWithoutPriority = items.filter((item) => item.priority === void 0);\n  if (itemsWithPriority.length === 0)\n    return items;\n  const itemsByPriorityId = new Map(itemsWithPriority.map((item) => [item.priority.id, item])), graph = /* @__PURE__ */ new Map(), inDegree = /* @__PURE__ */ new Map();\n  function ensureNode(id) {\n    graph.has(id) || (graph.set(id, /* @__PURE__ */ new Set()), inDegree.set(id, 0));\n  }\n  for (const item of itemsWithPriority) {\n    const id = item.priority.id;\n    ensureNode(id);\n  }\n  function addEdge(fromId, toId) {\n    !graph.has(fromId) || !graph.has(toId) || (graph.get(fromId)?.add(toId), inDegree.set(toId, (inDegree.get(toId) ?? 0) + 1));\n  }\n  for (const item of itemsWithPriority) {\n    const id = item.priority.id, visited = /* @__PURE__ */ new Set();\n    let ref = item.priority.reference;\n    for (; ref; ) {\n      const refId = ref.priority.id;\n      if (ensureNode(refId), visited.has(refId))\n        throw new Error(\"Circular dependency detected in priorities\");\n      visited.add(refId), ref.importance === \"higher\" ? addEdge(id, refId) : addEdge(refId, id), ref = ref.priority.reference;\n    }\n  }\n  const queue = [];\n  for (const [id, degree] of inDegree)\n    degree === 0 && queue.push(id);\n  const result = [];\n  for (; queue.length > 0; ) {\n    const currentId = queue.shift(), currentItem = itemsByPriorityId.get(currentId);\n    currentItem && result.push(currentItem);\n    for (const neighborId of graph.get(currentId) ?? []) {\n      const newDegree = (inDegree.get(neighborId) ?? 0) - 1;\n      inDegree.set(neighborId, newDegree), newDegree === 0 && queue.push(neighborId);\n    }\n  }\n  for (const item of itemsWithPriority)\n    result.includes(item) || result.push(item);\n  return [...result, ...itemsWithoutPriority];\n}\nfunction slateChildrenToBlocks(schema, value) {\n  const blocks = new Array(value.length);\n  for (let blockIndex = 0; blockIndex < value.length; blockIndex++) {\n    const descendant = value[blockIndex];\n    if (descendant._type !== schema.block.name) {\n      blocks[blockIndex] = {\n        _key: descendant._key,\n        _type: descendant._type,\n        ...\"value\" in descendant && typeof descendant.value == \"object\" ? descendant.value : {}\n      };\n      continue;\n    }\n    const children = \"children\" in descendant ? descendant.children : [], processedChildren = new Array(children.length);\n    for (let childIndex = 0; childIndex < children.length; childIndex++) {\n      const child = children[childIndex];\n      processedChildren[childIndex] = child._type === schema.span.name ? child : {\n        _key: child._key,\n        _type: child._type,\n        ...\"value\" in child && typeof child.value == \"object\" ? child.value : {}\n      };\n    }\n    blocks[blockIndex] = {\n      ...descendant,\n      children: processedChildren\n    };\n  }\n  return blocks;\n}\nfunction getActiveDecorators({\n  schema,\n  slateEditorInstance\n}) {\n  const decorators = schema.decorators.map((decorator) => decorator.name);\n  return ({\n    ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(slateEditorInstance) ?? {}\n  }.marks ?? []).filter((mark) => decorators.includes(mark));\n}\nfunction createEditorSnapshot({\n  converters,\n  editor,\n  keyGenerator,\n  readOnly,\n  schema,\n  hasTag,\n  internalDrag\n}) {\n  const value = slateChildrenToBlocks(schema, editor.children), selection = editor.selection ? slateRangeToSelection({\n    schema,\n    editor,\n    range: editor.selection\n  }) : null;\n  return {\n    context: {\n      activeDecorators: getActiveDecorators({\n        schema,\n        slateEditorInstance: editor\n      }),\n      converters,\n      keyGenerator,\n      readOnly,\n      schema,\n      selection,\n      value\n    },\n    beta: {\n      hasTag,\n      internalDrag\n    }\n  };\n}\nconst debug$7 = debugWithName(\"editor machine\"), editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_33__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {},\n    input: {},\n    tags: {}\n  },\n  actions: {\n    \"add behavior to context\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"add behavior\"), /* @__PURE__ */ new Set([...context.behaviors, event.behaviorConfig]))\n    }),\n    \"remove behavior from context\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"remove behavior\"), context.behaviors.delete(event.behaviorConfig), /* @__PURE__ */ new Set([...context.behaviors]))\n    }),\n    \"assign schema\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      schema: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"update schema\"), event.schema)\n    }),\n    \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.b)(({\n      event,\n      enqueue\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"internal.patch\"), enqueue.emit(event), enqueue.emit({\n        type: \"patch\",\n        patch: event.patch\n      });\n    }),\n    \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"mutation\"), event)),\n    \"emit read only\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n      type: \"read only\"\n    }),\n    \"emit editable\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n      type: \"editable\"\n    }),\n    \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingEvents: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, [\"internal.patch\", \"mutation\"]), [...context.pendingEvents, event])\n    }),\n    \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingEvents)\n        event.type === \"internal.patch\" ? (enqueue.emit(event), enqueue.emit({\n          type: \"patch\",\n          patch: event.patch\n        })) : enqueue.emit(event);\n    }),\n    \"emit ready\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n      type: \"ready\"\n    }),\n    \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingEvents: []\n    }),\n    \"defer incoming patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingIncomingPatchesEvents: ({\n        context,\n        event\n      }) => event.type === \"patches\" ? [...context.pendingIncomingPatchesEvents, event] : context.pendingIncomingPatchesEvents\n    }),\n    \"emit pending incoming patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingIncomingPatchesEvents)\n        enqueue.emit(event);\n    }),\n    \"clear pending incoming patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingIncomingPatchesEvents: []\n    }),\n    \"handle blur\": ({\n      event\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"blur\");\n      try {\n        slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.blur(event.editor);\n      } catch (error) {\n        console.error(new Error(`Failed to blur editor: ${error.message}`));\n      }\n    },\n    \"handle focus\": ({\n      context\n    }) => {\n      if (!context.slateEditor) {\n        console.error(\"No Slate editor found to focus\");\n        return;\n      }\n      try {\n        const currentSelection = context.slateEditor.selection;\n        slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.focus(context.slateEditor), currentSelection && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(context.slateEditor, currentSelection);\n      } catch (error) {\n        console.error(new Error(`Failed to focus editor: ${error.message}`));\n      }\n    },\n    \"handle behavior event\": ({\n      context,\n      event,\n      self\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, [\"behavior event\"]);\n      try {\n        const behaviors = sortByPriority([...context.behaviors.values(), ...coreBehaviorsConfig]).map((config) => config.behavior);\n        performEvent({\n          mode: \"raise\",\n          behaviors,\n          remainingEventBehaviors: behaviors,\n          event: event.behaviorEvent,\n          editor: event.editor,\n          keyGenerator: context.keyGenerator,\n          schema: context.schema,\n          getSnapshot: () => createEditorSnapshot({\n            converters: [...context.converters],\n            editor: event.editor,\n            keyGenerator: context.keyGenerator,\n            readOnly: self.getSnapshot().matches({\n              \"edit mode\": \"read only\"\n            }),\n            schema: context.schema,\n            hasTag: (tag) => self.getSnapshot().hasTag(tag),\n            internalDrag: context.internalDrag\n          }),\n          nativeEvent: event.nativeEvent\n        });\n      } catch (error) {\n        console.error(new Error(`Raising \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n      }\n    }\n  },\n  guards: {\n    \"slate is busy\": ({\n      context\n    }) => context.slateEditor ? context.slateEditor.operations.length > 0 : !1\n  }\n}).createMachine({\n  id: \"editor\",\n  context: ({\n    input\n  }) => ({\n    behaviors: /* @__PURE__ */ new Set([]),\n    converters: new Set(input.converters ?? []),\n    getLegacySchema: input.getLegacySchema,\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    pendingIncomingPatchesEvents: [],\n    schema: input.schema,\n    selection: null,\n    initialReadOnly: input.readOnly ?? !1,\n    maxBlocks: input.maxBlocks,\n    initialValue: input.initialValue\n  }),\n  on: {\n    \"notify.blurred\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"blurred\"\n      }))\n    },\n    \"notify.done loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n        type: \"done loading\"\n      })\n    },\n    \"notify.error\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"error\"\n      }))\n    },\n    \"notify.invalid value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"invalid value\"\n      }))\n    },\n    \"notify.focused\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"focused\"\n      }))\n    },\n    \"notify.selection\": {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n        selection: ({\n          event\n        }) => event.selection\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"selection\"\n      }))]\n    },\n    \"notify.unset\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"unset\"\n      }))\n    },\n    \"notify.loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n        type: \"loading\"\n      })\n    },\n    \"notify.value changed\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n        event\n      }) => ({\n        ...event,\n        type: \"value changed\"\n      }))\n    },\n    \"add behavior\": {\n      actions: \"add behavior to context\"\n    },\n    \"remove behavior\": {\n      actions: \"remove behavior from context\"\n    },\n    \"update key generator\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n        keyGenerator: ({\n          event\n        }) => event.keyGenerator\n      })\n    },\n    \"update schema\": {\n      actions: \"assign schema\"\n    },\n    \"update maxBlocks\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n        maxBlocks: ({\n          event\n        }) => event.maxBlocks\n      })\n    }\n  },\n  type: \"parallel\",\n  states: {\n    \"edit mode\": {\n      initial: \"read only\",\n      states: {\n        \"read only\": {\n          initial: \"determine initial edit mode\",\n          on: {\n            \"behavior event\": {\n              actions: \"handle behavior event\",\n              guard: ({\n                event\n              }) => event.behaviorEvent.type === \"clipboard.copy\" || event.behaviorEvent.type === \"mouse.click\" || event.behaviorEvent.type === \"serialize\" || event.behaviorEvent.type === \"serialization.failure\" || event.behaviorEvent.type === \"serialization.success\" || event.behaviorEvent.type === \"select\"\n            }\n          },\n          states: {\n            \"determine initial edit mode\": {\n              entry: [() => {\n                debug$7(\"entry: edit mode->read only->determine initial edit mode\");\n              }],\n              exit: [() => {\n                debug$7(\"exit: edit mode->read only->determine initial edit mode\");\n              }],\n              on: {\n                \"done syncing value\": [{\n                  target: \"#editor.edit mode.read only.read only\",\n                  guard: ({\n                    context\n                  }) => context.initialReadOnly\n                }, {\n                  target: \"#editor.edit mode.editable\"\n                }]\n              }\n            },\n            \"read only\": {\n              entry: [() => {\n                debug$7(\"entry: edit mode->read only->read only\");\n              }],\n              exit: [() => {\n                debug$7(\"exit: edit mode->read only->read only\");\n              }],\n              on: {\n                \"update readOnly\": {\n                  guard: ({\n                    event\n                  }) => !event.readOnly,\n                  target: \"#editor.edit mode.editable\",\n                  actions: [\"emit editable\"]\n                }\n              }\n            }\n          }\n        },\n        editable: {\n          on: {\n            \"update readOnly\": {\n              guard: ({\n                event\n              }) => event.readOnly,\n              target: \"#editor.edit mode.read only.read only\",\n              actions: [\"emit read only\"]\n            },\n            \"behavior event\": {\n              actions: \"handle behavior event\"\n            },\n            blur: {\n              actions: \"handle blur\"\n            },\n            focus: {\n              target: \".focusing\",\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n                slateEditor: ({\n                  event\n                }) => event.editor\n              })]\n            }\n          },\n          initial: \"idle\",\n          states: {\n            idle: {\n              entry: [() => {\n                debug$7(\"entry: edit mode->editable->idle\");\n              }],\n              exit: [() => {\n                debug$7(\"exit: edit mode->editable-idle\");\n              }],\n              on: {\n                dragstart: {\n                  actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n                    internalDrag: ({\n                      event\n                    }) => ({\n                      ghost: event.ghost,\n                      origin: event.origin\n                    })\n                  })],\n                  target: \"dragging internally\"\n                }\n              }\n            },\n            focusing: {\n              initial: \"checking if busy\",\n              states: {\n                \"checking if busy\": {\n                  entry: [() => {\n                    debug$7(\"entry: edit mode->editable->focusing->checking if busy\");\n                  }],\n                  exit: [() => {\n                    debug$7(\"exit: edit mode->editable->focusing->checking if busy\");\n                  }],\n                  always: [{\n                    guard: \"slate is busy\",\n                    target: \"busy\"\n                  }, {\n                    target: \"#editor.edit mode.editable.idle\",\n                    actions: [\"handle focus\"]\n                  }]\n                },\n                busy: {\n                  entry: [() => {\n                    debug$7(\"entry: edit mode->editable->focusing-busy\");\n                  }],\n                  exit: [() => {\n                    debug$7(\"exit: edit mode->editable->focusing->busy\");\n                  }],\n                  after: {\n                    10: {\n                      target: \"checking if busy\"\n                    }\n                  }\n                }\n              }\n            },\n            \"dragging internally\": {\n              entry: [() => {\n                debug$7(\"entry: edit mode->editable->dragging internally\");\n              }],\n              exit: [() => {\n                debug$7(\"exit: edit mode->editable->dragging internally\");\n              }, ({\n                context\n              }) => {\n                if (context.internalDrag?.ghost)\n                  try {\n                    context.internalDrag.ghost.parentNode?.removeChild(context.internalDrag.ghost);\n                  } catch (error) {\n                    console.error(new Error(`Removing the internal drag ghost failed due to: ${error.message}`));\n                  }\n              }, (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n                internalDrag: void 0\n              })],\n              tags: [\"dragging internally\"],\n              on: {\n                dragend: {\n                  target: \"idle\"\n                },\n                drop: {\n                  target: \"idle\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setup: {\n      initial: \"setting up\",\n      states: {\n        \"setting up\": {\n          entry: [() => {\n            debug$7(\"entry: setup->setting up\");\n          }],\n          exit: [() => {\n            debug$7(\"exit: setup->setting up\");\n          }, \"emit ready\", \"emit pending incoming patches\", \"clear pending incoming patches\"],\n          on: {\n            \"internal.patch\": {\n              actions: \"defer event\"\n            },\n            mutation: {\n              actions: \"defer event\"\n            },\n            \"done syncing value\": {\n              target: \"set up\"\n            },\n            patches: {\n              actions: [\"defer incoming patches\"]\n            }\n          }\n        },\n        \"set up\": {\n          type: \"parallel\",\n          states: {\n            \"value sync\": {\n              initial: \"idle\",\n              states: {\n                idle: {\n                  entry: [() => {\n                    debug$7(\"entry: setup->set up->value sync->idle\");\n                  }],\n                  exit: [() => {\n                    debug$7(\"exit: setup->set up->value sync->idle\");\n                  }],\n                  on: {\n                    patches: {\n                      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n                        event\n                      }) => event)]\n                    },\n                    \"syncing value\": {\n                      target: \"syncing value\"\n                    }\n                  }\n                },\n                \"syncing value\": {\n                  entry: [() => {\n                    debug$7(\"entry: setup->set up->value sync->syncing value\");\n                  }],\n                  exit: [() => {\n                    debug$7(\"exit: setup->set up->value sync->syncing value\");\n                  }, \"emit pending incoming patches\", \"clear pending incoming patches\"],\n                  on: {\n                    patches: {\n                      actions: [\"defer incoming patches\"]\n                    },\n                    \"done syncing value\": {\n                      target: \"idle\"\n                    }\n                  }\n                }\n              }\n            },\n            writing: {\n              initial: \"pristine\",\n              states: {\n                pristine: {\n                  initial: \"idle\",\n                  states: {\n                    idle: {\n                      entry: [() => {\n                        debug$7(\"entry: setup->set up->writing->pristine->idle\");\n                      }],\n                      exit: [() => {\n                        debug$7(\"exit: setup->set up->writing->pristine->idle\");\n                      }],\n                      on: {\n                        normalizing: {\n                          target: \"normalizing\"\n                        },\n                        \"internal.patch\": {\n                          actions: \"defer event\",\n                          target: \"#editor.setup.set up.writing.dirty\"\n                        },\n                        mutation: {\n                          actions: \"defer event\",\n                          target: \"#editor.setup.set up.writing.dirty\"\n                        }\n                      }\n                    },\n                    normalizing: {\n                      entry: [() => {\n                        debug$7(\"entry: setup->set up->writing->pristine->normalizing\");\n                      }],\n                      exit: [() => {\n                        debug$7(\"exit: setup->set up->writing->pristine->normalizing\");\n                      }],\n                      on: {\n                        \"done normalizing\": {\n                          target: \"idle\"\n                        },\n                        \"internal.patch\": {\n                          actions: \"defer event\"\n                        },\n                        mutation: {\n                          actions: \"defer event\"\n                        }\n                      }\n                    }\n                  }\n                },\n                dirty: {\n                  entry: [() => {\n                    debug$7(\"entry: setup->set up->writing->dirty\");\n                  }, \"emit pending events\", \"clear pending events\"],\n                  exit: [() => {\n                    debug$7(\"exit: setup->set up->writing->dirty\");\n                  }],\n                  on: {\n                    \"internal.patch\": {\n                      actions: \"emit patch event\"\n                    },\n                    mutation: {\n                      actions: \"emit mutation event\"\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n});\nfunction createLegacySchema(portableTextType) {\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = portableTextType.of?.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = blockType.fields?.find((field) => field.name === \"children\");\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\"Valid types for block children not found in schema (required)\");\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== \"span\") || [], blockObjectTypes = portableTextType.of?.filter((field) => field.name !== blockType.name) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields?.find((btField) => btField.name === \"style\");\n  if (!styleField)\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style) => style.value);\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\");\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields?.find((btField) => btField.name === \"listItem\");\n  if (!listField)\n    throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction defineSchema(definition) {\n  return definition;\n}\nconst temporaryImageName = `tmp-${defaultKeyGenerator()}-image`, temporaryUrlName = `tmp-${defaultKeyGenerator()}-url`, temporaryObjectNames = {\n  image: temporaryImageName,\n  url: temporaryUrlName\n}, objectNames = {\n  [temporaryImageName]: \"image\",\n  [temporaryUrlName]: \"url\"\n}, defaultObjectTitles = {\n  image: \"Image\",\n  url: \"URL\"\n};\nfunction legacySchemaToEditorSchema(schema) {\n  return {\n    annotations: schema.annotations.map((annotation) => ({\n      name: annotation.name,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType\n      })),\n      title: annotation.title\n    })),\n    block: {\n      name: schema.block.name\n    },\n    blockObjects: schema.blockObjects.map((blockObject) => ({\n      name: blockObject.name,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType\n      })),\n      title: blockObject.title\n    })),\n    decorators: schema.decorators.map((decorator) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value\n    })),\n    inlineObjects: schema.inlineObjects.map((inlineObject) => ({\n      name: inlineObject.name,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType\n      })),\n      title: inlineObject.title\n    })),\n    span: {\n      name: schema.span.name\n    },\n    styles: schema.styles.map((style) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value\n    })),\n    lists: schema.lists.map((list) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value\n    }))\n  };\n}\nfunction compileSchemaDefinitionToLegacySchema(definition) {\n  const blockObjects = definition?.blockObjects?.map((blockObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_23__.defineType)({\n    type: \"object\",\n    // Very naive way to work around `SanitySchema.compile` adding default\n    // fields to objects with certain names.\n    name: temporaryObjectNames[blockObject.name] ?? blockObject.name,\n    title: blockObject.title === void 0 ? (\n      // This avoids the default title which is a title case of the object name\n      defaultObjectTitles[blockObject.name]\n    ) : blockObject.title,\n    fields: blockObject.fields?.map((field) => ({\n      name: field.name,\n      type: field.type\n    })) ?? []\n  })) ?? [], inlineObjects = definition?.inlineObjects?.map((inlineObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_23__.defineType)({\n    type: \"object\",\n    // Very naive way to work around `SanitySchema.compile` adding default\n    // fields to objects with certain names.\n    name: temporaryObjectNames[inlineObject.name] ?? inlineObject.name,\n    title: inlineObject.title === void 0 ? (\n      // This avoids the default title which is a title case of the object name\n      defaultObjectTitles[inlineObject.name]\n    ) : inlineObject.title,\n    fields: inlineObject.fields?.map((field) => ({\n      name: field.name,\n      type: field.type\n    })) ?? []\n  })) ?? [], portableTextSchema = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_23__.defineField)({\n    type: \"array\",\n    name: \"portable-text\",\n    of: [...blockObjects.map((blockObject) => ({\n      type: blockObject.name\n    })), {\n      type: \"block\",\n      name: \"block\",\n      of: inlineObjects.map((inlineObject) => ({\n        type: inlineObject.name\n      })),\n      marks: {\n        decorators: definition?.decorators?.map((decorator) => ({\n          title: decorator.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_12__(decorator.name),\n          value: decorator.name\n        })) ?? [],\n        annotations: definition?.annotations?.map((annotation) => ({\n          name: annotation.name,\n          type: \"object\",\n          title: annotation.title,\n          fields: annotation.fields?.map((field) => ({\n            name: field.name,\n            type: field.type\n          })) ?? []\n        })) ?? []\n      },\n      lists: definition?.lists?.map((list) => ({\n        value: list.name,\n        title: list.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_12__(list.name)\n      })) ?? [],\n      styles: definition?.styles?.map((style) => ({\n        value: style.name,\n        title: style.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_12__(style.name)\n      })) ?? []\n    }]\n  }), schema = _sanity_schema__WEBPACK_IMPORTED_MODULE_28__.Schema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects]\n  }).get(\"portable-text\"), pteSchema = createLegacySchema(schema);\n  return {\n    ...pteSchema,\n    blockObjects: pteSchema.blockObjects.map((blockObject) => objectNames[blockObject.name] !== void 0 ? {\n      ...blockObject,\n      name: objectNames[blockObject.name],\n      type: {\n        ...blockObject.type,\n        name: objectNames[blockObject.name]\n      }\n    } : blockObject),\n    inlineObjects: pteSchema.inlineObjects.map((inlineObject) => objectNames[inlineObject.name] !== void 0 ? {\n      ...inlineObject,\n      name: objectNames[inlineObject.name]\n    } : inlineObject)\n  };\n}\nfunction defaultCompare(a, b) {\n  return a === b;\n}\nfunction useEditorSelector(editor, selector, t0) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(3), compare = t0 === void 0 ? defaultCompare : t0;\n  let t1;\n  return $[0] !== editor || $[1] !== selector ? (t1 = (editorActorSnapshot) => {\n    const snapshot = getEditorSnapshot({\n      editorActorSnapshot,\n      slateEditorInstance: editor._internal.slateEditor.instance\n    });\n    return selector(snapshot);\n  }, $[0] = editor, $[1] = selector, $[2] = t1) : t1 = $[2], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editor._internal.editorActor, t1, compare);\n}\nfunction getEditorSnapshot({\n  editorActorSnapshot,\n  slateEditorInstance\n}) {\n  return {\n    context: {\n      converters: [...editorActorSnapshot.context.converters],\n      activeDecorators: getActiveDecorators({\n        schema: editorActorSnapshot.context.schema,\n        slateEditorInstance\n      }),\n      keyGenerator: editorActorSnapshot.context.keyGenerator,\n      readOnly: editorActorSnapshot.matches({\n        \"edit mode\": \"read only\"\n      }),\n      schema: editorActorSnapshot.context.schema,\n      selection: editorActorSnapshot.context.selection,\n      value: slateChildrenToBlocks(editorActorSnapshot.context.schema, slateEditorInstance.children)\n    },\n    beta: {\n      hasTag: (tag) => editorActorSnapshot.hasTag(tag),\n      internalDrag: editorActorSnapshot.context.internalDrag\n    }\n  };\n}\nconst mutationMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_33__.setup)({\n  types: {\n    context: {},\n    events: {},\n    input: {},\n    emitted: {}\n  },\n  actions: {\n    \"emit has pending patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n      type: \"has pending patches\"\n    }),\n    \"emit mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const bulk of context.pendingMutations)\n        enqueue.emit({\n          type: \"mutation\",\n          patches: bulk.patches,\n          snapshot: bulk.value\n        });\n    }),\n    \"clear pending mutations\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingMutations: []\n    }),\n    \"defer patch\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingMutations: ({\n        context,\n        event\n      }) => {\n        if ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"patch\"), context.pendingMutations.length === 0)\n          return [{\n            operationId: event.operationId,\n            value: event.value,\n            patches: [event.patch]\n          }];\n        const lastBulk = context.pendingMutations.at(-1);\n        return lastBulk && lastBulk.operationId === event.operationId ? context.pendingMutations.slice(0, -1).concat({\n          value: event.value,\n          operationId: lastBulk.operationId,\n          patches: [...lastBulk.patches, event.patch]\n        }) : context.pendingMutations.concat({\n          value: event.value,\n          operationId: event.operationId,\n          patches: [event.patch]\n        });\n      }\n    })\n  },\n  actors: {\n    \"type listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_35__.fromCallback)(({\n      input,\n      sendBack\n    }) => {\n      const originalApply = input.slateEditor.apply;\n      return input.slateEditor.apply = (op) => {\n        op.type === \"insert_text\" || op.type === \"remove_text\" ? sendBack({\n          type: \"typing\"\n        }) : sendBack({\n          type: \"not typing\"\n        }), originalApply(op);\n      }, () => {\n        input.slateEditor.apply = originalApply;\n      };\n    })\n  },\n  guards: {\n    \"is typing\": (0,xstate__WEBPACK_IMPORTED_MODULE_36__.G)({\n      typing: \"typing\"\n    }),\n    \"no pending mutations\": ({\n      context\n    }) => context.pendingMutations.length === 0,\n    \"slate is normalizing\": ({\n      context\n    }) => slate__WEBPACK_IMPORTED_MODULE_20__.Editor.isNormalizing(context.slateEditor)\n  },\n  delays: {\n    \"mutation debounce\":  false ? 0 : 0,\n    \"type debounce\":  false ? 0 : 250\n  }\n}).createMachine({\n  id: \"mutation\",\n  context: ({\n    input\n  }) => ({\n    pendingMutations: [],\n    schema: input.schema,\n    slateEditor: input.slateEditor\n  }),\n  type: \"parallel\",\n  states: {\n    typing: {\n      initial: \"idle\",\n      invoke: {\n        src: \"type listener\",\n        input: ({\n          context\n        }) => ({\n          slateEditor: context.slateEditor\n        })\n      },\n      states: {\n        idle: {\n          on: {\n            typing: {\n              target: \"typing\"\n            }\n          }\n        },\n        typing: {\n          after: {\n            \"type debounce\": {\n              target: \"idle\"\n            }\n          },\n          on: {\n            \"not typing\": {\n              target: \"idle\"\n            },\n            typing: {\n              target: \"typing\",\n              reenter: !0\n            }\n          }\n        }\n      }\n    },\n    mutations: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          on: {\n            patch: {\n              actions: [\"defer patch\", \"emit has pending patches\"],\n              target: \"emitting mutations\"\n            }\n          }\n        },\n        \"emitting mutations\": {\n          after: {\n            \"mutation debounce\": [{\n              guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.D)([(0,xstate__WEBPACK_IMPORTED_MODULE_36__.E)(\"is typing\"), \"slate is normalizing\"]),\n              target: \"idle\",\n              actions: [\"emit mutations\", \"clear pending mutations\"]\n            }, {\n              target: \"emitting mutations\",\n              reenter: !0\n            }]\n          },\n          on: {\n            patch: {\n              target: \"emitting mutations\",\n              actions: [\"defer patch\"],\n              reenter: !0\n            }\n          }\n        }\n      }\n    }\n  }\n}), debug$6 = debugWithName(\"API:editable\");\nfunction createEditableAPI(editor, editorActor) {\n  const types = editorActor.getSnapshot().context.schema;\n  return {\n    focus: () => {\n      editorActor.send({\n        type: \"focus\",\n        editor\n      });\n    },\n    blur: () => {\n      editorActor.send({\n        type: \"blur\",\n        editor\n      });\n    },\n    toggleMark: (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.toggle\",\n          decorator: mark\n        },\n        editor\n      });\n    },\n    toggleList: (listItem) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"list item.toggle\",\n          listItem\n        },\n        editor\n      });\n    },\n    toggleBlockStyle: (style) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"style.toggle\",\n          style\n        },\n        editor\n      });\n    },\n    isMarkActive: (mark) => {\n      try {\n        return isDecoratorActive({\n          editor,\n          decorator: mark\n        });\n      } catch (err) {\n        return console.warn(err), !1;\n      }\n    },\n    marks: () => ({\n      ...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.marks(editor) || {}\n    }).marks || [],\n    undo: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.undo\"\n        },\n        editor\n      });\n    },\n    redo: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"history.redo\"\n        },\n        editor\n      });\n    },\n    select: (selection) => {\n      const slateSelection = toSlateRange(selection, editor);\n      slateSelection ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(editor), editor.onChange();\n    },\n    focusBlock: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_20__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block)\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n      }\n    },\n    focusChild: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_20__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block && editor.isTextBlock(block))\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n      }\n    },\n    insertChild: (type, value) => {\n      if (type.name !== types.span.name)\n        return editorActor.send({\n          type: \"behavior event\",\n          behaviorEvent: {\n            type: \"insert.inline object\",\n            inlineObject: {\n              name: type.name,\n              value\n            }\n          },\n          editor\n        }), editor.selection ? slateRangeToSelection({\n          schema: editorActor.getSnapshot().context.schema,\n          editor,\n          range: editor.selection\n        })?.focus.path ?? [] : [];\n      if (!editor.selection)\n        throw new Error(\"The editor has no selection\");\n      const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n        at: editor.selection.focus.path.slice(0, 1),\n        match: (n) => n._type === types.block.name\n      }))[0] || [void 0];\n      if (!focusBlock)\n        throw new Error(\"No focused text block\");\n      if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n        throw new Error(\"This type cannot be inserted as a child to a text block\");\n      const child = toSlateValue([{\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        _type: types.block.name,\n        children: [{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: type.name,\n          ...value || {}\n        }]\n      }], {\n        schemaTypes: editorActor.getSnapshot().context.schema\n      })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_20__.Node.get(editor, focusChildPath);\n      return isSpanNode && focusNode._type !== types.span.name && (debug$6(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n        distance: 1,\n        unit: \"character\"\n      })), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(editor, child, {\n        select: !0,\n        at: editor.selection\n      }), editor.onChange(), editor.selection ? slateRangeToSelection({\n        schema: editorActor.getSnapshot().context.schema,\n        editor,\n        range: editor.selection\n      })?.focus.path ?? [] : [];\n    },\n    insertBlock: (type, value) => (editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"insert.block\",\n        block: {\n          _type: type.name,\n          ...value || {}\n        },\n        placement: \"auto\"\n      },\n      editor\n    }), editor.selection ? slateRangeToSelection({\n      schema: editorActor.getSnapshot().context.schema,\n      editor,\n      range: editor.selection\n    })?.focus.path ?? [] : []),\n    hasBlockStyle: (style) => {\n      try {\n        return isStyleActive({\n          editor,\n          style\n        });\n      } catch {\n        return !1;\n      }\n    },\n    hasListStyle: (listItem) => {\n      try {\n        return isListItemActive({\n          editor,\n          listItem\n        });\n      } catch {\n        return !1;\n      }\n    },\n    isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n    findByPath: (path) => {\n      const slatePath = toSlateRange({\n        focus: {\n          path,\n          offset: 0\n        },\n        anchor: {\n          path,\n          offset: 0\n        }\n      }, editor);\n      if (slatePath) {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n        if (block && blockPath && typeof block._key == \"string\") {\n          if (path.length === 1 && slatePath.focus.path.length === 1)\n            return [fromSlateValue([block], types.block.name)[0], [{\n              _key: block._key\n            }]];\n          const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]];\n            if (ptChild)\n              return [ptChild, [{\n                _key: block._key\n              }, \"children\", {\n                _key: ptChild._key\n              }]];\n          }\n        }\n      }\n      return [void 0, void 0];\n    },\n    findDOMNode: (element) => {\n      let node;\n      try {\n        const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n          at: [],\n          match: (n) => n._key === element._key\n        }) || [])[0] || [void 0];\n        node = slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.toDOMNode(editor, item);\n      } catch {\n      }\n      return node;\n    },\n    activeAnnotations: () => {\n      if (!editor.selection || editor.selection.focus.path.length < 2)\n        return [];\n      try {\n        const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n        });\n        for (const [span, path] of spans) {\n          const [block] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, path, {\n            depth: 1\n          });\n          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {\n            slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n          });\n        }\n        return activeAnnotations;\n      } catch {\n        return [];\n      }\n    },\n    isAnnotationActive: (annotationType) => isAnnotationActive({\n      editor,\n      annotation: {\n        name: annotationType\n      }\n    }),\n    addAnnotation: (type, value) => {\n      let paths;\n      return slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(editor, () => {\n        paths = addAnnotationOperationImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: types\n          },\n          operation: {\n            annotation: {\n              name: type.name,\n              value: value ?? {}\n            },\n            editor\n          }\n        });\n      }), editor.onChange(), paths;\n    },\n    delete: (selection, options) => {\n      if (selection) {\n        const range = toSlateRange(selection, editor);\n        if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n          throw new Error(\"Invalid range\");\n        if (range) {\n          if (!options?.mode || options?.mode === \"selected\") {\n            debug$6(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.delete(editor, {\n              at: range,\n              hanging: !0,\n              voids: !0\n            }), editor.onChange();\n            return;\n          }\n          options?.mode === \"blocks\" && (debug$6(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(node)\n          })), options?.mode === \"children\" && (debug$6(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => node._type === types.span.name || // Text children\n            !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(node)\n          })), editor.children.length === 0 && (editor.children = [editor.pteCreateTextBlock({\n            decorators: []\n          })]), editor.onChange();\n        }\n      }\n    },\n    removeAnnotation: (type) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"annotation.remove\",\n          annotation: {\n            name: type.name\n          }\n        },\n        editor\n      });\n    },\n    getSelection: () => {\n      let ptRange = null;\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n        if (existing)\n          return existing;\n        ptRange = slateRangeToSelection({\n          schema: editorActor.getSnapshot().context.schema,\n          editor,\n          range: editor.selection\n        }), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n      }\n      return ptRange;\n    },\n    getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n    isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(editor.selection),\n    isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isExpanded(editor.selection),\n    insertBreak: () => {\n      editor.insertBreak(), editor.onChange();\n    },\n    getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n    isSelectionsOverlapping: (selectionA, selectionB) => {\n      const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n      return slate__WEBPACK_IMPORTED_MODULE_20__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_20__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_20__.Range.includes(rangeA, rangeB);\n    }\n  };\n}\nfunction isAnnotationActive({\n  editor,\n  annotation\n}) {\n  if (!editor.selection || editor.selection.focus.path.length < 2)\n    return !1;\n  try {\n    const spans = [...slate__WEBPACK_IMPORTED_MODULE_20__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(node)\n    })];\n    if (spans.length === 0 || spans.some(([span]) => !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_23__.isPortableTextSpan)(span) || !span.marks || span.marks?.length === 0)) return !1;\n    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n      const [block] = slate__WEBPACK_IMPORTED_MODULE_20__.Editor.node(editor, path, {\n        depth: 1\n      });\n      return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;\n    }, []);\n    return spans.every(([span]) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_23__.isPortableTextSpan)(span) ? span.marks?.map((markKey) => selectionMarkDefs.find((def) => def?._key === markKey)?._type)?.includes(annotation.name) : !1);\n  } catch {\n    return !1;\n  }\n}\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? {\n    valid: !0,\n    resolution: null,\n    value\n  } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_13__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([index])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n          ...blk,\n          _key: keyGenerator()\n        }, [index])],\n        description: `Block at index ${index} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n            ...blk,\n            _type: currentBlockTypeName\n          }, [{\n            _key: blk._key\n          }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: {\n              key: blk._key,\n              expectedTypeName: currentBlockTypeName\n            }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.isTextBlock)({\n        schema: types\n      }, {\n        ...blk,\n        _type: types.block.name\n      }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n          ...blk,\n          _type: types.block.name\n        }, [{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: {\n            key: blk._key,\n            expectedTypeName: types.block.name\n          }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: {\n            key: blk._key,\n            typeName: blk._type\n          }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: {\n            key: blk._key\n          }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n            children: []\n          }, [{\n            _key: textBlock._key\n          }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: {\n              key: textBlock._key\n            }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.setIfMissing)([], [{\n            _key: blk._key\n          }, \"children\"]), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.insert)([newSpan], \"after\", [{\n            _key: blk._key\n          }, \"children\", 0])],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: {\n              key: blk._key\n            }\n          }\n        }, !0;\n      }\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])));\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map((markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n              _key: blk._key\n            }, \"markDefs\", {\n              _key: markDefKey\n            }])),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: {\n                key: blk._key,\n                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())\n              }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.name).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{\n              _key: blk._key\n            }, \"children\", {\n              _key: child._key\n            }, \"marks\"])),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: {\n                key: blk._key,\n                orphanedMarks: orphanedMarks.map((m) => m.toString())\n              }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_13__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = {\n            ...child,\n            _key: keyGenerator()\n          };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)(newChild, [{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.set)({\n            ...child,\n            text: \"\"\n          }, [{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key,\n              childType: child._type\n            }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_31__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), {\n    valid,\n    resolution,\n    value\n  });\n}\nconst debug$5 = debugWithName(\"sync machine\"), syncValueCallback = ({\n  sendBack,\n  input\n}) => {\n  updateValue({\n    context: input.context,\n    sendBack,\n    slateEditor: input.slateEditor,\n    value: input.value,\n    streamBlocks: input.streamBlocks\n  });\n}, syncValueLogic = (0,xstate__WEBPACK_IMPORTED_MODULE_35__.fromCallback)(syncValueCallback), syncMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_33__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {},\n    emitted: {}\n  },\n  actions: {\n    \"assign initial value synced\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      initialValueSynced: !0\n    }),\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      readOnly: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"update readOnly\"), event.readOnly)\n    }),\n    \"assign pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"update value\"), event.value)\n    }),\n    \"clear pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingValue: void 0\n    }),\n    \"assign previous value\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      previousValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"done syncing\"), event.value)\n    }),\n    \"emit done syncing value\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n      type: \"done syncing value\"\n    }),\n    \"emit syncing value\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n      type: \"syncing value\"\n    })\n  },\n  guards: {\n    \"initial value synced\": ({\n      context\n    }) => context.initialValueSynced,\n    \"is busy\": ({\n      context\n    }) => {\n      const editable = !context.readOnly, isProcessingLocalChanges = context.isProcessingLocalChanges, isChanging = isChangingRemotely(context.slateEditor) ?? !1, isBusy = editable && (isProcessingLocalChanges || isChanging);\n      return debug$5(\"isBusy\", {\n        isBusy,\n        editable,\n        isProcessingLocalChanges,\n        isChanging\n      }), isBusy;\n    },\n    \"is empty value\": ({\n      event\n    }) => event.type === \"update value\" && event.value === void 0,\n    \"is empty array\": ({\n      event\n    }) => event.type === \"update value\" && Array.isArray(event.value) && event.value.length === 0,\n    \"is new value\": ({\n      context,\n      event\n    }) => event.type === \"update value\" && context.previousValue !== event.value,\n    \"value changed while syncing\": ({\n      context,\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_33__.assertEvent)(event, \"done syncing\"), context.pendingValue !== event.value),\n    \"pending value equals previous value\": ({\n      context\n    }) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(context.pendingValue, context.previousValue)\n  },\n  actors: {\n    \"sync value\": syncValueLogic\n  }\n}).createMachine({\n  id: \"sync\",\n  context: ({\n    input\n  }) => ({\n    initialValue: input.initialValue,\n    initialValueSynced: !1,\n    isProcessingLocalChanges: !1,\n    keyGenerator: input.keyGenerator,\n    schema: input.schema,\n    readOnly: input.readOnly,\n    slateEditor: input.slateEditor,\n    pendingValue: void 0,\n    previousValue: void 0\n  }),\n  entry: [(0,xstate__WEBPACK_IMPORTED_MODULE_36__.O)(({\n    context\n  }) => ({\n    type: \"update value\",\n    value: context.initialValue\n  }))],\n  on: {\n    \"has pending patches\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n        isProcessingLocalChanges: !0\n      })\n    },\n    mutation: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n        isProcessingLocalChanges: !1\n      })\n    },\n    \"update readOnly\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  initial: \"idle\",\n  states: {\n    idle: {\n      entry: [() => {\n        debug$5(\"entry: syncing->idle\");\n      }],\n      exit: [() => {\n        debug$5(\"exit: syncing->idle\");\n      }],\n      on: {\n        \"update value\": [{\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.D)([\"is empty value\", (0,xstate__WEBPACK_IMPORTED_MODULE_36__.E)(\"initial value synced\")]),\n          actions: [\"assign initial value synced\", \"emit done syncing value\"]\n        }, {\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.D)([\"is empty array\", (0,xstate__WEBPACK_IMPORTED_MODULE_36__.E)(\"initial value synced\")]),\n          actions: [\"assign initial value synced\", (0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)({\n            type: \"value changed\",\n            value: []\n          }), \"emit done syncing value\"]\n        }, {\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.D)([\"is busy\", \"is new value\"]),\n          target: \"busy\",\n          actions: [\"assign pending value\"]\n        }, {\n          guard: \"is new value\",\n          target: \"syncing\",\n          actions: [\"assign pending value\"]\n        }, {\n          guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.E)(\"initial value synced\"),\n          actions: [() => {\n            debug$5(\"no new value \\u2013 setting initial value as synced\");\n          }, \"assign initial value synced\", \"emit done syncing value\"]\n        }, {\n          actions: [() => {\n            debug$5(\"no new value and initial value already synced\");\n          }]\n        }]\n      }\n    },\n    busy: {\n      entry: [() => {\n        debug$5(\"entry: syncing->busy\");\n      }],\n      exit: [() => {\n        debug$5(\"exit: syncing->busy\");\n      }],\n      after: {\n        1e3: [{\n          guard: \"is busy\",\n          target: \".\",\n          reenter: !0,\n          actions: [() => {\n            debug$5(\"reenter: syncing->busy\");\n          }]\n        }, {\n          target: \"syncing\"\n        }]\n      },\n      on: {\n        \"update value\": [{\n          guard: \"is new value\",\n          actions: [\"assign pending value\"]\n        }]\n      }\n    },\n    syncing: {\n      entry: [() => {\n        debug$5(\"entry: syncing->syncing\");\n      }, \"emit syncing value\"],\n      exit: [() => {\n        debug$5(\"exit: syncing->syncing\");\n      }, \"emit done syncing value\"],\n      invoke: {\n        src: \"sync value\",\n        id: \"sync value\",\n        input: ({\n          context\n        }) => ({\n          context: {\n            keyGenerator: context.keyGenerator,\n            previousValue: context.previousValue,\n            readOnly: context.readOnly,\n            schema: context.schema\n          },\n          slateEditor: context.slateEditor,\n          streamBlocks: !context.initialValueSynced,\n          value: context.pendingValue\n        })\n      },\n      on: {\n        \"update value\": {\n          guard: \"is new value\",\n          actions: [\"assign pending value\"]\n        },\n        patch: {\n          actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n            event\n          }) => event)]\n        },\n        \"invalid value\": {\n          actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n            event\n          }) => event)]\n        },\n        \"value changed\": {\n          actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_34__.e)(({\n            event\n          }) => event)]\n        },\n        \"done syncing\": [{\n          guard: \"value changed while syncing\",\n          actions: [\"assign previous value\", \"assign initial value synced\"],\n          target: \"syncing\",\n          reenter: !0\n        }, {\n          target: \"idle\",\n          actions: [\"clear pending value\", \"assign previous value\", \"assign initial value synced\"]\n        }]\n      }\n    }\n  }\n});\nasync function updateValue({\n  context,\n  sendBack,\n  slateEditor,\n  streamBlocks,\n  value\n}) {\n  let doneSyncing = !1, isChanged = !1, isValid = !0;\n  const hadSelection = !!slateEditor.selection;\n  if ((!value || value.length === 0) && (debug$5(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(slateEditor, () => {\n    withoutSaving(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (doneSyncing)\n          return;\n        hadSelection && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(slateEditor);\n        const childrenLength = slateEditor.children.length;\n        slateEditor.children.forEach((_, index) => {\n          slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(slateEditor, {\n            at: [childrenLength - 1 - index]\n          });\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n          decorators: []\n        }), {\n          at: [0]\n        }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(slateEditor, [0, 0]);\n      });\n    });\n  }), isChanged = !0), value && value.length > 0) {\n    const slateValueFromProps = toSlateValue(value, {\n      schemaTypes: context.schema\n    });\n    streamBlocks ? await new Promise((resolve) => {\n      slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            if (doneSyncing) {\n              resolve();\n              return;\n            }\n            isChanged = removeExtraBlocks({\n              slateEditor,\n              slateValueFromProps\n            }), (async () => {\n              for await (const [currentBlock, currentBlockIndex] of getStreamedBlocks({\n                slateValue: slateValueFromProps\n              })) {\n                const {\n                  blockChanged,\n                  blockValid\n                } = syncBlock({\n                  context,\n                  sendBack,\n                  block: currentBlock,\n                  index: currentBlockIndex,\n                  slateEditor,\n                  value\n                });\n                isChanged = blockChanged || isChanged, isValid = isValid && blockValid;\n              }\n              resolve();\n            })();\n          });\n        });\n      });\n    }) : slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(slateEditor, () => {\n      withRemoteChanges(slateEditor, () => {\n        withoutPatching(slateEditor, () => {\n          if (doneSyncing)\n            return;\n          isChanged = removeExtraBlocks({\n            slateEditor,\n            slateValueFromProps\n          });\n          let index = 0;\n          for (const currentBlock of slateValueFromProps) {\n            const {\n              blockChanged,\n              blockValid\n            } = syncBlock({\n              context,\n              sendBack,\n              block: currentBlock,\n              index,\n              slateEditor,\n              value\n            });\n            isChanged = blockChanged || isChanged, isValid = isValid && blockValid, index++;\n          }\n        });\n      });\n    });\n  }\n  if (!isValid) {\n    debug$5(\"Invalid value, returning\"), doneSyncing = !0, sendBack({\n      type: \"done syncing\",\n      value\n    });\n    return;\n  }\n  if (isChanged) {\n    debug$5(\"Server value changed, syncing editor\");\n    try {\n      slateEditor.onChange();\n    } catch (err) {\n      console.error(err), sendBack({\n        type: \"invalid value\",\n        resolution: null,\n        value\n      }), doneSyncing = !0, sendBack({\n        type: \"done syncing\",\n        value\n      });\n      return;\n    }\n    hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(slateEditor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), slateEditor.onChange()), sendBack({\n      type: \"value changed\",\n      value\n    });\n  } else\n    debug$5(\"Server value and editor value is equal, no need to sync.\");\n  doneSyncing = !0, sendBack({\n    type: \"done syncing\",\n    value\n  });\n}\nfunction removeExtraBlocks({\n  slateEditor,\n  slateValueFromProps\n}) {\n  let isChanged = !1;\n  const childrenLength = slateEditor.children.length;\n  if (slateValueFromProps.length < childrenLength) {\n    for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)\n      slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(slateEditor, {\n        at: [i]\n      });\n    isChanged = !0;\n  }\n  return isChanged;\n}\nasync function* getStreamedBlocks({\n  slateValue\n}) {\n  let index = 0;\n  for await (const block of slateValue)\n    index % 10 === 0 && await new Promise((resolve) => setTimeout(resolve, 0)), yield [block, index], index++;\n}\nfunction syncBlock({\n  context,\n  sendBack,\n  block,\n  index,\n  slateEditor,\n  value\n}) {\n  let blockChanged = !1, blockValid = !0;\n  const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(currentBlock, oldBlock);\n  return slate__WEBPACK_IMPORTED_MODULE_20__.Editor.withoutNormalizing(slateEditor, () => {\n    withRemoteChanges(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (hasChanges && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {\n            sendBack({\n              type: \"patch\",\n              patch\n            });\n          })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$5.enabled && debug$5(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$5.enabled && debug$5(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n        if (!oldBlock && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          debug$5.enabled && debug$5(\"Validating and inserting new block in the end of the value\", currentBlock), validation.valid || validation.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(slateEditor, currentBlock, {\n            at: [currentBlockIndex]\n          }) : (debug$5(\"Invalid\", validation), sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n      });\n    });\n  }), {\n    blockChanged,\n    blockValid\n  };\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(slateEditor, {\n    at: [currentBlockIndex]\n  }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {\n      const childIndex = oldBlockChildrenLength - 1 - index;\n      childIndex > 0 && (debug$5(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(slateEditor, {\n        at: [currentBlockIndex, childIndex]\n      }));\n    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === oldBlockChild?._key) {\n          debug$5(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_20__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode && isTextChanged ? (oldBlockChild.text.length > 0 && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.delete(slateEditor, {\n            at: {\n              focus: {\n                path,\n                offset: 0\n              },\n              anchor: {\n                path,\n                offset: oldBlockChild.text.length\n              }\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode || (debug$5(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.setNodes(slateEditor, {\n            _key: VOID_CHILD_KEY\n          }, {\n            at: [...path, 0],\n            voids: !0\n          }));\n        } else oldBlockChild ? (debug$5(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange()) : oldBlockChild || (debug$5(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange());\n    });\n  }\n}\nconst debug$4 = debugWithName(\"setup\");\nfunction compileSchemasFromEditorConfig(config) {\n  const legacySchema = config.schemaDefinition ? compileSchemaDefinitionToLegacySchema(config.schemaDefinition) : createLegacySchema(config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema)), schema = legacySchemaToEditorSchema(legacySchema);\n  return {\n    legacySchema,\n    schema\n  };\n}\nfunction editorConfigToMachineInput(config) {\n  const {\n    legacySchema,\n    schema\n  } = compileSchemasFromEditorConfig(config);\n  return {\n    converters: createCoreConverters(legacySchema),\n    getLegacySchema: () => legacySchema,\n    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema,\n    initialValue: config.initialValue\n  };\n}\nfunction createInternalEditor(config) {\n  debug$4(\"Creating new Editor instance\");\n  const subscriptions = [], editorActor = (0,xstate__WEBPACK_IMPORTED_MODULE_36__.A)(editorMachine, {\n    input: editorConfigToMachineInput(config)\n  }), slateEditor = createSlateEditor({\n    editorActor,\n    subscriptions\n  }), editable = createEditableAPI(slateEditor.instance, editorActor), {\n    mutationActor,\n    syncActor\n  } = createActors({\n    editorActor,\n    slateEditor: slateEditor.instance,\n    subscriptions\n  });\n  return {\n    actors: {\n      editorActor,\n      mutationActor,\n      syncActor\n    },\n    editor: {\n      getSnapshot: () => getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor.instance\n      }),\n      registerBehavior: (behaviorConfig) => {\n        const priority = createEditorPriority({\n          name: \"custom\",\n          reference: {\n            priority: corePriority,\n            importance: \"higher\"\n          }\n        }), behaviorConfigWithPriority = {\n          ...behaviorConfig,\n          priority\n        };\n        return editorActor.send({\n          type: \"add behavior\",\n          behaviorConfig: behaviorConfigWithPriority\n        }), () => {\n          editorActor.send({\n            type: \"remove behavior\",\n            behaviorConfig: behaviorConfigWithPriority\n          });\n        };\n      },\n      send: (event) => {\n        switch (event.type) {\n          case \"update value\":\n            syncActor.send(event);\n            break;\n          case \"update key generator\":\n          case \"update readOnly\":\n          case \"patches\":\n          case \"update schema\":\n          case \"update maxBlocks\":\n            editorActor.send(event);\n            break;\n          case \"blur\":\n            editorActor.send({\n              type: \"blur\",\n              editor: slateEditor.instance\n            });\n            break;\n          case \"focus\":\n            editorActor.send({\n              type: \"focus\",\n              editor: slateEditor.instance\n            });\n            break;\n          case \"insert.block object\":\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"insert.block\",\n                block: {\n                  _type: event.blockObject.name,\n                  ...event.blockObject.value ?? {}\n                },\n                placement: event.placement\n              },\n              editor: slateEditor.instance\n            });\n            break;\n          default:\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: event,\n              editor: slateEditor.instance\n            });\n        }\n      },\n      on: (event, listener) => editorActor.on(event, (event2) => {\n        switch (event2.type) {\n          case \"blurred\":\n          case \"done loading\":\n          case \"editable\":\n          case \"error\":\n          case \"focused\":\n          case \"invalid value\":\n          case \"loading\":\n          case \"mutation\":\n          case \"patch\":\n          case \"read only\":\n          case \"ready\":\n          case \"selection\":\n          case \"value changed\":\n            listener(event2);\n            break;\n        }\n      }),\n      _internal: {\n        editable,\n        editorActor,\n        slateEditor\n      }\n    },\n    subscriptions\n  };\n}\nfunction createActors(config) {\n  debug$4(\"Creating new Actors\");\n  const mutationActor = (0,xstate__WEBPACK_IMPORTED_MODULE_36__.A)(mutationMachine, {\n    input: {\n      schema: config.editorActor.getSnapshot().context.schema,\n      slateEditor: config.slateEditor\n    }\n  }), syncActor = (0,xstate__WEBPACK_IMPORTED_MODULE_36__.A)(syncMachine, {\n    input: {\n      initialValue: config.editorActor.getSnapshot().context.initialValue,\n      keyGenerator: config.editorActor.getSnapshot().context.keyGenerator,\n      readOnly: config.editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      }),\n      schema: config.editorActor.getSnapshot().context.schema,\n      slateEditor: config.slateEditor\n    }\n  });\n  return config.subscriptions.push(() => {\n    const subscription = mutationActor.on(\"*\", (event) => {\n      event.type === \"has pending patches\" && syncActor.send({\n        type: \"has pending patches\"\n      }), event.type === \"mutation\" && (syncActor.send({\n        type: \"mutation\"\n      }), config.editorActor.send({\n        type: \"mutation\",\n        patches: event.patches,\n        snapshot: event.snapshot,\n        value: event.snapshot\n      }));\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), config.subscriptions.push(() => {\n    const subscription = syncActor.on(\"*\", (event) => {\n      switch (event.type) {\n        case \"invalid value\":\n          config.editorActor.send({\n            ...event,\n            type: \"notify.invalid value\"\n          });\n          break;\n        case \"value changed\":\n          config.editorActor.send({\n            ...event,\n            type: \"notify.value changed\"\n          });\n          break;\n        case \"patch\":\n          config.editorActor.send({\n            ...event,\n            type: \"internal.patch\",\n            value: fromSlateValue(config.slateEditor.children, config.editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(config.slateEditor))\n          });\n          break;\n        default:\n          config.editorActor.send(event);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), config.subscriptions.push(() => {\n    const subscription = config.editorActor.on(\"*\", (event) => {\n      config.editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      }) ? syncActor.send({\n        type: \"update readOnly\",\n        readOnly: !0\n      }) : syncActor.send({\n        type: \"update readOnly\",\n        readOnly: !1\n      }), event.type === \"internal.patch\" && mutationActor.send({\n        ...event,\n        type: \"patch\"\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }), {\n    syncActor,\n    mutationActor\n  };\n}\nconst PortableTextEditorSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null), usePortableTextEditorSelection = () => {\n  const selection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PortableTextEditorSelectionContext);\n  if (selection === void 0)\n    throw new Error(\"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\");\n  return selection;\n}, debug$3 = debugWithName(\"component:PortableTextEditor:SelectionProvider\");\nfunction PortableTextEditorSelectionProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(6), [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  let t0, t1;\n  $[0] !== props.editorActor ? (t0 = () => {\n    debug$3(\"Subscribing to selection changes\");\n    const subscription = props.editorActor.on(\"selection\", (event) => {\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)(() => {\n        setSelection(event.selection);\n      });\n    });\n    return () => {\n      debug$3(\"Unsubscribing to selection changes\"), subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1);\n  let t2;\n  return $[3] !== props.children || $[4] !== selection ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }), $[3] = props.children, $[4] = selection, $[5] = t2) : t2 = $[5], t2;\n}\nfunction RouteEventsToChanges(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(7);\n  let t0;\n  $[0] !== props ? (t0 = (change) => props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];\n  const handleChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_15__.useEffectEvent)(t0);\n  let t1;\n  $[2] !== handleChange || $[3] !== props.editorActor ? (t1 = () => {\n    const sub = props.editorActor.on(\"*\", (event) => {\n      const change_0 = eventToChange(event);\n      change_0 && handleChange(change_0);\n    });\n    return () => {\n      sub.unsubscribe();\n    };\n  }, $[2] = handleChange, $[3] = props.editorActor, $[4] = t1) : t1 = $[4];\n  let t2;\n  return $[5] !== props.editorActor ? (t2 = [props.editorActor], $[5] = props.editorActor, $[6] = t2) : t2 = $[6], (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t1, t2), null;\n}\nfunction eventToChange(event) {\n  switch (event.type) {\n    case \"blurred\":\n      return {\n        type: \"blur\",\n        event: event.event\n      };\n    case \"patch\":\n      return event;\n    case \"loading\":\n      return {\n        type: \"loading\",\n        isLoading: !0\n      };\n    case \"done loading\":\n      return {\n        type: \"loading\",\n        isLoading: !1\n      };\n    case \"focused\":\n      return {\n        type: \"focus\",\n        event: event.event\n      };\n    case \"value changed\":\n      return {\n        type: \"value\",\n        value: event.value\n      };\n    case \"invalid value\":\n      return {\n        type: \"invalidValue\",\n        resolution: event.resolution,\n        value: event.value\n      };\n    case \"error\":\n      return {\n        ...event,\n        level: \"warning\"\n      };\n    case \"mutation\":\n      return event;\n    case \"ready\":\n      return event;\n    case \"selection\":\n      return event;\n    case \"unset\":\n      return event;\n  }\n}\nconst debug$2 = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  static displayName = \"PortableTextEditor\";\n  /**\n   * An observable of all the editor changes.\n   */\n  change$ = new rxjs__WEBPACK_IMPORTED_MODULE_37__.Subject();\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  /**\n   * The editor instance\n   */\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  unsubscribers = [];\n  constructor(props) {\n    if (super(props), props.editor)\n      this.editor = props.editor, this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.getLegacySchema();\n    else {\n      const {\n        actors,\n        editor,\n        subscriptions\n      } = createInternalEditor({\n        initialValue: props.value,\n        keyGenerator: props.keyGenerator,\n        maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),\n        readOnly: props.readOnly,\n        schema: props.schemaType\n      });\n      this.unsubscribers.push((() => {\n        const subscription = actors.editorActor.on(\"*\", (event) => {\n          const change = eventToChange(event);\n          change && (props.onChange(change), this.change$.next(change));\n        });\n        return () => {\n          subscription.unsubscribe();\n        };\n      })());\n      for (const subscription of subscriptions)\n        this.unsubscribers.push(subscription());\n      this.actors = actors, this.editor = editor, this.schemaTypes = actors.editorActor.getSnapshot().context.getLegacySchema();\n    }\n    this.editable = this.editor._internal.editable;\n  }\n  componentDidMount() {\n    this.actors && (this.actors.editorActor.start(), this.actors.mutationActor.start(), this.actors.syncActor.start());\n  }\n  componentDidUpdate(prevProps) {\n    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = createLegacySchema(this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)), this.editor._internal.editorActor.send({\n      type: \"update schema\",\n      schema: legacySchemaToEditorSchema(this.schemaTypes)\n    })), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({\n      type: \"update readOnly\",\n      readOnly: this.props.readOnly ?? !1\n    }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({\n      type: \"update maxBlocks\",\n      maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)\n    }), this.props.value !== prevProps.value && this.editor.send({\n      type: \"update value\",\n      value: this.props.value\n    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));\n  }\n  componentWillUnmount() {\n    for (const unsubscribe of this.unsubscribers)\n      unsubscribe();\n    this.actors && (stopActor(this.actors.editorActor), stopActor(this.actors.mutationActor), stopActor(this.actors.syncActor));\n  }\n  setEditable = (editable) => {\n    this.editor._internal.editable = {\n      ...this.editor._internal.editable,\n      ...editable\n    };\n  };\n  render() {\n    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n      legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_26__.Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorContext.Provider, { value: this, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorSelectionProvider, { editorActor: this.editor._internal.editorActor, children: this.props.children }) }) }) })\n    ] });\n  }\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)\n   * ```\n   */\n  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))\n   * ```\n   */\n  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.add',\n   *  annotation: {\n   *    name: '...',\n   *    value: {...},\n   *  }\n   * })\n   * ```\n   */\n  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'blur',\n   * })\n   * ```\n   */\n  static blur = (editor) => {\n    debug$2(\"Host blurred\"), editor.editable?.blur();\n  };\n  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);\n  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);\n  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'focus',\n   * })\n   * ```\n   */\n  static focus = (editor) => {\n    debug$2(\"Host requesting focus\"), editor.editable?.focus();\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)\n   * ```\n   */\n  static focusBlock = (editor) => editor.editable?.focusBlock();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)\n   * ```\n   */\n  static focusChild = (editor) => editor.editable?.focusChild();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selection = useEditorSelector(editor, selectors.getSelection)\n   * ```\n   */\n  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const value = useEditorSelector(editor, selectors.getValue)\n   * ```\n   */\n  static getValue = (editor) => editor.editable?.getValue();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))\n   * ```\n   */\n  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))\n   * ```\n   */\n  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)\n   * ```\n   */\n  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)\n   * ```\n   */\n  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))\n   * ```\n   */\n  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.span',\n   *  text: '...',\n   *  annotations: [{name: '...', value: {...}}],\n   *  decorators: ['...'],\n   * })\n   * editor.send({\n   *  type: 'insert.inline object',\n   *  inlineObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   * })\n   * ```\n   */\n  static insertChild = (editor, type, value) => (debug$2(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.block object',\n   *  blockObject: {\n   *    name: '...',\n   *    value: {...},\n   *  },\n   *  placement: 'auto' | 'after' | 'before',\n   * })\n   * ```\n   */\n  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'insert.break',\n   * })\n   * ```\n   */\n  static insertBreak = (editor) => editor.editable?.insertBreak();\n  static isVoid = (editor, element) => editor.editable?.isVoid(element);\n  static isObjectPath = (_editor, path) => {\n    if (!path || !Array.isArray(path)) return !1;\n    const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n    return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n  };\n  static marks = (editor) => editor.editable?.marks();\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'select',\n   *  selection: {...},\n   * })\n   * ```\n   */\n  static select = (editor, selection) => {\n    debug$2(\"Host setting selection\", selection), editor.editable?.select(selection);\n  };\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'annotation.remove',\n   *  annotation: {\n   *    name: '...',\n   *  },\n   * })\n   * ```\n   */\n  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'style.toggle',\n   *  style: '...',\n   * })\n   * ```\n   */\n  static toggleBlockStyle = (editor, blockStyle) => (debug$2(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'list item.toggle',\n   *  listItem: '...',\n   * })\n   * ```\n   */\n  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *  type: 'decorator.toggle',\n   *  decorator: '...',\n   * })\n   * ```\n   */\n  static toggleMark = (editor, mark) => {\n    debug$2(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const selectedSlice = useEditorSelector(editor, selectors.getSelectedSlice)\n   * ```\n   */\n  static getFragment = (editor) => editor.editable?.getFragment();\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *   type: 'history.undo',\n   * })\n   * ```\n   */\n  static undo = (editor) => {\n    debug$2(\"Host undoing\"), editor.editable?.undo();\n  };\n  /**\n   * @deprecated\n   * Use `editor.send(...)` instead\n   *\n   * ```\n   * const editor = useEditor()\n   * editor.send({\n   *   type: 'history.redo',\n   * })\n   * ```\n   */\n  static redo = (editor) => {\n    debug$2(\"Host redoing\"), editor.editable?.redo();\n  };\n  /**\n   * @deprecated\n   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/\n   *\n   * ```\n   * import * as selectors from '@portabletext/editor/selectors'\n   * const editor = useEditor()\n   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))\n   * ```\n   */\n  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4);\n  let t0, t1;\n  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: \"patches\",\n        ...payload\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction RenderSpan(props) {\n  const slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSlateStatic)(), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), legacySchema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, (s) => s.context.getLegacySchema()), spanRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), parent = props.children.props.parent, block = parent && slateEditor.isTextBlock(parent) ? parent : void 0, path = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => block ? [{\n    _key: block._key\n  }, \"children\", {\n    _key: props.leaf._key\n  }] : void 0, [block, props.leaf._key]), decoratorSchemaTypes = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), decorators = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_6__((props.leaf.marks ?? []).filter((mark) => decoratorSchemaTypes.includes(mark))), annotationMarkDefs = (props.leaf.marks ?? []).flatMap((mark_0) => {\n    if (decoratorSchemaTypes.includes(mark_0))\n      return [];\n    const markDef_0 = block?.markDefs?.find((markDef) => markDef._key === mark_0);\n    return markDef_0 ? [markDef_0] : [];\n  }), shouldTrackSelectionAndFocus = annotationMarkDefs.length > 0 && blockSelected;\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(!1);\n      return;\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor);\n    sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)(() => {\n      setFocused(!0);\n    });\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);\n  const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const winSelection = window.getSelection();\n    if (!winSelection) {\n      setSelected(!1);\n      return;\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0);\n      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n    } else\n      setSelected(!1);\n  }, [shouldTrackSelectionAndFocus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const onBlur = editorActor.on(\"blurred\", () => {\n      setFocused(!1), setSelected(!1);\n    }), onFocus = editorActor.on(\"focused\", () => {\n      const sel_0 = PortableTextEditor.getSelection(portableTextEditor);\n      sel_0 && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n    }), onSelection = editorActor.on(\"selection\", (event) => {\n      event.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();\n    });\n    return () => {\n      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();\n    };\n  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);\n  let children = props.children;\n  for (const mark_1 of decorators) {\n    const legacyDecoratorSchemaType = legacySchema.decorators.find((dec) => dec.value === mark_1);\n    path && legacyDecoratorSchemaType && props.renderDecorator && (children = props.renderDecorator({\n      children,\n      editorElementRef: spanRef,\n      focused,\n      path,\n      selected,\n      schemaType: legacyDecoratorSchemaType,\n      value: mark_1,\n      type: legacyDecoratorSchemaType\n    }));\n  }\n  for (const annotationMarkDef of annotationMarkDefs) {\n    const legacyAnnotationSchemaType = legacySchema.annotations.find((t) => t.name === annotationMarkDef._type);\n    legacyAnnotationSchemaType && (block && path && props.renderAnnotation ? children = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ref: spanRef, children: props.renderAnnotation({\n      block,\n      children,\n      editorElementRef: spanRef,\n      focused,\n      path,\n      selected,\n      schemaType: legacyAnnotationSchemaType,\n      value: annotationMarkDef,\n      type: legacyAnnotationSchemaType\n    }) }) : children = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ref: spanRef, children }));\n  }\n  if (block && path && props.renderChild) {\n    const child = block.children.find((_child) => _child._key === props.leaf._key);\n    child && (children = props.renderChild({\n      annotations: annotationMarkDefs,\n      children,\n      editorElementRef: spanRef,\n      focused,\n      path,\n      schemaType: legacySchema.span,\n      selected,\n      value: child,\n      type: legacySchema.span\n    }));\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ...props.attributes, ref: spanRef, children });\n}\nconst PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n};\nfunction RenderLeaf(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(12), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), schema = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, _temp);\n  if (props.leaf._type !== schema.span.name)\n    return props.children;\n  let t0;\n  $[0] !== props ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderSpan, { ...props }), $[0] = props, $[1] = t0) : t0 = $[1];\n  let renderedSpan = t0;\n  if (props.renderPlaceholder && props.leaf.placeholder && props.text.text === \"\") {\n    let t1;\n    $[2] !== props.renderPlaceholder ? (t1 = props.renderPlaceholder(), $[2] = props.renderPlaceholder, $[3] = t1) : t1 = $[3];\n    let t2;\n    $[4] !== t1 ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: t1 }), $[4] = t1, $[5] = t2) : t2 = $[5];\n    let t3;\n    return $[6] !== renderedSpan || $[7] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [\n      t2,\n      renderedSpan\n    ] }), $[6] = renderedSpan, $[7] = t2, $[8] = t3) : t3 = $[8], t3;\n  }\n  const rangeDecoration = props.leaf.rangeDecoration;\n  if (rangeDecoration) {\n    let t1;\n    $[9] !== rangeDecoration || $[10] !== renderedSpan ? (t1 = rangeDecoration.component({\n      children: renderedSpan\n    }), $[9] = rangeDecoration, $[10] = renderedSpan, $[11] = t1) : t1 = $[11], renderedSpan = t1;\n  }\n  return renderedSpan;\n}\nfunction _temp(s) {\n  return s.context.schema;\n}\nfunction RenderText(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5);\n  let t0;\n  return $[0] !== props.attributes || $[1] !== props.children || $[2] !== props.text._key || $[3] !== props.text._type ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { ...props.attributes, \"data-child-key\": props.text._key, \"data-child-name\": props.text._type, \"data-child-type\": \"span\", children: props.children }), $[0] = props.attributes, $[1] = props.children, $[2] = props.text._key, $[3] = props.text._type, $[4] = t0) : t0 = $[4], t0;\n}\nconst debug$1 = debugWithName(\"plugin:withHotKeys\");\nfunction createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions ?? {};\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$1(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({\n                  type: \"behavior event\",\n                  behaviorEvent: {\n                    type: \"decorator.toggle\",\n                    decorator: mark\n                  },\n                  editor\n                });\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n    }, editor;\n  };\n}\nconst slateOperationCallback = ({\n  input,\n  sendBack\n}) => {\n  const originalApply = input.slateEditor.apply;\n  return input.slateEditor.apply = (op) => {\n    op.type !== \"set_selection\" && sendBack({\n      type: \"slate operation\",\n      operation: op\n    }), originalApply(op);\n  }, () => {\n    input.slateEditor.apply = originalApply;\n  };\n}, rangeDecorationsMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_33__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {}\n  },\n  actions: {\n    \"update pending range decorations\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      pendingRangeDecorations: ({\n        context,\n        event\n      }) => event.type !== \"range decorations updated\" ? context.pendingRangeDecorations : event.rangeDecorations\n    }),\n    \"set up initial range decorations\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      decoratedRanges: ({\n        context\n      }) => {\n        const rangeDecorationState = [];\n        for (const rangeDecoration of context.pendingRangeDecorations) {\n          const slateRange = toSlateRange(rangeDecoration.selection, context.slateEditor);\n          if (!slate__WEBPACK_IMPORTED_MODULE_20__.Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: \"local\"\n            });\n            continue;\n          }\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange\n          });\n        }\n        return rangeDecorationState;\n      }\n    }),\n    \"update range decorations\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      decoratedRanges: ({\n        context,\n        event\n      }) => {\n        if (event.type !== \"range decorations updated\")\n          return context.decoratedRanges;\n        const rangeDecorationState = [];\n        for (const rangeDecoration of event.rangeDecorations) {\n          const slateRange = toSlateRange(rangeDecoration.selection, context.slateEditor);\n          if (!slate__WEBPACK_IMPORTED_MODULE_20__.Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: \"local\"\n            });\n            continue;\n          }\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange\n          });\n        }\n        return rangeDecorationState;\n      }\n    }),\n    \"move range decorations\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      decoratedRanges: ({\n        context,\n        event\n      }) => {\n        if (event.type !== \"slate operation\")\n          return context.decoratedRanges;\n        const rangeDecorationState = [];\n        for (const decoratedRange of context.decoratedRanges) {\n          const slateRange = toSlateRange(decoratedRange.rangeDecoration.selection, context.slateEditor);\n          if (!slate__WEBPACK_IMPORTED_MODULE_20__.Range.isRange(slateRange)) {\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: \"local\"\n            });\n            continue;\n          }\n          let newRange;\n          if (newRange = moveRangeByOperation(slateRange, event.operation), newRange && newRange !== slateRange || newRange === null && slateRange) {\n            const newRangeSelection = newRange ? slateRangeToSelection({\n              schema: context.schema,\n              editor: context.slateEditor,\n              range: newRange\n            }) : null;\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: newRangeSelection,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: \"local\"\n            });\n          }\n          newRange !== null && rangeDecorationState.push({\n            ...newRange || slateRange,\n            rangeDecoration: {\n              ...decoratedRange.rangeDecoration,\n              selection: slateRangeToSelection({\n                schema: context.schema,\n                editor: context.slateEditor,\n                range: newRange\n              })\n            }\n          });\n        }\n        return rangeDecorationState;\n      }\n    }),\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      readOnly: ({\n        context,\n        event\n      }) => event.type !== \"update read only\" ? context.readOnly : event.readOnly\n    }),\n    \"increment update count\": (0,xstate__WEBPACK_IMPORTED_MODULE_34__.a)({\n      updateCount: ({\n        context\n      }) => context.updateCount + 1\n    })\n  },\n  actors: {\n    \"slate operation listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_35__.fromCallback)(slateOperationCallback)\n  },\n  guards: {\n    \"has pending range decorations\": ({\n      context\n    }) => context.pendingRangeDecorations.length > 0,\n    \"has range decorations\": ({\n      context\n    }) => context.decoratedRanges.length > 0,\n    \"has different decorations\": ({\n      context,\n      event\n    }) => {\n      if (event.type !== \"range decorations updated\")\n        return !1;\n      const existingRangeDecorations = context.decoratedRanges.map((decoratedRange) => ({\n        anchor: decoratedRange.rangeDecoration.selection?.anchor,\n        focus: decoratedRange.rangeDecoration.selection?.focus\n      })), newRangeDecorations = event.rangeDecorations.map((rangeDecoration) => ({\n        anchor: rangeDecoration.selection?.anchor,\n        focus: rangeDecoration.selection?.focus\n      }));\n      return !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_5__(existingRangeDecorations, newRangeDecorations);\n    },\n    \"not read only\": ({\n      context\n    }) => !context.readOnly,\n    \"should skip setup\": ({\n      context\n    }) => context.skipSetup\n  }\n}).createMachine({\n  id: \"range decorations\",\n  context: ({\n    input\n  }) => ({\n    readOnly: input.readOnly,\n    pendingRangeDecorations: input.rangeDecorations,\n    decoratedRanges: [],\n    skipSetup: input.skipSetup,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n    updateCount: 0\n  }),\n  invoke: {\n    src: \"slate operation listener\",\n    input: ({\n      context\n    }) => ({\n      slateEditor: context.slateEditor\n    })\n  },\n  on: {\n    \"update read only\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  initial: \"setting up\",\n  states: {\n    \"setting up\": {\n      always: [{\n        guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.D)([\"should skip setup\", \"has pending range decorations\"]),\n        target: \"ready\",\n        actions: [\"set up initial range decorations\", \"increment update count\"]\n      }, {\n        guard: \"should skip setup\",\n        target: \"ready\"\n      }],\n      on: {\n        \"range decorations updated\": {\n          actions: [\"update pending range decorations\"]\n        },\n        ready: [{\n          target: \"ready\",\n          guard: \"has pending range decorations\",\n          actions: [\"set up initial range decorations\", \"increment update count\"]\n        }, {\n          target: \"ready\"\n        }]\n      }\n    },\n    ready: {\n      initial: \"idle\",\n      on: {\n        \"range decorations updated\": {\n          target: \".idle\",\n          guard: \"has different decorations\",\n          actions: [\"update range decorations\", \"increment update count\"]\n        }\n      },\n      states: {\n        idle: {\n          on: {\n            \"slate operation\": {\n              target: \"moving range decorations\",\n              guard: (0,xstate__WEBPACK_IMPORTED_MODULE_36__.D)([\"has range decorations\", \"not read only\"])\n            }\n          }\n        },\n        \"moving range decorations\": {\n          entry: [\"move range decorations\"],\n          always: {\n            target: \"idle\"\n          }\n        }\n      }\n    }\n  }\n});\nfunction createDecorate(rangeDecorationActor) {\n  return function([node, path]) {\n    if (isEqualToEmptyEditor(rangeDecorationActor.getSnapshot().context.slateEditor.children, rangeDecorationActor.getSnapshot().context.schema))\n      return [{\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        },\n        placeholder: !0\n      }];\n    if (path.length === 0)\n      return [];\n    if (!slate__WEBPACK_IMPORTED_MODULE_20__.Element.isElement(node) || node.children.length === 0)\n      return [];\n    const blockIndex = path.at(0);\n    return blockIndex === void 0 ? [] : rangeDecorationActor.getSnapshot().context.decoratedRanges.filter((decoratedRange) => slate__WEBPACK_IMPORTED_MODULE_20__.Range.isCollapsed(decoratedRange) ? node.children.some((_, childIndex) => slate__WEBPACK_IMPORTED_MODULE_20__.Path.equals(decoratedRange.anchor.path, [blockIndex, childIndex]) && slate__WEBPACK_IMPORTED_MODULE_20__.Path.equals(decoratedRange.focus.path, [blockIndex, childIndex])) : slate__WEBPACK_IMPORTED_MODULE_20__.Range.intersection(decoratedRange, {\n      anchor: {\n        path,\n        offset: 0\n      },\n      focus: {\n        path,\n        offset: 0\n      }\n    }) || slate__WEBPACK_IMPORTED_MODULE_20__.Range.includes(decoratedRange, path));\n  };\n}\nconst debug = debugWithName(\"component:Editable\"), PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, portableTextEditor = usePortableTextEditor(), ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(forwardedRef, () => ref.current);\n  const editorActor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(EditorActorContext), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(editorActor, (s) => s.matches({\n    \"edit mode\": \"read only\"\n  })), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_26__.useSlate)(), rangeDecorationsActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useActorRef)(rangeDecorationsMachine, {\n    input: {\n      rangeDecorations: rangeDecorations ?? [],\n      readOnly,\n      schema: editorActor.getSnapshot().context.schema,\n      slateEditor,\n      skipSetup: !editorActor.getSnapshot().matches({\n        setup: \"setting up\"\n      })\n    }\n  });\n  (0,_xstate_react__WEBPACK_IMPORTED_MODULE_27__.useSelector)(rangeDecorationsActor, (s_0) => s_0.context.updateCount);\n  const decorate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => createDecorate(rangeDecorationsActor), [rangeDecorationsActor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    rangeDecorationsActor.send({\n      type: \"update read only\",\n      readOnly\n    });\n  }, [rangeDecorationsActor, readOnly]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    rangeDecorationsActor.send({\n      type: \"range decorations updated\",\n      rangeDecorations: rangeDecorations ?? []\n    });\n  }, [rangeDecorationsActor, rangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => readOnly ? slateEditor : createWithHotkeys(editorActor, portableTextEditor, hotkeys)(slateEditor), [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor]);\n  const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderElement, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, spellCheck }), [spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((leafProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderLeaf, { ...leafProps, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder }), [readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder]), renderText = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((props_0) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderText, { ...props_0 }), []), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, editorActor.getSnapshot().context.schema.block.name));\n      if (normalizedSelection !== null) {\n        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = toSlateRange(normalizedSelection, slateEditor);\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === \"set_selection\") || editorActor.send({\n          type: \"notify.selection\",\n          selection: normalizedSelection\n        }), slateEditor.onChange());\n      }\n    }\n  }, [editorActor, propsSelection, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const onReady = editorActor.on(\"ready\", () => {\n      rangeDecorationsActor.send({\n        type: \"ready\"\n      }), restoreSelectionFromProps();\n    }), onInvalidValue = editorActor.on(\"invalid value\", () => {\n      setHasInvalidValue(!0);\n    }), onValueChanged = editorActor.on(\"value changed\", () => {\n      setHasInvalidValue(!1);\n    });\n    return () => {\n      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n    };\n  }, [rangeDecorationsActor, editorActor, restoreSelectionFromProps]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);\n  const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {\n    if (onCopy)\n      onCopy(event) !== void 0 && event.preventDefault();\n    else if (event.nativeEvent.clipboardData) {\n      event.stopPropagation(), event.preventDefault();\n      const selection = slateEditor.selection ? slateRangeToSelection({\n        schema: editorActor.getSnapshot().context.schema,\n        editor: slateEditor,\n        range: slateEditor.selection\n      }) : void 0, position = selection ? {\n        selection\n      } : void 0;\n      if (!position) {\n        console.warn(\"Could not find position for copy event\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"clipboard.copy\",\n          originEvent: {\n            dataTransfer: event.nativeEvent.clipboardData\n          },\n          position\n        },\n        editor: slateEditor,\n        nativeEvent: event\n      });\n    }\n  }, [onCopy, editorActor, slateEditor]), handleCut = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_0) => {\n    if (onCut)\n      onCut(event_0) !== void 0 && event_0.preventDefault();\n    else if (event_0.nativeEvent.clipboardData) {\n      event_0.stopPropagation(), event_0.preventDefault();\n      const selection_0 = editorActor.getSnapshot().context.selection, position_0 = selection_0 ? {\n        selection: selection_0\n      } : void 0;\n      if (!position_0) {\n        console.warn(\"Could not find position for cut event\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"clipboard.cut\",\n          originEvent: {\n            dataTransfer: event_0.nativeEvent.clipboardData\n          },\n          position: position_0\n        },\n        editor: slateEditor,\n        nativeEvent: event_0\n      });\n    }\n  }, [onCut, editorActor, slateEditor]), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_1) => {\n    const value = fromSlateValue(slateEditor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor)), path = (slateEditor.selection ? slateRangeToSelection({\n      schema: editorActor.getSnapshot().context.schema,\n      editor: slateEditor,\n      range: slateEditor.selection\n    }) : null)?.focus.path || [], onPasteResult = onPaste?.({\n      event: event_1,\n      value,\n      path,\n      schemaTypes: portableTextEditor.schemaTypes\n    });\n    if (onPasteResult || !slateEditor.selection)\n      event_1.preventDefault(), editorActor.send({\n        type: \"notify.loading\"\n      }), Promise.resolve(onPasteResult).then((result_1) => {\n        if (debug(\"Custom paste function from client resolved\", result_1), !result_1 || !result_1.insert) {\n          debug(\"No result from custom paste handler, pasting normally\");\n          const selection_1 = editorActor.getSnapshot().context.selection, position_1 = selection_1 ? {\n            selection: selection_1\n          } : void 0;\n          if (!position_1) {\n            console.warn(\"Could not find position for paste event\");\n            return;\n          }\n          editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n              type: \"clipboard.paste\",\n              originEvent: {\n                dataTransfer: event_1.clipboardData\n              },\n              position: position_1\n            },\n            editor: slateEditor,\n            nativeEvent: event_1\n          });\n        } else result_1.insert ? editorActor.send({\n          type: \"behavior event\",\n          behaviorEvent: {\n            type: \"insert.blocks\",\n            blocks: (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_18__.parseBlocks)({\n              context: {\n                keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n                schema: editorActor.getSnapshot().context.schema\n              },\n              blocks: result_1.insert,\n              options: {\n                refreshKeys: !0,\n                validateFields: !0\n              }\n            }),\n            placement: \"auto\"\n          },\n          editor: slateEditor\n        }) : console.warn(\"Your onPaste function returned something unexpected:\", result_1);\n      }).catch((error) => (console.warn(error), error)).finally(() => {\n        editorActor.send({\n          type: \"notify.done loading\"\n        });\n      });\n    else if (event_1.nativeEvent.clipboardData) {\n      event_1.preventDefault(), event_1.stopPropagation();\n      const selection_2 = editorActor.getSnapshot().context.selection, position_2 = selection_2 ? {\n        selection: selection_2\n      } : void 0;\n      if (!position_2) {\n        console.warn(\"Could not find position for paste event\");\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"clipboard.paste\",\n          originEvent: {\n            dataTransfer: event_1.nativeEvent.clipboardData\n          },\n          position: position_2\n        },\n        editor: slateEditor,\n        nativeEvent: event_1\n      });\n    }\n    debug(\"No result from custom paste handler, pasting normally\");\n  }, [editorActor, onPaste, portableTextEditor, slateEditor]), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_2) => {\n    if (onFocus && onFocus(event_2), !event_2.isDefaultPrevented()) {\n      const selection_3 = PortableTextEditor.getSelection(portableTextEditor);\n      selection_3 === null && (slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_20__.Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({\n        type: \"notify.focused\",\n        event: event_2\n      });\n      const newSelection = PortableTextEditor.getSelection(portableTextEditor);\n      selection_3 === newSelection && editorActor.send({\n        type: \"notify.selection\",\n        selection: selection_3\n      });\n    }\n  }, [editorActor, onFocus, slateEditor, portableTextEditor]), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_3) => {\n    if (onClick && onClick(event_3), event_3.isDefaultPrevented() || event_3.isPropagationStopped())\n      return;\n    const position_3 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_3.nativeEvent\n    });\n    position_3 && editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"mouse.click\",\n        position: position_3\n      },\n      editor: slateEditor,\n      nativeEvent: event_3\n    });\n  }, [onClick, editorActor, slateEditor]), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_4) => {\n    onBlur && onBlur(event_4), event_4.isPropagationStopped() || editorActor.send({\n      type: \"notify.blurred\",\n      event: event_4\n    });\n  }, [editorActor, onBlur]), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_5) => {\n    onBeforeInput && onBeforeInput(event_5);\n  }, [onBeforeInput]), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (!slateEditor.selection)\n      return;\n    const root = slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.findDocumentOrShadowRoot(slateEditor), {\n      activeElement\n    } = root;\n    if (ref.current !== activeElement)\n      return;\n    const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.getWindow(slateEditor).getSelection();\n    if (!domSelection || domSelection.rangeCount === 0)\n      return;\n    const existingDOMRange = domSelection.getRangeAt(0);\n    try {\n      const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n    } catch {\n      debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_20__.Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();\n    }\n  }, [ref, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection);\n      return mutationObserver.observe(editableElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, [validateSelection, editableElement]);\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_6) => {\n    props.onKeyDown && props.onKeyDown(event_6), event_6.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_6), event_6.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"keyboard.keydown\",\n        originEvent: {\n          key: event_6.key,\n          code: event_6.code,\n          altKey: event_6.altKey,\n          ctrlKey: event_6.ctrlKey,\n          metaKey: event_6.metaKey,\n          shiftKey: event_6.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_6\n    });\n  }, [props, editorActor, slateEditor]), handleKeyUp = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_7) => {\n    props.onKeyUp && props.onKeyUp(event_7), event_7.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"keyboard.keyup\",\n        originEvent: {\n          key: event_7.key,\n          code: event_7.code,\n          altKey: event_7.altKey,\n          ctrlKey: event_7.ctrlKey,\n          metaKey: event_7.metaKey,\n          shiftKey: event_7.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_7\n    });\n  }, [props, editorActor, slateEditor]), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    if (scrollSelectionIntoView !== void 0)\n      return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ : (_editor, domRange) => {\n        scrollSelectionIntoView(portableTextEditor, domRange);\n      };\n  }, [portableTextEditor, scrollSelectionIntoView]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ref.current = slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n  }, [slateEditor, ref]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const window_0 = slate_react__WEBPACK_IMPORTED_MODULE_26__.ReactEditor.getWindow(slateEditor), onDragEnd_0 = () => {\n      editorActor.send({\n        type: \"dragend\"\n      });\n    }, onDrop_0 = () => {\n      editorActor.send({\n        type: \"drop\"\n      });\n    };\n    return window_0.document.addEventListener(\"dragend\", onDragEnd_0), window_0.document.addEventListener(\"drop\", onDrop_0), () => {\n      window_0.document.removeEventListener(\"dragend\", onDragEnd_0), window_0.document.removeEventListener(\"drop\", onDrop_0);\n    };\n  }, [slateEditor, editorActor]);\n  const handleDragStart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_8) => {\n    if (onDragStart?.(event_8), event_8.isDefaultPrevented() || event_8.isPropagationStopped())\n      return;\n    const position_4 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_8.nativeEvent\n    });\n    if (!position_4) {\n      console.warn(\"Could not find position for dragstart event\");\n      return;\n    }\n    const snapshot = getEditorSnapshot({\n      editorActorSnapshot: editorActor.getSnapshot(),\n      slateEditorInstance: slateEditor\n    }), dragSelection = getDragSelection({\n      eventSelection: position_4.selection,\n      snapshot\n    }), selectingEntireBlocks = (0,_chunks_es_selector_is_selecting_entire_blocks_js__WEBPACK_IMPORTED_MODULE_16__.isSelectingEntireBlocks)({\n      context: {\n        ...snapshot.context,\n        selection: dragSelection\n      }\n    }), dragGhost = document.createElement(\"div\"), draggedDomNodes = getSelectionDomNodes({\n      snapshot: {\n        context: {\n          ...snapshot.context,\n          selection: dragSelection\n        }\n      },\n      slateEditor\n    });\n    if (selectingEntireBlocks) {\n      const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) => node.cloneNode(!0));\n      for (const block of clonedBlockNodes)\n        block instanceof HTMLElement && (block.style.position = \"relative\"), dragGhost.appendChild(block);\n      const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n      if (customGhost && dragGhost.replaceChildren(customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost), customGhost) {\n        const customGhostRect = customGhost.getBoundingClientRect(), x = event_8.clientX - customGhostRect.left, y = event_8.clientY - customGhostRect.top;\n        dragGhost.style.width = `${customGhostRect.width}px`, dragGhost.style.height = `${customGhostRect.height}px`, event_8.dataTransfer.setDragImage(dragGhost, x, y);\n      } else {\n        const blocksDomRect = getCompoundClientRect(draggedDomNodes.blockNodes), x_0 = event_8.clientX - blocksDomRect.left, y_0 = event_8.clientY - blocksDomRect.top;\n        dragGhost.style.width = `${blocksDomRect.width}px`, dragGhost.style.height = `${blocksDomRect.height}px`, event_8.dataTransfer.setDragImage(dragGhost, x_0, y_0);\n      }\n    } else {\n      const clonedChildNodes = draggedDomNodes.childNodes.map((node_0) => node_0.cloneNode(!0));\n      for (const child of clonedChildNodes)\n        dragGhost.appendChild(child);\n      dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n      const childrenDomRect = getCompoundClientRect(draggedDomNodes.childNodes), x_1 = event_8.clientX - childrenDomRect.left, y_1 = event_8.clientY - childrenDomRect.top;\n      dragGhost.style.width = `${childrenDomRect.width}px`, dragGhost.style.height = `${childrenDomRect.height}px`, event_8.dataTransfer.setDragImage(dragGhost, x_1, y_1);\n    }\n    return editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"select\",\n        at: (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.isSelectionCollapsed)(dragSelection) ? dragSelection : {\n          anchor: (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionEndPoint)(dragSelection),\n          focus: (0,_chunks_es_util_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_21__.getSelectionEndPoint)(dragSelection),\n          backward: !1\n        }\n      },\n      editor: slateEditor\n    }), editorActor.send({\n      type: \"dragstart\",\n      origin: {\n        selection: dragSelection\n      },\n      ghost: dragGhost\n    }), editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"drag.dragstart\",\n        originEvent: {\n          dataTransfer: event_8.dataTransfer\n        },\n        position: {\n          selection: dragSelection\n        }\n      },\n      editor: slateEditor\n    }), !0;\n  }, [onDragStart, editorActor, slateEditor]), handleDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_9) => {\n    if (onDrag?.(event_9), !(event_9.isDefaultPrevented() || event_9.isPropagationStopped() || !getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_9.nativeEvent\n    })))\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.drag\",\n          originEvent: {\n            dataTransfer: event_9.dataTransfer\n          }\n        },\n        editor: slateEditor\n      }), !0;\n  }, [onDrag, editorActor, slateEditor]), handleDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_10) => {\n    if (onDragEnd?.(event_10), !(event_10.isDefaultPrevented() || event_10.isPropagationStopped()))\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragend\",\n          originEvent: {\n            dataTransfer: event_10.dataTransfer\n          }\n        },\n        editor: slateEditor\n      }), !0;\n  }, [onDragEnd, editorActor, slateEditor]), handleDragEnter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_11) => {\n    if (onDragEnter?.(event_11), event_11.isDefaultPrevented() || event_11.isPropagationStopped())\n      return;\n    const position_6 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_11.nativeEvent\n    });\n    if (position_6)\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragenter\",\n          originEvent: {\n            dataTransfer: event_11.dataTransfer\n          },\n          position: position_6\n        },\n        editor: slateEditor\n      }), !0;\n  }, [onDragEnter, editorActor, slateEditor]), handleDragOver = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_12) => {\n    if (onDragOver?.(event_12), event_12.isDefaultPrevented() || event_12.isPropagationStopped())\n      return;\n    const position_7 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_12.nativeEvent\n    });\n    if (position_7)\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragover\",\n          originEvent: {\n            dataTransfer: event_12.dataTransfer\n          },\n          position: position_7\n        },\n        editor: slateEditor,\n        nativeEvent: event_12\n      }), !0;\n  }, [onDragOver, editorActor, slateEditor]), handleDrop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_13) => {\n    if (onDrop?.(event_13), event_13.isDefaultPrevented() || event_13.isPropagationStopped())\n      return;\n    const position_8 = getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_13.nativeEvent\n    });\n    if (!position_8) {\n      console.warn(\"Could not find position for drop event\");\n      return;\n    }\n    return editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"drag.drop\",\n        originEvent: {\n          dataTransfer: event_13.dataTransfer\n        },\n        position: position_8\n      },\n      editor: slateEditor,\n      nativeEvent: event_13\n    }), !0;\n  }, [onDrop, editorActor, slateEditor]), handleDragLeave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event_14) => {\n    if (onDragLeave?.(event_14), !(event_14.isDefaultPrevented() || event_14.isPropagationStopped() || !getEventPosition({\n      editorActor,\n      slateEditor,\n      event: event_14.nativeEvent\n    })))\n      return editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"drag.dragleave\",\n          originEvent: {\n            dataTransfer: event_14.dataTransfer\n          }\n        },\n        editor: slateEditor\n      }), !0;\n  }, [onDragLeave, editorActor, slateEditor]);\n  return portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\n    slate_react__WEBPACK_IMPORTED_MODULE_26__.Editable,\n    {\n      ...restProps,\n      \"data-read-only\": readOnly,\n      autoFocus: !1,\n      className: restProps.className || \"pt-editable\",\n      decorate,\n      onBlur: handleOnBlur,\n      onCopy: handleCopy,\n      onCut: handleCut,\n      onClick: handleClick,\n      onDOMBeforeInput: handleOnBeforeInput,\n      onDragStart: handleDragStart,\n      onDrag: handleDrag,\n      onDragEnd: handleDragEnd,\n      onDragEnter: handleDragEnter,\n      onDragOver: handleDragOver,\n      onDrop: handleDrop,\n      onDragLeave: handleDragLeave,\n      onFocus: handleOnFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onPaste: handlePaste,\n      readOnly,\n      renderPlaceholder: void 0,\n      renderElement,\n      renderLeaf,\n      renderText,\n      scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }\n  ) : null;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nfunction useConstant(factory) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  return ref.current || (ref.current = {\n    constant: factory()\n  }), ref.current.constant;\n}\nfunction EditorProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(31);\n  let t0;\n  $[0] !== props.initialConfig ? (t0 = () => {\n    const internalEditor = createInternalEditor(props.initialConfig), portableTextEditor = new PortableTextEditor({\n      editor: internalEditor.editor\n    });\n    return {\n      internalEditor,\n      portableTextEditor\n    };\n  }, $[0] = props.initialConfig, $[1] = t0) : t0 = $[1];\n  const {\n    internalEditor: internalEditor_0,\n    portableTextEditor: portableTextEditor_0\n  } = useConstant(t0);\n  let t1;\n  $[2] !== internalEditor_0.actors.editorActor || $[3] !== internalEditor_0.actors.mutationActor || $[4] !== internalEditor_0.actors.syncActor || $[5] !== internalEditor_0.subscriptions ? (t1 = () => {\n    const unsubscribers = [];\n    for (const subscription of internalEditor_0.subscriptions)\n      unsubscribers.push(subscription());\n    return internalEditor_0.actors.editorActor.start(), internalEditor_0.actors.mutationActor.start(), internalEditor_0.actors.syncActor.start(), () => {\n      for (const unsubscribe of unsubscribers)\n        unsubscribe();\n      stopActor(internalEditor_0.actors.editorActor), stopActor(internalEditor_0.actors.mutationActor), stopActor(internalEditor_0.actors.syncActor);\n    };\n  }, $[2] = internalEditor_0.actors.editorActor, $[3] = internalEditor_0.actors.mutationActor, $[4] = internalEditor_0.actors.syncActor, $[5] = internalEditor_0.subscriptions, $[6] = t1) : t1 = $[6];\n  let t2;\n  $[7] !== internalEditor_0 ? (t2 = [internalEditor_0], $[7] = internalEditor_0, $[8] = t2) : t2 = $[8], (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t1, t2);\n  let t3;\n  $[9] !== portableTextEditor_0.change$ ? (t3 = (change) => {\n    portableTextEditor_0.change$.next(change);\n  }, $[9] = portableTextEditor_0.change$, $[10] = t3) : t3 = $[10];\n  let t4;\n  $[11] !== internalEditor_0.actors.editorActor || $[12] !== t3 ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RouteEventsToChanges, { editorActor: internalEditor_0.actors.editorActor, onChange: t3 }), $[11] = internalEditor_0.actors.editorActor, $[12] = t3, $[13] = t4) : t4 = $[13];\n  let t5;\n  $[14] !== internalEditor_0.actors.editorActor || $[15] !== props.children ? (t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorSelectionProvider, { editorActor: internalEditor_0.actors.editorActor, children: props.children }), $[14] = internalEditor_0.actors.editorActor, $[15] = props.children, $[16] = t5) : t5 = $[16];\n  let t6;\n  $[17] !== portableTextEditor_0 || $[18] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PortableTextEditorContext.Provider, { value: portableTextEditor_0, children: t5 }), $[17] = portableTextEditor_0, $[18] = t5, $[19] = t6) : t6 = $[19];\n  let t7;\n  $[20] !== internalEditor_0.editor._internal.slateEditor.initialValue || $[21] !== internalEditor_0.editor._internal.slateEditor.instance || $[22] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_26__.Slate, { editor: internalEditor_0.editor._internal.slateEditor.instance, initialValue: internalEditor_0.editor._internal.slateEditor.initialValue, children: t6 }), $[20] = internalEditor_0.editor._internal.slateEditor.initialValue, $[21] = internalEditor_0.editor._internal.slateEditor.instance, $[22] = t6, $[23] = t7) : t7 = $[23];\n  let t8;\n  $[24] !== internalEditor_0.actors.editorActor || $[25] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EditorActorContext.Provider, { value: internalEditor_0.actors.editorActor, children: t7 }), $[24] = internalEditor_0.actors.editorActor, $[25] = t7, $[26] = t8) : t8 = $[26];\n  let t9;\n  return $[27] !== internalEditor_0.editor || $[28] !== t4 || $[29] !== t8 ? (t9 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_14__.EditorContext.Provider, { value: internalEditor_0.editor, children: [\n    t4,\n    t8\n  ] }), $[27] = internalEditor_0.editor, $[28] = t4, $[29] = t8, $[30] = t9) : t9 = $[30], t9;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUM4SDtBQUN2SDtBQUNvQjtBQUNkO0FBQ0M7QUFDdkI7QUFDdUg7QUFDNUM7QUFDakY7QUFDZ0c7QUFDNEw7QUFDdUg7QUFDMUY7QUFDcFM7QUFDZ0o7QUFDeko7QUFDMEU7QUFDOUQ7QUFDa0I7QUFDcEM7QUFDSDtBQUNTO0FBQ2tHO0FBQ2pGO0FBQ1Y7QUFDd0U7QUFDdkY7QUFDZ0I7QUFDVjtBQUNFO0FBQ047QUFDbUU7QUFDNUQ7QUFDVztBQUNwRDtBQUNBLFlBQVkseURBQUMsY0FBYyxvRUFBUyxTQUFTLGlFQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtGQUFrRixnREFBUztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBTztBQUNQO0FBQ0EsdUJBQXVCLFNBQVMsRUFBRSxLQUFLO0FBQ3ZDLFNBQVMsa0NBQU8sSUFBSSwwQ0FBZSxjQUFjLGtDQUFPLGNBQWMsa0NBQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLHdHQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFDQUFxQyxtR0FBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNCQUFzQixnR0FBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQiwyRkFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksb0ZBQWtCO0FBQzlCO0FBQ0E7QUFDQSxL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SCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFLDhDQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxFQUFFLDhDQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsOENBQVUsMENBQTBDLDhDQUFVO0FBQy9FLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDLGVBQWUsbUJBQW1CLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMENBQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTBEO0FBQ3JMO0FBQ0EsbUdBQW1HLHVEQUFJLENBQUMsb0VBQWEsYUFBYTtBQUNsSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvaW5kZXguanM/MDE0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjIH0gZnJvbSBcInJlYWN0LWNvbXBpbGVyLXJ1bnRpbWVcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VSZWYsIHN0YXJ0VHJhbnNpdGlvbiwgQ29tcG9uZW50LCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0RXZlbnQgfSBmcm9tIFwidXNlLWVmZmVjdC1ldmVudFwiO1xuaW1wb3J0IHsgdXNlRWRpdG9yLCBFZGl0b3JDb250ZXh0IH0gZnJvbSBcIi4vX2NodW5rcy1lcy91c2UtZWRpdG9yLmpzXCI7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgdXNlQWN0b3JSZWYgfSBmcm9tIFwiQHhzdGF0ZS9yZWFjdFwiO1xuaW1wb3J0IG5vb3AgZnJvbSBcImxvZGFzaC9ub29wLmpzXCI7XG5pbXBvcnQgeyBFbGVtZW50IGFzIEVsZW1lbnQkMSwgVGV4dCwgUmFuZ2UsIEVkaXRvciwgTm9kZSwgUG9pbnQsIFRyYW5zZm9ybXMsIFBhdGgsIE9wZXJhdGlvbiwgZGVsZXRlQmFja3dhcmQsIGRlbGV0ZUZvcndhcmQsIGNyZWF0ZUVkaXRvciB9IGZyb20gXCJzbGF0ZVwiO1xuaW1wb3J0IHsgdXNlU2xhdGVTdGF0aWMsIHVzZVNlbGVjdGVkLCB3aXRoUmVhY3QsIFJlYWN0RWRpdG9yLCBTbGF0ZSwgdXNlU2xhdGUsIEVkaXRhYmxlIH0gZnJvbSBcInNsYXRlLXJlYWN0XCI7XG5pbXBvcnQgZGVidWckaSBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IGdldEJsb2NrRW5kUG9pbnQsIGlzRW1wdHlUZXh0QmxvY2ssIGlzRXF1YWxTZWxlY3Rpb25Qb2ludHMgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL3V0aWwuaXMtZXF1YWwtc2VsZWN0aW9uLXBvaW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0QmxvY2tTdGFydFBvaW50LCBpc0tleWVkU2VnbWVudCBhcyBpc0tleWVkU2VnbWVudCQxLCBwYXJzZUlubGluZU9iamVjdCwgcGFyc2VUZXh0QmxvY2ssIHBhcnNlQmxvY2tPYmplY3QsIHBhcnNlQmxvY2ssIHNsaWNlQmxvY2tzLCBpc1RleHRCbG9jaywgcGFyc2VBbm5vdGF0aW9uLCBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50LCBpc1NwYW4kMSBhcyBpc1NwYW4sIGlzTGlzdEJsb2NrLCBnZXRUZXh0QmxvY2tUZXh0LCBwYXJzZUJsb2NrcyB9IGZyb20gXCIuL19jaHVua3MtZXMvdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGlzU2VsZWN0aW9uQ29sbGFwc2VkLCBnZXRGb2N1c1RleHRCbG9jaywgZ2V0Rm9jdXNTcGFuLCBnZXRTZWxlY3RlZEJsb2NrcywgaXNTZWxlY3Rpb25FeHBhbmRlZCwgZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayBhcyBnZXRTZWxlY3Rpb25TdGFydEJsb2NrJDEsIGdldFNlbGVjdGlvbkVuZEJsb2NrIGFzIGdldFNlbGVjdGlvbkVuZEJsb2NrJDEsIGdldEZvY3VzQmxvY2sgYXMgZ2V0Rm9jdXNCbG9jayQxLCBnZXRGb2N1c0Jsb2NrT2JqZWN0LCBnZXRQcmV2aW91c0Jsb2NrLCBnZXROZXh0QmxvY2ssIGdldEZpcnN0QmxvY2sgYXMgZ2V0Rmlyc3RCbG9jayQxLCBnZXRMYXN0QmxvY2sgYXMgZ2V0TGFzdEJsb2NrJDEsIGdldEZvY3VzTGlzdEJsb2NrIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9zZWxlY3Rvci5pcy1zZWxlY3Rpb24tZXhwYW5kZWQuanNcIjtcbmltcG9ydCB7IGdldEZvY3VzSW5saW5lT2JqZWN0LCBpc092ZXJsYXBwaW5nU2VsZWN0aW9uLCBpc1NlbGVjdGluZ0VudGlyZUJsb2NrcywgZ2V0VHJpbW1lZFNlbGVjdGlvbiwgZ2V0Q2FyZXRXb3JkU2VsZWN0aW9uLCBpc0F0VGhlRW5kT2ZCbG9jaywgaXNBdFRoZVN0YXJ0T2ZCbG9jaywgaXNBY3RpdmVBbm5vdGF0aW9uLCBpc0FjdGl2ZURlY29yYXRvciwgZ2V0U2VsZWN0ZWRUZXh0QmxvY2tzLCBpc0FjdGl2ZUxpc3RJdGVtLCBpc0FjdGl2ZVN0eWxlLCBnZXRBY3RpdmVBbm5vdGF0aW9ucyB9IGZyb20gXCIuL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW5nLWVudGlyZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IERPTUVkaXRvciwgaXNET01Ob2RlIH0gZnJvbSBcInNsYXRlLWRvbVwiO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb25Db2xsYXBzZWQgYXMgaXNTZWxlY3Rpb25Db2xsYXBzZWQkMSwgc2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0LCBnZXRTZWxlY3Rpb25TdGFydFBvaW50LCBnZXRTZWxlY3Rpb25FbmRQb2ludCB9IGZyb20gXCIuL19jaHVua3MtZXMvdXRpbC5zZWxlY3Rpb24tcG9pbnQtdG8tYmxvY2stb2Zmc2V0LmpzXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB7IGlzS2V5U2VnbWVudCwgZGVmaW5lVHlwZSwgZGVmaW5lRmllbGQsIGlzUG9ydGFibGVUZXh0U3BhbiBhcyBpc1BvcnRhYmxlVGV4dFNwYW4kMSB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgZ2V0UmFuZG9tVmFsdWVzIGZyb20gXCJnZXQtcmFuZG9tLXZhbHVlcy1lc21cIjtcbmltcG9ydCB7IGRlZmluZUJlaGF2aW9yLCBmb3J3YXJkLCByYWlzZSB9IGZyb20gXCIuL2JlaGF2aW9ycy9pbmRleC5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gXCJAc2FuaXR5L3NjaGVtYVwiO1xuaW1wb3J0IHsgc2V0dXAsIGFzc2lnbiwgZW5xdWV1ZUFjdGlvbnMsIGVtaXQsIGFzc2VydEV2ZW50LCBzdGF0ZUluLCBmcm9tQ2FsbGJhY2ssIGFuZCwgbm90LCByYWlzZSBhcyByYWlzZSQxLCBjcmVhdGVBY3RvciB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IGh0bWxUb0Jsb2NrcyB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L2Jsb2NrLXRvb2xzXCI7XG5pbXBvcnQgeyB0b0hUTUwgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90by1odG1sXCI7XG5pbXBvcnQgeyBpbnNlcnQsIHVuc2V0LCBzZXQsIGRpZmZNYXRjaFBhdGNoIGFzIGRpZmZNYXRjaFBhdGNoJDEsIHNldElmTWlzc2luZywgYXBwbHlBbGwgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9wYXRjaGVzXCI7XG5pbXBvcnQgZ2V0IGZyb20gXCJsb2Rhc2gvZ2V0LmpzXCI7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSBcImxvZGFzaC9pc1VuZGVmaW5lZC5qc1wiO1xuaW1wb3J0IG9taXRCeSBmcm9tIFwibG9kYXNoL29taXRCeS5qc1wiO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSBcImxvZGFzaC9mbGF0dGVuLmpzXCI7XG5pbXBvcnQgb21pdCBmcm9tIFwibG9kYXNoL29taXQuanNcIjtcbmltcG9ydCB7IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uIH0gZnJvbSBcIi4vX2NodW5rcy1lcy91dGlsLmNoaWxkLXNlbGVjdGlvbi1wb2ludC10by1ibG9jay1vZmZzZXQuanNcIjtcbmltcG9ydCBzdGFydENhc2UgZnJvbSBcImxvZGFzaC5zdGFydGNhc2VcIjtcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1wiO1xuZnVuY3Rpb24gRWRpdG9yRXZlbnRMaXN0ZW5lcihwcm9wcykge1xuICBjb25zdCAkID0gYyg1KSwgZWRpdG9yID0gdXNlRWRpdG9yKCksIG9uID0gdXNlRWZmZWN0RXZlbnQocHJvcHMub24pO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBvbiA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3Iub24oXCIqXCIsIG9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IG9uLCAkWzJdID0gdDApIDogdDAgPSAkWzJdO1xuICBsZXQgdDE7XG4gIHJldHVybiAkWzNdICE9PSBlZGl0b3IgPyAodDEgPSBbZWRpdG9yXSwgJFszXSA9IGVkaXRvciwgJFs0XSA9IHQxKSA6IHQxID0gJFs0XSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb21wb3VuZENsaWVudFJlY3Qobm9kZXMpIHtcbiAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbmV3IERPTVJlY3QoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IGVsZW1lbnRzID0gbm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlIGluc3RhbmNlb2YgRWxlbWVudCksIGZpcnN0UmVjdCA9IGVsZW1lbnRzLmF0KDApPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgaWYgKCFmaXJzdFJlY3QpXG4gICAgcmV0dXJuIG5ldyBET01SZWN0KDAsIDAsIDAsIDApO1xuICBsZXQgbGVmdCA9IGZpcnN0UmVjdC5sZWZ0LCB0b3AgPSBmaXJzdFJlY3QudG9wLCByaWdodCA9IGZpcnN0UmVjdC5yaWdodCwgYm90dG9tID0gZmlyc3RSZWN0LmJvdHRvbTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50c1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgcmVjdC5sZWZ0KSwgdG9wID0gTWF0aC5taW4odG9wLCByZWN0LnRvcCksIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIHJlY3QucmlnaHQpLCBib3R0b20gPSBNYXRoLm1heChib3R0b20sIHJlY3QuYm90dG9tKTtcbiAgfVxuICByZXR1cm4gbmV3IERPTVJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG59XG5jb25zdCByb290TmFtZSA9IFwic2FuaXR5LXB0ZTpcIjtcbmRlYnVnJGkocm9vdE5hbWUpO1xuZnVuY3Rpb24gZGVidWdXaXRoTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGAke3Jvb3ROYW1lfSR7bmFtZX1gO1xuICByZXR1cm4gZGVidWckaSAmJiBkZWJ1ZyRpLmVuYWJsZWQobmFtZXNwYWNlKSA/IGRlYnVnJGkobmFtZXNwYWNlKSA6IGRlYnVnJGkocm9vdE5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RHJhZ1NlbGVjdGlvbih7XG4gIGV2ZW50U2VsZWN0aW9uLFxuICBzbmFwc2hvdFxufSkge1xuICBsZXQgZHJhZ1NlbGVjdGlvbiA9IGV2ZW50U2VsZWN0aW9uO1xuICBpZiAoZ2V0Rm9jdXNJbmxpbmVPYmplY3Qoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uXG4gICAgfVxuICB9KSlcbiAgICByZXR1cm4gZHJhZ1NlbGVjdGlvbjtcbiAgY29uc3QgZHJhZ2dpbmdDb2xsYXBzZWRTZWxlY3Rpb24gPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgY29udGV4dDoge1xuICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgIHNlbGVjdGlvbjogZXZlbnRTZWxlY3Rpb25cbiAgICB9XG4gIH0pLCBkcmFnZ2VkVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uXG4gICAgfVxuICB9KSwgZHJhZ2dlZFNwYW4gPSBnZXRGb2N1c1NwYW4oe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICBzZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uXG4gICAgfVxuICB9KTtcbiAgZHJhZ2dpbmdDb2xsYXBzZWRTZWxlY3Rpb24gJiYgZHJhZ2dlZFRleHRCbG9jayAmJiBkcmFnZ2VkU3BhbiAmJiAoZHJhZ1NlbGVjdGlvbiA9IHtcbiAgICBhbmNob3I6IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IGRyYWdnZWRUZXh0QmxvY2tcbiAgICB9KSxcbiAgICBmb2N1czogZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IGRyYWdnZWRUZXh0QmxvY2tcbiAgICB9KVxuICB9KTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBnZXRTZWxlY3RlZEJsb2NrcyhzbmFwc2hvdCk7XG4gIGlmIChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiBpc1NlbGVjdGlvbkV4cGFuZGVkKHNuYXBzaG90KSAmJiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRCbG9jayA9IGdldFNlbGVjdGlvblN0YXJ0QmxvY2skMShzbmFwc2hvdCksIHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2skMShzbmFwc2hvdCk7XG4gICAgaWYgKCFzZWxlY3Rpb25TdGFydEJsb2NrIHx8ICFzZWxlY3Rpb25FbmRCbG9jaylcbiAgICAgIHJldHVybiBkcmFnU2VsZWN0aW9uO1xuICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBzZWxlY3Rpb25TdGFydEJsb2NrXG4gICAgfSksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IHNlbGVjdGlvbkVuZEJsb2NrXG4gICAgfSk7XG4gICAgaXNPdmVybGFwcGluZ1NlbGVjdGlvbihldmVudFNlbGVjdGlvbikoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgICAgICAgICBmb2N1czogc2VsZWN0aW9uRW5kUG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pICYmIChkcmFnU2VsZWN0aW9uID0ge1xuICAgICAgYW5jaG9yOiBzZWxlY3Rpb25TdGFydFBvaW50LFxuICAgICAgZm9jdXM6IHNlbGVjdGlvbkVuZFBvaW50XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRyYWdTZWxlY3Rpb247XG59XG5jb25zdCBWT0lEX0NISUxEX0tFWSA9IFwidm9pZC1jaGlsZFwiO1xuZnVuY3Rpb24ga2VlcE9iamVjdEVxdWFsaXR5KG9iamVjdCwga2V5TWFwKSB7XG4gIGNvbnN0IHZhbHVlID0ga2V5TWFwW29iamVjdC5fa2V5XTtcbiAgcmV0dXJuIHZhbHVlICYmIGlzRXF1YWwob2JqZWN0LCB2YWx1ZSkgPyB2YWx1ZSA6IChrZXlNYXBbb2JqZWN0Ll9rZXldID0gb2JqZWN0LCBvYmplY3QpO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVZhbHVlKHZhbHVlLCB7XG4gIHNjaGVtYVR5cGVzXG59LCBrZXlNYXAgPSB7fSkge1xuICByZXR1cm4gdmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKGJsb2NrKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX3R5cGUsXG4gICAgICBfa2V5LFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBibG9jaztcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGJsb2NrO1xuICAgICAgbGV0IGhhc0lubGluZXMgPSAhMTtcbiAgICAgIGNvbnN0IGhhc01pc3NpbmdTdHlsZSA9IHR5cGVvZiB0ZXh0QmxvY2suc3R5bGUgPiBcInVcIiwgaGFzTWlzc2luZ01hcmtEZWZzID0gdHlwZW9mIHRleHRCbG9jay5tYXJrRGVmcyA+IFwidVwiLCBoYXNNaXNzaW5nQ2hpbGRyZW4gPSB0eXBlb2YgdGV4dEJsb2NrLmNoaWxkcmVuID4gXCJ1XCIsIGNoaWxkcmVuID0gKHRleHRCbG9jay5jaGlsZHJlbiB8fCBbXSkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgLi4uY1Jlc3RcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4gY1R5cGUgIT09IFwic3BhblwiID8gKGhhc0lubGluZXMgPSAhMCwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgICBfdHlwZTogY1R5cGUsXG4gICAgICAgICAgX2tleTogY0tleSxcbiAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgIF9rZXk6IFZPSURfQ0hJTERfS0VZLFxuICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIHZhbHVlOiBjUmVzdCxcbiAgICAgICAgICBfX2lubGluZTogITBcbiAgICAgICAgfSwga2V5TWFwKSkgOiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICFoYXNNaXNzaW5nU3R5bGUgJiYgIWhhc01pc3NpbmdNYXJrRGVmcyAmJiAhaGFzTWlzc2luZ0NoaWxkcmVuICYmICFoYXNJbmxpbmVzICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spID8gYmxvY2sgOiAoaGFzTWlzc2luZ1N0eWxlICYmIChyZXN0LnN0eWxlID0gc2NoZW1hVHlwZXMuc3R5bGVzWzBdLm5hbWUpLCBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICBfdHlwZSxcbiAgICAgICAgX2tleSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0sIGtleU1hcCkpO1xuICAgIH1cbiAgICByZXR1cm4ga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWSxcbiAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1dLFxuICAgICAgdmFsdWU6IHJlc3RcbiAgICB9LCBrZXlNYXApO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gZnJvbVNsYXRlVmFsdWUodmFsdWUsIHRleHRCbG9ja1R5cGUsIGtleU1hcCA9IHt9KSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGJsb2NrKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlXG4gICAgfSA9IGJsb2NrO1xuICAgIGlmICghX2tleSB8fCAhX3R5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBibG9ja1wiKTtcbiAgICBpZiAoX3R5cGUgPT09IHRleHRCbG9ja1R5cGUgJiYgXCJjaGlsZHJlblwiIGluIGJsb2NrICYmIEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIF9rZXkpIHtcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBfY1R5cGVcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGNoaWxkICYmIF9jVHlwZSAhPT0gXCJzcGFuXCIpIHtcbiAgICAgICAgICBoYXNJbmxpbmVzID0gITA7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHQsXG4gICAgICAgICAgICBfX2lubGluZTogX2ksXG4gICAgICAgICAgICBjaGlsZHJlbjogX2MsXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIC4uLnYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHRcbiAgICAgICAgICB9LCBrZXlNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhhc0lubGluZXMgPyBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIF9rZXksXG4gICAgICAgIF90eXBlXG4gICAgICB9LCBrZXlNYXApIDogYmxvY2s7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrVmFsdWUgPSBcInZhbHVlXCIgaW4gYmxvY2sgJiYgYmxvY2sudmFsdWU7XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfa2V5LFxuICAgICAgX3R5cGUsXG4gICAgICAuLi50eXBlb2YgYmxvY2tWYWx1ZSA9PSBcIm9iamVjdFwiID8gYmxvY2tWYWx1ZSA6IHt9XG4gICAgfSwga2V5TWFwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0VxdWFsVG9FbXB0eUVkaXRvcihjaGlsZHJlbiwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGNoaWxkcmVuID09PSB2b2lkIDAgfHwgY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSAmJiBcInN0eWxlXCIgaW4gY2hpbGRyZW5bMF0gJiYgY2hpbGRyZW5bMF0uc3R5bGUgPT09IHNjaGVtYVR5cGVzLnN0eWxlc1swXS5uYW1lICYmICEoXCJsaXN0SXRlbVwiIGluIGNoaWxkcmVuWzBdKSAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuWzBdLmNoaWxkcmVuKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0pICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLl90eXBlID09PSBcInNwYW5cIiAmJiAhY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0ubWFya3M/LmpvaW4oXCJcIikgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzQmxvY2soe1xuICBlZGl0b3Jcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB0cnkge1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSkgPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblN0YXJ0QmxvY2soe1xuICBlZGl0b3Jcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICBjb25zdCBzZWxlY3Rpb25TdGFydFBvaW50ID0gUmFuZ2Uuc3RhcnQoZWRpdG9yLnNlbGVjdGlvbik7XG4gIHJldHVybiBnZXRQb2ludEJsb2NrKHtcbiAgICBlZGl0b3IsXG4gICAgcG9pbnQ6IHNlbGVjdGlvblN0YXJ0UG9pbnRcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25FbmRCbG9jayh7XG4gIGVkaXRvclxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIGNvbnN0IHNlbGVjdGlvbkVuZFBvaW50ID0gUmFuZ2UuZW5kKGVkaXRvci5zZWxlY3Rpb24pO1xuICByZXR1cm4gZ2V0UG9pbnRCbG9jayh7XG4gICAgZWRpdG9yLFxuICAgIHBvaW50OiBzZWxlY3Rpb25FbmRQb2ludFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBvaW50QmxvY2soe1xuICBlZGl0b3IsXG4gIHBvaW50XG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aC5zbGljZSgwLCAxKSkgPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICByZXR1cm4gYmxvY2sgPyBbYmxvY2ssIHBvaW50LnBhdGguc2xpY2UoMCwgMSldIDogW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZvY3VzQ2hpbGQoe1xuICBlZGl0b3Jcbn0pIHtcbiAgY29uc3QgW2ZvY3VzQmxvY2ssIGZvY3VzQmxvY2tQYXRoXSA9IGdldEZvY3VzQmxvY2soe1xuICAgIGVkaXRvclxuICB9KSwgY2hpbGRJbmRleCA9IGVkaXRvci5zZWxlY3Rpb24/LmZvY3VzLnBhdGguYXQoMSk7XG4gIGlmICghZm9jdXNCbG9jayB8fCAhZm9jdXNCbG9ja1BhdGggfHwgY2hpbGRJbmRleCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB0cnkge1xuICAgIGNvbnN0IGZvY3VzQ2hpbGQgPSBOb2RlLmNoaWxkKGZvY3VzQmxvY2ssIGNoaWxkSW5kZXgpO1xuICAgIHJldHVybiBmb2N1c0NoaWxkID8gW2ZvY3VzQ2hpbGQsIFsuLi5mb2N1c0Jsb2NrUGF0aCwgY2hpbGRJbmRleF1dIDogW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBvaW50Q2hpbGQoe1xuICBlZGl0b3IsXG4gIHBvaW50XG59KSB7XG4gIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IGdldFBvaW50QmxvY2soe1xuICAgIGVkaXRvcixcbiAgICBwb2ludFxuICB9KSwgY2hpbGRJbmRleCA9IHBvaW50LnBhdGguYXQoMSk7XG4gIGlmICghYmxvY2sgfHwgIWJsb2NrUGF0aCB8fCBjaGlsZEluZGV4ID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnRDaGlsZCA9IE5vZGUuY2hpbGQoYmxvY2ssIGNoaWxkSW5kZXgpO1xuICAgIHJldHVybiBwb2ludENoaWxkID8gW3BvaW50Q2hpbGQsIFsuLi5ibG9ja1BhdGgsIGNoaWxkSW5kZXhdXSA6IFt2b2lkIDAsIHZvaWQgMF07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaXJzdEJsb2NrKHtcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IGZpcnN0QmxvY2tQYXRoID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pLnBhdGguYXQoMCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZpcnN0QmxvY2tQYXRoICE9PSB2b2lkIDAgPyBFZGl0b3Iubm9kZShlZGl0b3IsIFtmaXJzdEJsb2NrUGF0aF0pID8/IFt2b2lkIDAsIHZvaWQgMF0gOiBbdm9pZCAwLCB2b2lkIDBdO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGFzdEJsb2NrKHtcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IGxhc3RCbG9ja1BhdGggPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pLnBhdGguYXQoMCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxhc3RCbG9ja1BhdGggIT09IHZvaWQgMCA/IEVkaXRvci5ub2RlKGVkaXRvciwgW2xhc3RCbG9ja1BhdGhdKSA/PyBbdm9pZCAwLCB2b2lkIDBdIDogW3ZvaWQgMCwgdm9pZCAwXTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5vZGVCbG9jayh7XG4gIGVkaXRvcixcbiAgc2NoZW1hLFxuICBub2RlXG59KSB7XG4gIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpXG4gICAgcmV0dXJuO1xuICBpZiAoaXNCbG9ja0VsZW1lbnQoe1xuICAgIGVkaXRvcixcbiAgICBzY2hlbWFcbiAgfSwgbm9kZSkpXG4gICAgcmV0dXJuIGVsZW1lbnRUb0Jsb2NrKHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICB9KTtcbiAgY29uc3QgcGFyZW50ID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbW9kZTogXCJoaWdoZXN0XCIsXG4gICAgYXQ6IFtdLFxuICAgIG1hdGNoOiAobikgPT4gaXNCbG9ja0VsZW1lbnQoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc2NoZW1hXG4gICAgfSwgbikgJiYgbi5jaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuX2tleSA9PT0gbm9kZS5fa2V5KVxuICB9KSkuYXQoMCk/LmF0KDApO1xuICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChwYXJlbnQpID8gZWxlbWVudFRvQmxvY2soe1xuICAgIHNjaGVtYSxcbiAgICBlbGVtZW50OiBwYXJlbnRcbiAgfSkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBlbGVtZW50VG9CbG9jayh7XG4gIHNjaGVtYSxcbiAgZWxlbWVudFxufSkge1xuICByZXR1cm4gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWEuYmxvY2submFtZSk/LmF0KDApO1xufVxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQoe1xuICBlZGl0b3IsXG4gIHNjaGVtYVxufSwgbm9kZSkge1xuICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpICYmIChzY2hlbWEuYmxvY2submFtZSA9PT0gbm9kZS5fdHlwZSB8fCBzY2hlbWEuYmxvY2tPYmplY3RzLnNvbWUoKGJsb2NrT2JqZWN0KSA9PiBibG9ja09iamVjdC5uYW1lID09PSBub2RlLl90eXBlKSk7XG59XG5mdW5jdGlvbiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBsaXN0SXRlbVxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMCA/IHNlbGVjdGVkQmxvY2tzLmV2ZXJ5KChbbm9kZV0pID0+IGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSAmJiBub2RlLmxpc3RJdGVtID09PSBsaXN0SXRlbSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzU3R5bGVBY3RpdmUoe1xuICBlZGl0b3IsXG4gIHN0eWxlXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAwID8gc2VsZWN0ZWRCbG9ja3MuZXZlcnkoKFtub2RlXSkgPT4gbm9kZS5zdHlsZSA9PT0gc3R5bGUpIDogITE7XG59XG5mdW5jdGlvbiBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICBzY2hlbWEsXG4gIGVkaXRvcixcbiAgcmFuZ2Vcbn0pIHtcbiAgY29uc3QgW2FuY2hvckJsb2NrXSA9IGdldFBvaW50QmxvY2soe1xuICAgIGVkaXRvcixcbiAgICBwb2ludDogcmFuZ2UuYW5jaG9yXG4gIH0pLCBbZm9jdXNCbG9ja10gPSBnZXRQb2ludEJsb2NrKHtcbiAgICBlZGl0b3IsXG4gICAgcG9pbnQ6IHJhbmdlLmZvY3VzXG4gIH0pO1xuICBpZiAoIWFuY2hvckJsb2NrIHx8ICFmb2N1c0Jsb2NrKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBbYW5jaG9yQ2hpbGRdID0gYW5jaG9yQmxvY2suX3R5cGUgPT09IHNjaGVtYS5ibG9jay5uYW1lID8gZ2V0UG9pbnRDaGlsZCh7XG4gICAgZWRpdG9yLFxuICAgIHBvaW50OiByYW5nZS5hbmNob3JcbiAgfSkgOiBbdm9pZCAwLCB2b2lkIDBdLCBbZm9jdXNDaGlsZF0gPSBmb2N1c0Jsb2NrLl90eXBlID09PSBzY2hlbWEuYmxvY2submFtZSA/IGdldFBvaW50Q2hpbGQoe1xuICAgIGVkaXRvcixcbiAgICBwb2ludDogcmFuZ2UuZm9jdXNcbiAgfSkgOiBbdm9pZCAwLCB2b2lkIDBdLCBzZWxlY3Rpb24gPSB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBhbmNob3JCbG9jay5fa2V5XG4gICAgICB9XSxcbiAgICAgIG9mZnNldDogcmFuZ2UuYW5jaG9yLm9mZnNldFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IFt7XG4gICAgICAgIF9rZXk6IGZvY3VzQmxvY2suX2tleVxuICAgICAgfV0sXG4gICAgICBvZmZzZXQ6IHJhbmdlLmZvY3VzLm9mZnNldFxuICAgIH0sXG4gICAgYmFja3dhcmQ6IFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpXG4gIH07XG4gIHJldHVybiBhbmNob3JDaGlsZCAmJiAoc2VsZWN0aW9uLmFuY2hvci5wYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgc2VsZWN0aW9uLmFuY2hvci5wYXRoLnB1c2goe1xuICAgIF9rZXk6IGFuY2hvckNoaWxkLl9rZXlcbiAgfSkpLCBmb2N1c0NoaWxkICYmIChzZWxlY3Rpb24uZm9jdXMucGF0aC5wdXNoKFwiY2hpbGRyZW5cIiksIHNlbGVjdGlvbi5mb2N1cy5wYXRoLnB1c2goe1xuICAgIF9rZXk6IGZvY3VzQ2hpbGQuX2tleVxuICB9KSksIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50UG9zaXRpb24oe1xuICBlZGl0b3JBY3RvcixcbiAgc2xhdGVFZGl0b3IsXG4gIGV2ZW50XG59KSB7XG4gIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgIHNldHVwOiBcInNldHRpbmcgdXBcIlxuICB9KSlcbiAgICByZXR1cm47XG4gIGNvbnN0IG5vZGUgPSBnZXRFdmVudE5vZGUoe1xuICAgIHNsYXRlRWRpdG9yLFxuICAgIGV2ZW50XG4gIH0pO1xuICBpZiAoIW5vZGUpXG4gICAgcmV0dXJuO1xuICBjb25zdCBibG9jayA9IGdldE5vZGVCbG9jayh7XG4gICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgbm9kZVxuICB9KSwgcG9zaXRpb25CbG9jayA9IGdldEV2ZW50UG9zaXRpb25CbG9jayh7XG4gICAgbm9kZSxcbiAgICBzbGF0ZUVkaXRvcixcbiAgICBldmVudFxuICB9KSwgc2VsZWN0aW9uID0gZ2V0RXZlbnRTZWxlY3Rpb24oe1xuICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICBzbGF0ZUVkaXRvcixcbiAgICBldmVudFxuICB9KTtcbiAgaWYgKGJsb2NrICYmIHBvc2l0aW9uQmxvY2sgJiYgIXNlbGVjdGlvbiAmJiAhRWRpdG9yLmlzRWRpdG9yKG5vZGUpKVxuICAgIHJldHVybiB7XG4gICAgICBibG9jazogcG9zaXRpb25CbG9jayxcbiAgICAgIGlzRWRpdG9yOiAhMSxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LFxuICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZm9jdXM6IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgICAgIGNvbnRleHQ6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCxcbiAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9O1xuICBpZiAoIXBvc2l0aW9uQmxvY2sgfHwgIXNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGZvY3VzQmxvY2tQYXRoID0gc2VsZWN0aW9uLmZvY3VzLnBhdGguYXQoMCksIGZvY3VzQmxvY2tLZXkgPSBpc0tleWVkU2VnbWVudCQxKGZvY3VzQmxvY2tQYXRoKSA/IGZvY3VzQmxvY2tQYXRoLl9rZXkgOiB2b2lkIDA7XG4gIGlmIChmb2N1c0Jsb2NrS2V5KVxuICAgIHJldHVybiBpc1NlbGVjdGlvbkNvbGxhcHNlZCQxKHNlbGVjdGlvbikgJiYgYmxvY2sgJiYgZm9jdXNCbG9ja0tleSAhPT0gYmxvY2suX2tleSA/IHtcbiAgICAgIGJsb2NrOiBwb3NpdGlvbkJsb2NrLFxuICAgICAgaXNFZGl0b3I6ICExLFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjogZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICAgICAgICBjb250ZXh0OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQsXG4gICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBmb2N1czogZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LFxuICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBibG9jazogcG9zaXRpb25CbG9jayxcbiAgICAgIGlzRWRpdG9yOiBFZGl0b3IuaXNFZGl0b3Iobm9kZSksXG4gICAgICBzZWxlY3Rpb25cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnROb2RlKHtcbiAgc2xhdGVFZGl0b3IsXG4gIGV2ZW50XG59KSB7XG4gIHJldHVybiBET01FZGl0b3IuaGFzVGFyZ2V0KHNsYXRlRWRpdG9yLCBldmVudC50YXJnZXQpID8gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKHNsYXRlRWRpdG9yLCBldmVudC50YXJnZXQpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRQb3NpdGlvbkJsb2NrKHtcbiAgbm9kZSxcbiAgc2xhdGVFZGl0b3IsXG4gIGV2ZW50XG59KSB7XG4gIGNvbnN0IFtmaXJzdEJsb2NrXSA9IGdldEZpcnN0QmxvY2soe1xuICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgfSk7XG4gIGlmICghZmlyc3RCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGZpcnN0QmxvY2tSZWN0ID0gRE9NRWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgZmlyc3RCbG9jaykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChldmVudC5wYWdlWSA8IGZpcnN0QmxvY2tSZWN0LnRvcClcbiAgICByZXR1cm4gXCJzdGFydFwiO1xuICBjb25zdCBbbGFzdEJsb2NrXSA9IGdldExhc3RCbG9jayh7XG4gICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICB9KTtcbiAgaWYgKCFsYXN0QmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBsYXN0QmxvY2tSZWYgPSBET01FZGl0b3IudG9ET01Ob2RlKHNsYXRlRWRpdG9yLCBsYXN0QmxvY2spLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoZXZlbnQucGFnZVkgPiBsYXN0QmxvY2tSZWYuYm90dG9tKVxuICAgIHJldHVybiBcImVuZFwiO1xuICBjb25zdCBlbGVtZW50UmVjdCA9IERPTUVkaXRvci50b0RPTU5vZGUoc2xhdGVFZGl0b3IsIG5vZGUpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0b3AgPSBlbGVtZW50UmVjdC50b3AsIGhlaWdodCA9IGVsZW1lbnRSZWN0LmhlaWdodDtcbiAgcmV0dXJuIE1hdGguYWJzKHRvcCAtIGV2ZW50LnBhZ2VZKSA8IGhlaWdodCAvIDIgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRTZWxlY3Rpb24oe1xuICBzY2hlbWEsXG4gIHNsYXRlRWRpdG9yLFxuICBldmVudFxufSkge1xuICBjb25zdCByYW5nZSA9IGdldFNsYXRlUmFuZ2VGcm9tRXZlbnQoc2xhdGVFZGl0b3IsIGV2ZW50KTtcbiAgcmV0dXJuIHJhbmdlID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICBzY2hlbWEsXG4gICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICByYW5nZVxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTbGF0ZVJhbmdlRnJvbUV2ZW50KGVkaXRvciwgZXZlbnQpIHtcbiAgaWYgKCFldmVudC50YXJnZXQgfHwgIWlzRE9NTm9kZShldmVudC50YXJnZXQpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgd2luZG93MiA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgbGV0IGRvbVJhbmdlO1xuICBpZiAod2luZG93Mi5kb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50ICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHdpbmRvdzIuZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBpZiAocG9zaXRpb24pXG4gICAgICB0cnkge1xuICAgICAgICBkb21SYW5nZSA9IHdpbmRvdzIuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgZG9tUmFuZ2Uuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KSwgZG9tUmFuZ2Uuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgfSBlbHNlIGlmICh3aW5kb3cyLmRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQgIT09IHZvaWQgMClcbiAgICBkb21SYW5nZSA9IHdpbmRvdzIuZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSA/PyB2b2lkIDA7XG4gIGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIk5laXRoZXIgY2FyZXRQb3NpdGlvbkZyb21Qb2ludCBub3IgY2FyZXRSYW5nZUZyb21Qb2ludCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZG9tUmFuZ2UpXG4gICAgcmV0dXJuO1xuICBsZXQgcmFuZ2U7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBET01FZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6ICExLFxuICAgICAgLy8gSXQgY2FuIHN0aWxsIHRocm93IGV2ZW4gd2l0aCB0aGlzIG9wdGlvbiBzZXQgdG8gdHJ1ZVxuICAgICAgc3VwcHJlc3NUaHJvdzogITFcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVBhdGgocGF0aCwgZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IFtdLFxuICAgIG1hdGNoOiAobikgPT4gaXNLZXlTZWdtZW50KHBhdGhbMF0pICYmIG4uX2tleSA9PT0gcGF0aFswXS5fa2V5XG4gIH0pKVswXSB8fCBbdm9pZCAwLCB2b2lkIDBdO1xuICBpZiAoIWJsb2NrIHx8ICFFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSlcbiAgICByZXR1cm4gW107XG4gIGlmIChlZGl0b3IuaXNWb2lkKGJsb2NrKSlcbiAgICByZXR1cm4gW2Jsb2NrUGF0aFswXSwgMF07XG4gIGNvbnN0IGNoaWxkUGF0aCA9IFtwYXRoWzJdXSwgY2hpbGRJbmRleCA9IGJsb2NrLmNoaWxkcmVuLmZpbmRJbmRleCgoY2hpbGQpID0+IGlzRXF1YWwoW3tcbiAgICBfa2V5OiBjaGlsZC5fa2V5XG4gIH1dLCBjaGlsZFBhdGgpKTtcbiAgaWYgKGNoaWxkSW5kZXggPj0gMCAmJiBibG9jay5jaGlsZHJlbltjaGlsZEluZGV4XSkge1xuICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgcmV0dXJuIEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGQpICYmIGVkaXRvci5pc1ZvaWQoY2hpbGQpID8gYmxvY2tQYXRoLmNvbmNhdChjaGlsZEluZGV4KS5jb25jYXQoMCkgOiBibG9ja1BhdGguY29uY2F0KGNoaWxkSW5kZXgpO1xuICB9XG4gIHJldHVybiBbYmxvY2tQYXRoWzBdLCAwXTtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcikge1xuICBpZiAoIXNlbGVjdGlvbiB8fCAhZWRpdG9yKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBhbmNob3IgPSB7XG4gICAgcGF0aDogdG9TbGF0ZVBhdGgoc2VsZWN0aW9uLmFuY2hvci5wYXRoLCBlZGl0b3IpLFxuICAgIG9mZnNldDogc2VsZWN0aW9uLmFuY2hvci5vZmZzZXRcbiAgfSwgZm9jdXMgPSB7XG4gICAgcGF0aDogdG9TbGF0ZVBhdGgoc2VsZWN0aW9uLmZvY3VzLnBhdGgsIGVkaXRvciksXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0XG4gIH07XG4gIHJldHVybiBmb2N1cy5wYXRoLmxlbmd0aCA9PT0gMCB8fCBhbmNob3IucGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogYW5jaG9yICYmIGZvY3VzID8ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHJhbmdlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmFuY2hvciwgb3BlcmF0aW9uKSwgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0ocmFuZ2UuZm9jdXMsIG9wZXJhdGlvbik7XG4gIHJldHVybiBhbmNob3IgPT09IG51bGwgfHwgZm9jdXMgPT09IG51bGwgPyBudWxsIDogUG9pbnQuZXF1YWxzKGFuY2hvciwgcmFuZ2UuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMoZm9jdXMsIHJhbmdlLmZvY3VzKSA/IHJhbmdlIDoge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQsIHZhbHVlKSB7XG4gIGlmICghcG9pbnQgfHwgIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuZXdQYXRoID0gW107XG4gIGxldCBuZXdPZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgY29uc3QgYmxvY2tLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFswXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMF0gJiYgcG9pbnQucGF0aFswXS5fa2V5LCBjaGlsZEtleSA9IHR5cGVvZiBwb2ludC5wYXRoWzJdID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gcG9pbnQucGF0aFsyXSAmJiBwb2ludC5wYXRoWzJdLl9rZXksIGJsb2NrID0gdmFsdWUuZmluZCgoYmxrKSA9PiBibGsuX2tleSA9PT0gYmxvY2tLZXkpO1xuICBpZiAoYmxvY2spXG4gICAgbmV3UGF0aC5wdXNoKHtcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoYmxvY2sgJiYgcG9pbnQucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgaWYgKCFibG9jay5jaGlsZHJlbiB8fCBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuLmZpbmQoKGNsZCkgPT4gY2xkLl9rZXkgPT09IGNoaWxkS2V5KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBuZXdQYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgbmV3UGF0aC5wdXNoKHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfSksIG5ld09mZnNldCA9IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggPj0gcG9pbnQub2Zmc2V0ID8gcG9pbnQub2Zmc2V0IDogY2hpbGQudGV4dCAmJiBjaGlsZC50ZXh0Lmxlbmd0aCB8fCAwO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbiwgdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG5ld0FuY2hvciA9IG51bGwsIG5ld0ZvY3VzID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICByZXR1cm4gYW5jaG9yICYmIHZhbHVlLmZpbmQoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgX2tleTogYmxrLl9rZXlcbiAgfSwgYW5jaG9yLnBhdGhbMF0pKSAmJiAobmV3QW5jaG9yID0gbm9ybWFsaXplUG9pbnQoYW5jaG9yLCB2YWx1ZSkpLCBmb2N1cyAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGZvY3VzLnBhdGhbMF0pKSAmJiAobmV3Rm9jdXMgPSBub3JtYWxpemVQb2ludChmb2N1cywgdmFsdWUpKSwgbmV3QW5jaG9yICYmIG5ld0ZvY3VzID8ge1xuICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICBiYWNrd2FyZDogc2VsZWN0aW9uLmJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRG9tTm9kZXMoe1xuICBzbGF0ZUVkaXRvcixcbiAgc25hcHNob3Rcbn0pIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2tOb2RlczogW10sXG4gICAgICBjaGlsZE5vZGVzOiBbXVxuICAgIH07XG4gIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gIGlmICghcmFuZ2UpXG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrTm9kZXM6IFtdLFxuICAgICAgY2hpbGROb2RlczogW11cbiAgICB9O1xuICBjb25zdCBibG9ja0VudHJpZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhzbGF0ZUVkaXRvciwge1xuICAgIGF0OiByYW5nZSxcbiAgICBtb2RlOiBcImhpZ2hlc3RcIixcbiAgICBtYXRjaDogKG4pID0+ICFFZGl0b3IuaXNFZGl0b3IobilcbiAgfSkpLCBjaGlsZEVudHJpZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhzbGF0ZUVkaXRvciwge1xuICAgIGF0OiByYW5nZSxcbiAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgIG1hdGNoOiAobikgPT4gIUVkaXRvci5pc0VkaXRvcihuKSAmJiBzbGF0ZUVkaXRvci5pc1RleHRTcGFuKG4pIHx8ICFzbGF0ZUVkaXRvci5pc0Jsb2NrKG4pXG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBibG9ja05vZGVzOiBibG9ja0VudHJpZXMubWFwKChbYmxvY2tOb2RlXSkgPT4gRE9NRWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgYmxvY2tOb2RlKSksXG4gICAgY2hpbGROb2RlczogY2hpbGRFbnRyaWVzLm1hcCgoW2NoaWxkTm9kZV0pID0+IERPTUVkaXRvci50b0RPTU5vZGUoc2xhdGVFZGl0b3IsIGNoaWxkTm9kZSkpXG4gIH07XG59XG5jb25zdCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19TTEFURV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19WQUxVRV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgRWRpdG9yQWN0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5mdW5jdGlvbiBEcm9wSW5kaWNhdG9yKCkge1xuICBjb25zdCAkID0gYygxKTtcbiAgbGV0IHQwO1xuICByZXR1cm4gJFswXSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDAgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY29udGVudEVkaXRhYmxlOiAhMSwgY2xhc3NOYW1lOiBcInB0LWRyb3AtaW5kaWNhdG9yXCIsIHN0eWxlOiB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiAxLFxuICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgY3VycmVudENvbG9yXCIsXG4gICAgekluZGV4OiA1XG4gIH0sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7fSkgfSksICRbMF0gPSB0MCkgOiB0MCA9ICRbMF0sIHQwO1xufVxuZnVuY3Rpb24gUmVuZGVyRGVmYXVsdEJsb2NrT2JqZWN0KHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDA7XG4gICRbMF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQwID0ge1xuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH0sICRbMF0gPSB0MCkgOiB0MCA9ICRbMF07XG4gIGxldCB0MTtcbiAgcmV0dXJuICRbMV0gIT09IHByb3BzLmJsb2NrT2JqZWN0Ll9rZXkgfHwgJFsyXSAhPT0gcHJvcHMuYmxvY2tPYmplY3QuX3R5cGUgPyAodDEgPSAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IHN0eWxlOiB0MCwgY2hpbGRyZW46IFtcbiAgICBcIltcIixcbiAgICBwcm9wcy5ibG9ja09iamVjdC5fdHlwZSxcbiAgICBcIjogXCIsXG4gICAgcHJvcHMuYmxvY2tPYmplY3QuX2tleSxcbiAgICBcIl1cIlxuICBdIH0pLCAkWzFdID0gcHJvcHMuYmxvY2tPYmplY3QuX2tleSwgJFsyXSA9IHByb3BzLmJsb2NrT2JqZWN0Ll90eXBlLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdLCB0MTtcbn1cbmZ1bmN0aW9uIFJlbmRlckRlZmF1bHRJbmxpbmVPYmplY3QocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MDtcbiAgJFswXSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDAgPSB7XG4gICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgfSwgJFswXSA9IHQwKSA6IHQwID0gJFswXTtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFsxXSAhPT0gcHJvcHMuaW5saW5lT2JqZWN0Ll9rZXkgfHwgJFsyXSAhPT0gcHJvcHMuaW5saW5lT2JqZWN0Ll90eXBlID8gKHQxID0gLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHQwLCBjaGlsZHJlbjogW1xuICAgIFwiW1wiLFxuICAgIHByb3BzLmlubGluZU9iamVjdC5fdHlwZSxcbiAgICBcIjogXCIsXG4gICAgcHJvcHMuaW5saW5lT2JqZWN0Ll9rZXksXG4gICAgXCJdXCJcbiAgXSB9KSwgJFsxXSA9IHByb3BzLmlubGluZU9iamVjdC5fa2V5LCAkWzJdID0gcHJvcHMuaW5saW5lT2JqZWN0Ll90eXBlLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdLCB0MTtcbn1cbmNvbnN0IGRlZmF1bHRLZXlHZW5lcmF0b3IgPSAoKSA9PiByYW5kb21LZXkoMTIpLCBnZXRCeXRlSGV4VGFibGUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IHRhYmxlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICh0YWJsZSlcbiAgICAgIHJldHVybiB0YWJsZTtcbiAgICB0YWJsZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpXG4gICAgICB0YWJsZVtpXSA9IChpICsgMjU2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9O1xufSkoKTtcbmZ1bmN0aW9uIHdoYXR3Z1JORyhsZW5ndGggPSAxNikge1xuICBjb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpLCBybmRzODtcbn1cbmZ1bmN0aW9uIHJhbmRvbUtleShsZW5ndGgpIHtcbiAgY29uc3QgdGFibGUgPSBnZXRCeXRlSGV4VGFibGUoKTtcbiAgcmV0dXJuIHdoYXR3Z1JORyhsZW5ndGgpLnJlZHVjZSgoc3RyLCBuKSA9PiBzdHIgKyB0YWJsZVtuXSwgXCJcIikuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRvclByaW9yaXR5KGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGlkOiBkZWZhdWx0S2V5R2VuZXJhdG9yKCksXG4gICAgbmFtZTogY29uZmlnPy5uYW1lLFxuICAgIHJlZmVyZW5jZTogY29uZmlnPy5yZWZlcmVuY2VcbiAgfTtcbn1cbmNvbnN0IGNvcmVQcmlvcml0eSA9IGNyZWF0ZUVkaXRvclByaW9yaXR5KHtcbiAgbmFtZTogXCJjb3JlXCJcbn0pO1xuZnVuY3Rpb24gY3JlYXRlQ29yZUJsb2NrRWxlbWVudEJlaGF2aW9yc0NvbmZpZyh7XG4gIGtleSxcbiAgb25TZXREcmFnUG9zaXRpb25CbG9ja1xufSkge1xuICByZXR1cm4gW3tcbiAgICBiZWhhdmlvcjogZGVmaW5lQmVoYXZpb3Ioe1xuICAgICAgb246IFwiZHJhZy5kcmFnb3ZlclwiLFxuICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBkcm9wRm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2skMSh7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQucG9zaXRpb24uc2VsZWN0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkcm9wRm9jdXNCbG9jayB8fCBkcm9wRm9jdXNCbG9jay5ub2RlLl9rZXkgIT09IGtleSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGRyYWdPcmlnaW4gPSBzbmFwc2hvdC5iZXRhLmludGVybmFsRHJhZz8ub3JpZ2luO1xuICAgICAgICByZXR1cm4gIWRyYWdPcmlnaW4gfHwgZ2V0U2VsZWN0ZWRCbG9ja3Moe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IGRyYWdPcmlnaW4uc2VsZWN0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KS5zb21lKChkcmFnZ2VkQmxvY2spID0+IGRyYWdnZWRCbG9jay5ub2RlLl9rZXkgPT09IGtleSkgPyAhMSA6IGlzU2VsZWN0aW5nRW50aXJlQmxvY2tzKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczogWyh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBbe1xuICAgICAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICBvblNldERyYWdQb3NpdGlvbkJsb2NrKGV2ZW50LnBvc2l0aW9uLmJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfV1dXG4gICAgfSksXG4gICAgcHJpb3JpdHk6IGNyZWF0ZUVkaXRvclByaW9yaXR5KHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBwcmlvcml0eTogY29yZVByaW9yaXR5LFxuICAgICAgICBpbXBvcnRhbmNlOiBcImxvd2VyXCJcbiAgICAgIH1cbiAgICB9KVxuICB9LCB7XG4gICAgYmVoYXZpb3I6IGRlZmluZUJlaGF2aW9yKHtcbiAgICAgIG9uOiBcImRyYWcuKlwiLFxuICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudC50eXBlICE9PSBcImRyYWcuZHJhZ292ZXJcIixcbiAgICAgIGFjdGlvbnM6IFsoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gW3tcbiAgICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgICAgb25TZXREcmFnUG9zaXRpb25CbG9jayh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9LCBmb3J3YXJkKGV2ZW50KV1dXG4gICAgfSksXG4gICAgcHJpb3JpdHk6IGNyZWF0ZUVkaXRvclByaW9yaXR5KHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBwcmlvcml0eTogY29yZVByaW9yaXR5LFxuICAgICAgICBpbXBvcnRhbmNlOiBcImxvd2VyXCJcbiAgICAgIH1cbiAgICB9KVxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZUNvcmVCbG9ja0VsZW1lbnRCZWhhdmlvcnModDApIHtcbiAgY29uc3QgJCA9IGMoNSksIHtcbiAgICBrZXksXG4gICAgb25TZXREcmFnUG9zaXRpb25CbG9ja1xuICB9ID0gdDAsIGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpO1xuICBsZXQgdDEsIHQyO1xuICAkWzBdICE9PSBlZGl0b3JBY3RvciB8fCAkWzFdICE9PSBrZXkgfHwgJFsyXSAhPT0gb25TZXREcmFnUG9zaXRpb25CbG9jayA/ICh0MSA9ICgpID0+IHtcbiAgICBjb25zdCBiZWhhdmlvckNvbmZpZ3MgPSBjcmVhdGVDb3JlQmxvY2tFbGVtZW50QmVoYXZpb3JzQ29uZmlnKHtcbiAgICAgIGtleSxcbiAgICAgIG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2tcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGJlaGF2aW9yQ29uZmlnIG9mIGJlaGF2aW9yQ29uZmlncylcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImFkZCBiZWhhdmlvclwiLFxuICAgICAgICBiZWhhdmlvckNvbmZpZ1xuICAgICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYmVoYXZpb3JDb25maWdfMCBvZiBiZWhhdmlvckNvbmZpZ3MpXG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwicmVtb3ZlIGJlaGF2aW9yXCIsXG4gICAgICAgICAgYmVoYXZpb3JDb25maWc6IGJlaGF2aW9yQ29uZmlnXzBcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfSwgdDIgPSBbZWRpdG9yQWN0b3IsIGtleSwgb25TZXREcmFnUG9zaXRpb25CbG9ja10sICRbMF0gPSBlZGl0b3JBY3RvciwgJFsxXSA9IGtleSwgJFsyXSA9IG9uU2V0RHJhZ1Bvc2l0aW9uQmxvY2ssICRbM10gPSB0MSwgJFs0XSA9IHQyKSA6ICh0MSA9ICRbM10sIHQyID0gJFs0XSksIHVzZUVmZmVjdCh0MSwgdDIpO1xufVxuZnVuY3Rpb24gUmVuZGVyQmxvY2tPYmplY3QocHJvcHMpIHtcbiAgY29uc3QgW2RyYWdQb3NpdGlvbkJsb2NrLCBzZXREcmFnUG9zaXRpb25CbG9ja10gPSB1c2VTdGF0ZSgpLCBibG9ja09iamVjdFJlZiA9IHVzZVJlZihudWxsKSwgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBzZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpO1xuICB1c2VDb3JlQmxvY2tFbGVtZW50QmVoYXZpb3JzKHtcbiAgICBrZXk6IHByb3BzLmVsZW1lbnQuX2tleSxcbiAgICBvblNldERyYWdQb3NpdGlvbkJsb2NrOiBzZXREcmFnUG9zaXRpb25CbG9ja1xuICB9KTtcbiAgY29uc3QgbGVnYWN5U2NoZW1hVHlwZSA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCAocykgPT4gcy5jb250ZXh0LmdldExlZ2FjeVNjaGVtYSgpLmJsb2NrT2JqZWN0cy5maW5kKChibG9ja09iamVjdCkgPT4gYmxvY2tPYmplY3QubmFtZSA9PT0gcHJvcHMuZWxlbWVudC5fdHlwZSkpO1xuICBsZWdhY3lTY2hlbWFUeXBlIHx8IGNvbnNvbGUuZXJyb3IoYEJsb2NrIG9iamVjdCB0eXBlICR7cHJvcHMuZWxlbWVudC5fdHlwZX0gbm90IGZvdW5kIGluIFNjaGVtYWApO1xuICBjb25zdCBmb2N1c2VkID0gc2VsZWN0ZWQgJiYgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uICE9PSBudWxsICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNsYXRlRWRpdG9yLnNlbGVjdGlvbik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IC4uLnByb3BzLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZTogXCJwdC1ibG9jayBwdC1vYmplY3QtYmxvY2tcIiwgXCJkYXRhLWJsb2NrLWtleVwiOiBwcm9wcy5lbGVtZW50Ll9rZXksIFwiZGF0YS1ibG9jay1uYW1lXCI6IHByb3BzLmVsZW1lbnQuX3R5cGUsIFwiZGF0YS1ibG9jay10eXBlXCI6IFwib2JqZWN0XCIsIGNoaWxkcmVuOiBbXG4gICAgZHJhZ1Bvc2l0aW9uQmxvY2sgPT09IFwic3RhcnRcIiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRHJvcEluZGljYXRvciwge30pIDogbnVsbCxcbiAgICBwcm9wcy5jaGlsZHJlbixcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja09iamVjdFJlZiwgY29udGVudEVkaXRhYmxlOiAhMSwgZHJhZ2dhYmxlOiAhcHJvcHMucmVhZE9ubHksIGNoaWxkcmVuOiBwcm9wcy5yZW5kZXJCbG9jayAmJiBsZWdhY3lTY2hlbWFUeXBlID8gcHJvcHMucmVuZGVyQmxvY2soe1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyRGVmYXVsdEJsb2NrT2JqZWN0LCB7IGJsb2NrT2JqZWN0OiBwcm9wcy5ibG9ja09iamVjdCB9KSxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrT2JqZWN0UmVmLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIHBhdGg6IFt7XG4gICAgICAgIF9rZXk6IHByb3BzLmVsZW1lbnQuX2tleVxuICAgICAgfV0sXG4gICAgICBzY2hlbWFUeXBlOiBsZWdhY3lTY2hlbWFUeXBlLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICB0eXBlOiBsZWdhY3lTY2hlbWFUeXBlLFxuICAgICAgdmFsdWU6IHByb3BzLmJsb2NrT2JqZWN0XG4gICAgfSkgOiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckRlZmF1bHRCbG9ja09iamVjdCwgeyBibG9ja09iamVjdDogcHJvcHMuYmxvY2tPYmplY3QgfSkgfSksXG4gICAgZHJhZ1Bvc2l0aW9uQmxvY2sgPT09IFwiZW5kXCIgPyAvKiBAX19QVVJFX18gKi8ganN4KERyb3BJbmRpY2F0b3IsIHt9KSA6IG51bGxcbiAgXSB9KTtcbn1cbmZ1bmN0aW9uIFJlbmRlcklubGluZU9iamVjdChwcm9wcykge1xuICBjb25zdCBpbmxpbmVPYmplY3RSZWYgPSB1c2VSZWYobnVsbCksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgc2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgbGVnYWN5U2NoZW1hVHlwZSA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCAocykgPT4gcy5jb250ZXh0LmdldExlZ2FjeVNjaGVtYSgpLmlubGluZU9iamVjdHMuZmluZCgoaW5saW5lT2JqZWN0KSA9PiBpbmxpbmVPYmplY3QubmFtZSA9PT0gcHJvcHMuZWxlbWVudC5fdHlwZSkpO1xuICBsZWdhY3lTY2hlbWFUeXBlIHx8IGNvbnNvbGUuZXJyb3IoYElubGluZSBvYmplY3QgdHlwZSAke3Byb3BzLmVsZW1lbnQuX3R5cGV9IG5vdCBmb3VuZCBpbiBTY2hlbWFgKTtcbiAgY29uc3QgZm9jdXNlZCA9IHNlbGVjdGVkICYmIHNsYXRlRWRpdG9yLnNlbGVjdGlvbiAhPT0gbnVsbCAmJiBSYW5nZS5pc0NvbGxhcHNlZChzbGF0ZUVkaXRvci5zZWxlY3Rpb24pLCBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKHNsYXRlRWRpdG9yLCBwcm9wcy5lbGVtZW50KSwgW2Jsb2NrXSA9IGdldFBvaW50QmxvY2soe1xuICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgcG9pbnQ6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYmxvY2sgfHwgY29uc29sZS5lcnJvcihgVW5hYmxlIHRvIGZpbmQgcGFyZW50IGJsb2NrIG9mIGlubGluZSBvYmplY3QgJHtwcm9wcy5lbGVtZW50Ll9rZXl9YCksIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IC4uLnByb3BzLmF0dHJpYnV0ZXMsIGRyYWdnYWJsZTogIXByb3BzLnJlYWRPbmx5LCBjbGFzc05hbWU6IFwicHQtaW5saW5lLW9iamVjdFwiLCBcImRhdGEtY2hpbGQta2V5XCI6IHByb3BzLmlubGluZU9iamVjdC5fa2V5LCBcImRhdGEtY2hpbGQtbmFtZVwiOiBwcm9wcy5pbmxpbmVPYmplY3QuX3R5cGUsIFwiZGF0YS1jaGlsZC10eXBlXCI6IFwib2JqZWN0XCIsIGNoaWxkcmVuOiBbXG4gICAgcHJvcHMuY2hpbGRyZW4sXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IGlubGluZU9iamVjdFJlZiwgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICB9LCBjaGlsZHJlbjogcHJvcHMucmVuZGVyQ2hpbGQgJiYgYmxvY2sgJiYgbGVnYWN5U2NoZW1hVHlwZSA/IHByb3BzLnJlbmRlckNoaWxkKHtcbiAgICAgIGFubm90YXRpb25zOiBbXSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckRlZmF1bHRJbmxpbmVPYmplY3QsIHsgaW5saW5lT2JqZWN0OiBwcm9wcy5pbmxpbmVPYmplY3QgfSksXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBpbmxpbmVPYmplY3RSZWYsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIGZvY3VzZWQsXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogcHJvcHMuZWxlbWVudC5fa2V5XG4gICAgICB9XSxcbiAgICAgIHNjaGVtYVR5cGU6IGxlZ2FjeVNjaGVtYVR5cGUsXG4gICAgICB2YWx1ZTogcHJvcHMuaW5saW5lT2JqZWN0LFxuICAgICAgdHlwZTogbGVnYWN5U2NoZW1hVHlwZVxuICAgIH0pIDogLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJEZWZhdWx0SW5saW5lT2JqZWN0LCB7IGlubGluZU9iamVjdDogcHJvcHMuaW5saW5lT2JqZWN0IH0pIH0pXG4gIF0gfSk7XG59XG5mdW5jdGlvbiBSZW5kZXJUZXh0QmxvY2socHJvcHMpIHtcbiAgY29uc3QgW2RyYWdQb3NpdGlvbkJsb2NrLCBzZXREcmFnUG9zaXRpb25CbG9ja10gPSB1c2VTdGF0ZSgpLCBibG9ja1JlZiA9IHVzZVJlZihudWxsKSwgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBzZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpO1xuICB1c2VDb3JlQmxvY2tFbGVtZW50QmVoYXZpb3JzKHtcbiAgICBrZXk6IHByb3BzLmVsZW1lbnQuX2tleSxcbiAgICBvblNldERyYWdQb3NpdGlvbkJsb2NrOiBzZXREcmFnUG9zaXRpb25CbG9ja1xuICB9KTtcbiAgY29uc3QgbGVnYWN5U2NoZW1hID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIChzKSA9PiBzLmNvbnRleHQuZ2V0TGVnYWN5U2NoZW1hKCkpLCBmb2N1c2VkID0gc2VsZWN0ZWQgJiYgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uICE9PSBudWxsICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNsYXRlRWRpdG9yLnNlbGVjdGlvbik7XG4gIGxldCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICBjb25zdCBsZWdhY3lCbG9ja1NjaGVtYVR5cGUgPSBsZWdhY3lTY2hlbWEuYmxvY2s7XG4gIGlmIChwcm9wcy5yZW5kZXJTdHlsZSAmJiBwcm9wcy50ZXh0QmxvY2suc3R5bGUpIHtcbiAgICBjb25zdCBsZWdhY3lTdHlsZVNjaGVtYVR5cGUgPSBwcm9wcy50ZXh0QmxvY2suc3R5bGUgIT09IHZvaWQgMCA/IGxlZ2FjeVNjaGVtYS5zdHlsZXMuZmluZCgoc3R5bGUpID0+IHN0eWxlLnZhbHVlID09PSBwcm9wcy50ZXh0QmxvY2suc3R5bGUpIDogdm9pZCAwO1xuICAgIGxlZ2FjeVN0eWxlU2NoZW1hVHlwZSA/IGNoaWxkcmVuID0gcHJvcHMucmVuZGVyU3R5bGUoe1xuICAgICAgYmxvY2s6IHByb3BzLnRleHRCbG9jayxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWYsXG4gICAgICBmb2N1c2VkLFxuICAgICAgcGF0aDogW3tcbiAgICAgICAgX2tleTogcHJvcHMudGV4dEJsb2NrLl9rZXlcbiAgICAgIH1dLFxuICAgICAgc2NoZW1hVHlwZTogbGVnYWN5U3R5bGVTY2hlbWFUeXBlLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICB2YWx1ZTogcHJvcHMudGV4dEJsb2NrLnN0eWxlXG4gICAgfSkgOiBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gZmluZCBTY2hlbWEgdHlwZSBmb3IgdGV4dCBibG9jayBzdHlsZSAke3Byb3BzLnRleHRCbG9jay5zdHlsZX1gKTtcbiAgfVxuICBpZiAocHJvcHMucmVuZGVyTGlzdEl0ZW0gJiYgcHJvcHMudGV4dEJsb2NrLmxpc3RJdGVtKSB7XG4gICAgY29uc3QgbGVnYWN5TGlzdEl0ZW1TY2hlbWFUeXBlID0gbGVnYWN5U2NoZW1hLmxpc3RzLmZpbmQoKGxpc3QpID0+IGxpc3QudmFsdWUgPT09IHByb3BzLnRleHRCbG9jay5saXN0SXRlbSk7XG4gICAgbGVnYWN5TGlzdEl0ZW1TY2hlbWFUeXBlID8gY2hpbGRyZW4gPSBwcm9wcy5yZW5kZXJMaXN0SXRlbSh7XG4gICAgICBibG9jazogcHJvcHMudGV4dEJsb2NrLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBsZXZlbDogcHJvcHMudGV4dEJsb2NrLmxldmVsID8/IDEsXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBwcm9wcy50ZXh0QmxvY2suX2tleVxuICAgICAgfV0sXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHZhbHVlOiBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0sXG4gICAgICBzY2hlbWFUeXBlOiBsZWdhY3lMaXN0SXRlbVNjaGVtYVR5cGVcbiAgICB9KSA6IGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBmaW5kIFNjaGVtYSB0eXBlIGZvciB0ZXh0IGJsb2NrIGxpc3QgaXRlbSAke3Byb3BzLnRleHRCbG9jay5saXN0SXRlbX1gKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyAuLi5wcm9wcy5hdHRyaWJ1dGVzLCBjbGFzc05hbWU6IFtcInB0LWJsb2NrXCIsIFwicHQtdGV4dC1ibG9ja1wiLCAuLi5wcm9wcy50ZXh0QmxvY2suc3R5bGUgPyBbYHB0LXRleHQtYmxvY2stc3R5bGUtJHtwcm9wcy50ZXh0QmxvY2suc3R5bGV9YF0gOiBbXSwgLi4ucHJvcHMudGV4dEJsb2NrLmxpc3RJdGVtID8gW1wicHQtbGlzdC1pdGVtXCIsIGBwdC1saXN0LWl0ZW0tJHtwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW19YCwgYHB0LWxpc3QtaXRlbS1sZXZlbC0ke3Byb3BzLnRleHRCbG9jay5sZXZlbCA/PyAxfWBdIDogW11dLmpvaW4oXCIgXCIpLCBzcGVsbENoZWNrOiBwcm9wcy5zcGVsbENoZWNrLCBcImRhdGEtYmxvY2sta2V5XCI6IHByb3BzLnRleHRCbG9jay5fa2V5LCBcImRhdGEtYmxvY2stbmFtZVwiOiBwcm9wcy50ZXh0QmxvY2suX3R5cGUsIFwiZGF0YS1ibG9jay10eXBlXCI6IFwidGV4dFwiLCBjaGlsZHJlbjogW1xuICAgIGRyYWdQb3NpdGlvbkJsb2NrID09PSBcInN0YXJ0XCIgPyAvKiBAX19QVVJFX18gKi8ganN4KERyb3BJbmRpY2F0b3IsIHt9KSA6IG51bGwsXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogYmxvY2tSZWYsIGNoaWxkcmVuOiBwcm9wcy5yZW5kZXJCbG9jayA/IHByb3BzLnJlbmRlckJsb2NrKHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWYsXG4gICAgICBmb2N1c2VkLFxuICAgICAgbGV2ZWw6IHByb3BzLnRleHRCbG9jay5sZXZlbCxcbiAgICAgIGxpc3RJdGVtOiBwcm9wcy50ZXh0QmxvY2subGlzdEl0ZW0sXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBwcm9wcy50ZXh0QmxvY2suX2tleVxuICAgICAgfV0sXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHNjaGVtYVR5cGU6IGxlZ2FjeUJsb2NrU2NoZW1hVHlwZSxcbiAgICAgIHN0eWxlOiBwcm9wcy50ZXh0QmxvY2suc3R5bGUsXG4gICAgICB0eXBlOiBsZWdhY3lCbG9ja1NjaGVtYVR5cGUsXG4gICAgICB2YWx1ZTogcHJvcHMudGV4dEJsb2NrXG4gICAgfSkgOiBwcm9wcy5jaGlsZHJlbiB9KSxcbiAgICBkcmFnUG9zaXRpb25CbG9jayA9PT0gXCJlbmRcIiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRHJvcEluZGljYXRvciwge30pIDogbnVsbFxuICBdIH0pO1xufVxuZnVuY3Rpb24gUmVuZGVyRWxlbWVudChwcm9wcykge1xuICBjb25zdCAkID0gYyg0NSksIGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpLCBzY2hlbWEgPSB1c2VTZWxlY3RvcihlZGl0b3JBY3RvciwgX3RlbXAkMSk7XG4gIGlmIChcIl9faW5saW5lXCIgaW4gcHJvcHMuZWxlbWVudCAmJiBwcm9wcy5lbGVtZW50Ll9faW5saW5lID09PSAhMCkge1xuICAgIGxldCB0MDI7XG4gICAgaWYgKCRbMF0gIT09IHByb3BzLmVsZW1lbnQgfHwgJFsxXSAhPT0gc2NoZW1hKSB7XG4gICAgICBsZXQgdDEzO1xuICAgICAgJFszXSAhPT0gcHJvcHMuZWxlbWVudCA/ICh0MTMgPSBcInZhbHVlXCIgaW4gcHJvcHMuZWxlbWVudCAmJiB0eXBlb2YgcHJvcHMuZWxlbWVudC52YWx1ZSA9PSBcIm9iamVjdFwiID8gcHJvcHMuZWxlbWVudC52YWx1ZSA6IHt9LCAkWzNdID0gcHJvcHMuZWxlbWVudCwgJFs0XSA9IHQxMykgOiB0MTMgPSAkWzRdLCB0MDIgPSBwYXJzZUlubGluZU9iamVjdCh7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBrZXlHZW5lcmF0b3I6IF90ZW1wMixcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJlZnJlc2hLZXlzOiAhMSxcbiAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICAgICAgfSxcbiAgICAgICAgaW5saW5lT2JqZWN0OiB7XG4gICAgICAgICAgX2tleTogcHJvcHMuZWxlbWVudC5fa2V5LFxuICAgICAgICAgIF90eXBlOiBwcm9wcy5lbGVtZW50Ll90eXBlLFxuICAgICAgICAgIC4uLnQxM1xuICAgICAgICB9XG4gICAgICB9KSwgJFswXSA9IHByb3BzLmVsZW1lbnQsICRbMV0gPSBzY2hlbWEsICRbMl0gPSB0MDI7XG4gICAgfSBlbHNlXG4gICAgICB0MDIgPSAkWzJdO1xuICAgIGNvbnN0IGlubGluZU9iamVjdCA9IHQwMjtcbiAgICBpbmxpbmVPYmplY3QgfHwgY29uc29sZS5lcnJvcihgVW5hYmxlIHRvIGZpbmQgSW5saW5lIE9iamVjdCBcIiR7cHJvcHMuZWxlbWVudC5fdHlwZX1cIiBpbiBTY2hlbWFgKTtcbiAgICBsZXQgdDEyO1xuICAgICRbNV0gIT09IGlubGluZU9iamVjdCB8fCAkWzZdICE9PSBwcm9wcy5lbGVtZW50Ll9rZXkgfHwgJFs3XSAhPT0gcHJvcHMuZWxlbWVudC5fdHlwZSA/ICh0MTIgPSBpbmxpbmVPYmplY3QgPz8ge1xuICAgICAgX2tleTogcHJvcHMuZWxlbWVudC5fa2V5LFxuICAgICAgX3R5cGU6IHByb3BzLmVsZW1lbnQuX3R5cGVcbiAgICB9LCAkWzVdID0gaW5saW5lT2JqZWN0LCAkWzZdID0gcHJvcHMuZWxlbWVudC5fa2V5LCAkWzddID0gcHJvcHMuZWxlbWVudC5fdHlwZSwgJFs4XSA9IHQxMikgOiB0MTIgPSAkWzhdO1xuICAgIGxldCB0MjI7XG4gICAgcmV0dXJuICRbOV0gIT09IHByb3BzLmF0dHJpYnV0ZXMgfHwgJFsxMF0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMTFdICE9PSBwcm9wcy5lbGVtZW50IHx8ICRbMTJdICE9PSBwcm9wcy5yZWFkT25seSB8fCAkWzEzXSAhPT0gcHJvcHMucmVuZGVyQ2hpbGQgfHwgJFsxNF0gIT09IHQxMiA/ICh0MjIgPSAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlcklubGluZU9iamVjdCwgeyBhdHRyaWJ1dGVzOiBwcm9wcy5hdHRyaWJ1dGVzLCBlbGVtZW50OiBwcm9wcy5lbGVtZW50LCBpbmxpbmVPYmplY3Q6IHQxMiwgcmVhZE9ubHk6IHByb3BzLnJlYWRPbmx5LCByZW5kZXJDaGlsZDogcHJvcHMucmVuZGVyQ2hpbGQsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFs5XSA9IHByb3BzLmF0dHJpYnV0ZXMsICRbMTBdID0gcHJvcHMuY2hpbGRyZW4sICRbMTFdID0gcHJvcHMuZWxlbWVudCwgJFsxMl0gPSBwcm9wcy5yZWFkT25seSwgJFsxM10gPSBwcm9wcy5yZW5kZXJDaGlsZCwgJFsxNF0gPSB0MTIsICRbMTVdID0gdDIyKSA6IHQyMiA9ICRbMTVdLCB0MjI7XG4gIH1cbiAgbGV0IHQwO1xuICAkWzE2XSAhPT0gcHJvcHMuZWxlbWVudCB8fCAkWzE3XSAhPT0gc2NoZW1hID8gKHQwID0gcGFyc2VUZXh0QmxvY2soe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIGtleUdlbmVyYXRvcjogX3RlbXAzLFxuICAgICAgc2NoZW1hXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWZyZXNoS2V5czogITEsXG4gICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICB9LFxuICAgIGJsb2NrOiBwcm9wcy5lbGVtZW50XG4gIH0pLCAkWzE2XSA9IHByb3BzLmVsZW1lbnQsICRbMTddID0gc2NoZW1hLCAkWzE4XSA9IHQwKSA6IHQwID0gJFsxOF07XG4gIGNvbnN0IHRleHRCbG9jayA9IHQwO1xuICBpZiAodGV4dEJsb2NrKSB7XG4gICAgbGV0IHQxMjtcbiAgICByZXR1cm4gJFsxOV0gIT09IHByb3BzLmF0dHJpYnV0ZXMgfHwgJFsyMF0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMjFdICE9PSBwcm9wcy5lbGVtZW50IHx8ICRbMjJdICE9PSBwcm9wcy5yZWFkT25seSB8fCAkWzIzXSAhPT0gcHJvcHMucmVuZGVyQmxvY2sgfHwgJFsyNF0gIT09IHByb3BzLnJlbmRlckxpc3RJdGVtIHx8ICRbMjVdICE9PSBwcm9wcy5yZW5kZXJTdHlsZSB8fCAkWzI2XSAhPT0gcHJvcHMuc3BlbGxDaGVjayB8fCAkWzI3XSAhPT0gdGV4dEJsb2NrID8gKHQxMiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyVGV4dEJsb2NrLCB7IGF0dHJpYnV0ZXM6IHByb3BzLmF0dHJpYnV0ZXMsIGVsZW1lbnQ6IHByb3BzLmVsZW1lbnQsIHJlYWRPbmx5OiBwcm9wcy5yZWFkT25seSwgcmVuZGVyQmxvY2s6IHByb3BzLnJlbmRlckJsb2NrLCByZW5kZXJMaXN0SXRlbTogcHJvcHMucmVuZGVyTGlzdEl0ZW0sIHJlbmRlclN0eWxlOiBwcm9wcy5yZW5kZXJTdHlsZSwgc3BlbGxDaGVjazogcHJvcHMuc3BlbGxDaGVjaywgdGV4dEJsb2NrLCBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSksICRbMTldID0gcHJvcHMuYXR0cmlidXRlcywgJFsyMF0gPSBwcm9wcy5jaGlsZHJlbiwgJFsyMV0gPSBwcm9wcy5lbGVtZW50LCAkWzIyXSA9IHByb3BzLnJlYWRPbmx5LCAkWzIzXSA9IHByb3BzLnJlbmRlckJsb2NrLCAkWzI0XSA9IHByb3BzLnJlbmRlckxpc3RJdGVtLCAkWzI1XSA9IHByb3BzLnJlbmRlclN0eWxlLCAkWzI2XSA9IHByb3BzLnNwZWxsQ2hlY2ssICRbMjddID0gdGV4dEJsb2NrLCAkWzI4XSA9IHQxMikgOiB0MTIgPSAkWzI4XSwgdDEyO1xuICB9XG4gIGxldCB0MTtcbiAgaWYgKCRbMjldICE9PSBwcm9wcy5lbGVtZW50IHx8ICRbMzBdICE9PSBzY2hlbWEpIHtcbiAgICBsZXQgdDIyO1xuICAgICRbMzJdICE9PSBwcm9wcy5lbGVtZW50ID8gKHQyMiA9IFwidmFsdWVcIiBpbiBwcm9wcy5lbGVtZW50ICYmIHR5cGVvZiBwcm9wcy5lbGVtZW50LnZhbHVlID09IFwib2JqZWN0XCIgPyBwcm9wcy5lbGVtZW50LnZhbHVlIDoge30sICRbMzJdID0gcHJvcHMuZWxlbWVudCwgJFszM10gPSB0MjIpIDogdDIyID0gJFszM10sIHQxID0gcGFyc2VCbG9ja09iamVjdCh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogX3RlbXA0LFxuICAgICAgICBzY2hlbWFcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlZnJlc2hLZXlzOiAhMSxcbiAgICAgICAgdmFsaWRhdGVGaWVsZHM6ICExXG4gICAgICB9LFxuICAgICAgYmxvY2tPYmplY3Q6IHtcbiAgICAgICAgX2tleTogcHJvcHMuZWxlbWVudC5fa2V5LFxuICAgICAgICBfdHlwZTogcHJvcHMuZWxlbWVudC5fdHlwZSxcbiAgICAgICAgLi4udDIyXG4gICAgICB9XG4gICAgfSksICRbMjldID0gcHJvcHMuZWxlbWVudCwgJFszMF0gPSBzY2hlbWEsICRbMzFdID0gdDE7XG4gIH0gZWxzZVxuICAgIHQxID0gJFszMV07XG4gIGNvbnN0IGJsb2NrT2JqZWN0ID0gdDE7XG4gIGJsb2NrT2JqZWN0IHx8IGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBmaW5kIEJsb2NrIE9iamVjdCBcIiR7cHJvcHMuZWxlbWVudC5fdHlwZX1cIiBpbiBTY2hlbWFgKTtcbiAgbGV0IHQyO1xuICAkWzM0XSAhPT0gYmxvY2tPYmplY3QgfHwgJFszNV0gIT09IHByb3BzLmVsZW1lbnQuX2tleSB8fCAkWzM2XSAhPT0gcHJvcHMuZWxlbWVudC5fdHlwZSA/ICh0MiA9IGJsb2NrT2JqZWN0ID8/IHtcbiAgICBfa2V5OiBwcm9wcy5lbGVtZW50Ll9rZXksXG4gICAgX3R5cGU6IHByb3BzLmVsZW1lbnQuX3R5cGVcbiAgfSwgJFszNF0gPSBibG9ja09iamVjdCwgJFszNV0gPSBwcm9wcy5lbGVtZW50Ll9rZXksICRbMzZdID0gcHJvcHMuZWxlbWVudC5fdHlwZSwgJFszN10gPSB0MikgOiB0MiA9ICRbMzddO1xuICBsZXQgdDM7XG4gIHJldHVybiAkWzM4XSAhPT0gcHJvcHMuYXR0cmlidXRlcyB8fCAkWzM5XSAhPT0gcHJvcHMuY2hpbGRyZW4gfHwgJFs0MF0gIT09IHByb3BzLmVsZW1lbnQgfHwgJFs0MV0gIT09IHByb3BzLnJlYWRPbmx5IHx8ICRbNDJdICE9PSBwcm9wcy5yZW5kZXJCbG9jayB8fCAkWzQzXSAhPT0gdDIgPyAodDMgPSAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckJsb2NrT2JqZWN0LCB7IGF0dHJpYnV0ZXM6IHByb3BzLmF0dHJpYnV0ZXMsIGJsb2NrT2JqZWN0OiB0MiwgZWxlbWVudDogcHJvcHMuZWxlbWVudCwgcmVhZE9ubHk6IHByb3BzLnJlYWRPbmx5LCByZW5kZXJCbG9jazogcHJvcHMucmVuZGVyQmxvY2ssIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFszOF0gPSBwcm9wcy5hdHRyaWJ1dGVzLCAkWzM5XSA9IHByb3BzLmNoaWxkcmVuLCAkWzQwXSA9IHByb3BzLmVsZW1lbnQsICRbNDFdID0gcHJvcHMucmVhZE9ubHksICRbNDJdID0gcHJvcHMucmVuZGVyQmxvY2ssICRbNDNdID0gdDIsICRbNDRdID0gdDMpIDogdDMgPSAkWzQ0XSwgdDM7XG59XG5mdW5jdGlvbiBfdGVtcDQoKSB7XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gX3RlbXAzKCkge1xuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIF90ZW1wMigpIHtcbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBfdGVtcCQxKHMpIHtcbiAgcmV0dXJuIHMuY29udGV4dC5zY2hlbWE7XG59XG5jb25zdCBQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VDb250ZXh0KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQpO1xuICBpZiAoIWVkaXRvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVBvcnRhYmxlVGV4dEVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8UG9ydGFibGVUZXh0RWRpdG9yPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5mdW5jdGlvbiBjb21waWxlVHlwZShyYXdUeXBlKSB7XG4gIHJldHVybiBTY2hlbWEuY29tcGlsZSh7XG4gICAgbmFtZTogXCJibG9ja1R5cGVTY2hlbWFcIixcbiAgICB0eXBlczogW3Jhd1R5cGVdXG4gIH0pLmdldChyYXdUeXBlLm5hbWUpO1xufVxuY29uc3QgZm9yRWFjaEFjdG9yID0gKGFjdG9yUmVmLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayhhY3RvclJlZik7XG4gIGNvbnN0IGNoaWxkcmVuID0gYWN0b3JSZWYuZ2V0U25hcHNob3QoKS5jaGlsZHJlbjtcbiAgY2hpbGRyZW4gJiYgT2JqZWN0LnZhbHVlcyhjaGlsZHJlbikuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBmb3JFYWNoQWN0b3IoY2hpbGQsIGNhbGxiYWNrKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gc3RvcEFjdG9yKGFjdG9yUmVmKSB7XG4gIGNvbnN0IHBlcnNpc3RlZFNuYXBzaG90cyA9IFtdO1xuICBmb3JFYWNoQWN0b3IoYWN0b3JSZWYsIChyZWYpID0+IHtcbiAgICBwZXJzaXN0ZWRTbmFwc2hvdHMucHVzaChbcmVmLCByZWYuZ2V0U25hcHNob3QoKV0pLCByZWYub2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfSk7XG4gIGNvbnN0IHN5c3RlbVNuYXBzaG90ID0gYWN0b3JSZWYuc3lzdGVtLmdldFNuYXBzaG90Py4oKTtcbiAgYWN0b3JSZWYuc3RvcCgpLCBhY3RvclJlZi5zeXN0ZW0uX3NuYXBzaG90ID0gc3lzdGVtU25hcHNob3QsIHBlcnNpc3RlZFNuYXBzaG90cy5mb3JFYWNoKChbcmVmLCBzbmFwc2hvdF0pID0+IHtcbiAgICByZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPSAwLCByZWYuX3NuYXBzaG90ID0gc25hcHNob3Q7XG4gIH0pO1xufVxuY29uc3QgY29udmVydGVySnNvbiA9IHtcbiAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICBzZXJpYWxpemU6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHBvcnRhYmxlVGV4dENvbnZlcnRlciA9IHNuYXBzaG90LmNvbnRleHQuY29udmVydGVycy5maW5kKChjb252ZXJ0ZXIpID0+IGNvbnZlcnRlci5taW1lVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIik7XG4gICAgcmV0dXJuIHBvcnRhYmxlVGV4dENvbnZlcnRlciA/IHtcbiAgICAgIC4uLnBvcnRhYmxlVGV4dENvbnZlcnRlci5zZXJpYWxpemUoe1xuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnQsXG4gICAgICByZWFzb246IFwiTm8gYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0IENvbnZlcnRlciBmb3VuZFwiXG4gICAgfTtcbiAgfSxcbiAgZGVzZXJpYWxpemU6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHBvcnRhYmxlVGV4dENvbnZlcnRlciA9IHNuYXBzaG90LmNvbnRleHQuY29udmVydGVycy5maW5kKChjb252ZXJ0ZXIpID0+IGNvbnZlcnRlci5taW1lVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIik7XG4gICAgcmV0dXJuIHBvcnRhYmxlVGV4dENvbnZlcnRlciA/IHtcbiAgICAgIC4uLnBvcnRhYmxlVGV4dENvbnZlcnRlci5kZXNlcmlhbGl6ZSh7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudFxuICAgICAgfSksXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9IDoge1xuICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgcmVhc29uOiBcIk5vIGFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dCBDb252ZXJ0ZXIgZm91bmRcIlxuICAgIH07XG4gIH1cbn0sIGNvbnZlcnRlclBvcnRhYmxlVGV4dCA9IHtcbiAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsXG4gIHNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gc25hcHNob3QuYmV0YS5pbnRlcm5hbERyYWc/Lm9yaWdpbi5zZWxlY3Rpb24gPz8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb247XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LFxuICAgICAgICByZWFzb246IFwiTm8gc2VsZWN0aW9uXCJcbiAgICAgIH07XG4gICAgY29uc3QgYmxvY2tzID0gc2xpY2VCbG9ja3Moe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIHNjaGVtYTogc25hcHNob3QuY29udGV4dC5zY2hlbWFcbiAgICAgIH0sXG4gICAgICBibG9ja3M6IHNuYXBzaG90LmNvbnRleHQudmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgICAgIHJlYXNvbjogXCJObyBibG9ja3Mgc2VyaWFsaXplZFwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShibG9ja3MpLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsXG4gICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICB9O1xuICB9LFxuICBkZXNlcmlhbGl6ZTogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgYmxvY2tzID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmxvY2tzKSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemF0aW9uLmZhaWx1cmVcIixcbiAgICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsXG4gICAgICAgIHJlYXNvbjogXCJEYXRhIGlzIG5vdCBhbiBhcnJheVwiXG4gICAgICB9O1xuICAgIGNvbnN0IHBhcnNlZEJsb2NrcyA9IGJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkQmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgYmxvY2ssXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiB3ZSBhcmUgZHJhZ2dpbmcgaW50ZXJuYWxseSB0aGVuIHdlIHdvdWxkIGxpa2UgdG8ga2VlcCB0aGVcbiAgICAgICAgICAgKiBkcm9wcGVkIHBvcnRhYmxlIHRleHQgYXMgaXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmVmcmVzaEtleXM6ICFzbmFwc2hvdC5iZXRhLmhhc1RhZz8uKFwiZHJhZ2dpbmcgaW50ZXJuYWxseVwiKSxcbiAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VkQmxvY2sgPyBbcGFyc2VkQmxvY2tdIDogW107XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlZEJsb2Nrcy5sZW5ndGggPT09IDAgJiYgYmxvY2tzLmxlbmd0aCA+IDAgPyB7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIixcbiAgICAgIHJlYXNvbjogXCJObyBibG9ja3Mgd2VyZSBwYXJzZWRcIlxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgICBkYXRhOiBwYXJzZWRCbG9ja3MsXG4gICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIlxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVDb252ZXJ0ZXJUZXh0SHRtbChsZWdhY3lTY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L2h0bWxcIixcbiAgICBzZXJpYWxpemU6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc25hcHNob3QuYmV0YS5pbnRlcm5hbERyYWc/Lm9yaWdpbi5zZWxlY3Rpb24gPz8gc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb247XG4gICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudCxcbiAgICAgICAgICByZWFzb246IFwiTm8gc2VsZWN0aW9uXCJcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IHNsaWNlQmxvY2tzKHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hXG4gICAgICAgIH0sXG4gICAgICAgIGJsb2Nrczogc25hcHNob3QuY29udGV4dC52YWx1ZVxuICAgICAgfSksIGh0bWwgPSB0b0hUTUwoYmxvY2tzLCB7XG4gICAgICAgIG9uTWlzc2luZ0NvbXBvbmVudDogITEsXG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICB1bmtub3duVHlwZTogKHtcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgfSkgPT4gY2hpbGRyZW4gIT09IHZvaWQgMCA/IGAke2NoaWxkcmVufWAgOiBcIlwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGh0bWwgPT09IFwiXCIgPyB7XG4gICAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiLFxuICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnQsXG4gICAgICAgIHJlYXNvbjogXCJTZXJpYWxpemVkIEhUTUwgaXMgZW1wdHlcIlxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgICAgZGF0YTogaHRtbCxcbiAgICAgICAgbWltZVR5cGU6IFwidGV4dC9odG1sXCIsXG4gICAgICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICAgICAgfTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZEJsb2NrcyA9IGh0bWxUb0Jsb2NrcyhldmVudC5kYXRhLCBsZWdhY3lTY2hlbWEucG9ydGFibGVUZXh0LCB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZTogbGVnYWN5U2NoZW1hLmJsb2NrLm9wdGlvbnMudW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlXG4gICAgICB9KS5mbGF0TWFwKChibG9jaykgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmVmcmVzaEtleXM6ICExLFxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEJsb2NrID8gW3BhcnNlZEJsb2NrXSA6IFtdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VkQmxvY2tzLmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uZmFpbHVyZVwiLFxuICAgICAgICBtaW1lVHlwZTogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgcmVhc29uOiBcIk5vIGJsb2NrcyBkZXNlcmlhbGl6ZWRcIlxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgICAgICBkYXRhOiBwYXJzZWRCbG9ja3MsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvaHRtbFwiXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnRlclRleHRQbGFpbihsZWdhY3lTY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgc2VyaWFsaXplOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNuYXBzaG90LmJldGEuaW50ZXJuYWxEcmFnPy5vcmlnaW4uc2VsZWN0aW9uID8/IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbiA/IHtcbiAgICAgICAgdHlwZTogXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIixcbiAgICAgICAgZGF0YTogc2xpY2VCbG9ja3Moe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgIHNjaGVtYTogc25hcHNob3QuY29udGV4dC5zY2hlbWFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJsb2Nrczogc25hcHNob3QuY29udGV4dC52YWx1ZVxuICAgICAgICB9KS5tYXAoKGJsb2NrKSA9PiBpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBibG9jaykgPyBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fdHlwZSA9PT0gc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lID8gY2hpbGQudGV4dCA6IHNuYXBzaG90LmJldGEuaGFzVGFnKFwiZHJhZ2dpbmcgaW50ZXJuYWxseVwiKSA/IGBbJHtzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLmZpbmQoKGlubGluZU9iamVjdFR5cGUpID0+IGlubGluZU9iamVjdFR5cGUubmFtZSA9PT0gY2hpbGQuX3R5cGUpPy50aXRsZSA/PyBcIk9iamVjdFwifV1gIDogXCJcIikuam9pbihcIlwiKSA6IHNuYXBzaG90LmJldGEuaGFzVGFnKFwiZHJhZ2dpbmcgaW50ZXJuYWxseVwiKSA/IGBbJHtzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9ja09iamVjdHMuZmluZCgoYmxvY2tPYmplY3RUeXBlKSA9PiBibG9ja09iamVjdFR5cGUubmFtZSA9PT0gYmxvY2suX3R5cGUpPy50aXRsZSA/PyBcIk9iamVjdFwifV1gIDogXCJcIikuZmlsdGVyKChibG9jaykgPT4gYmxvY2sgIT09IFwiXCIpLmpvaW4oYFxuXG5gKSxcbiAgICAgICAgbWltZVR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICBvcmlnaW5FdmVudDogZXZlbnQub3JpZ2luRXZlbnRcbiAgICAgIH0gOiB7XG4gICAgICAgIHR5cGU6IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LFxuICAgICAgICByZWFzb246IFwiTm8gc2VsZWN0aW9uXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZTogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0VG9IdG1sID0gYDxodG1sPjxib2R5PiR7ZXNjYXBlSHRtbChldmVudC5kYXRhKS5zcGxpdCgvXFxuezIsfS8pLm1hcCgobGluZSkgPT4gbGluZSA/IGA8cD4ke2xpbmUucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csIFwiPGJyLz5cIil9PC9wPmAgOiBcIjxwPjwvcD5cIikuam9pbihcIlwiKX08L2JvZHk+PC9odG1sPmAsIHBhcnNlZEJsb2NrcyA9IGh0bWxUb0Jsb2Nrcyh0ZXh0VG9IdG1sLCBsZWdhY3lTY2hlbWEucG9ydGFibGVUZXh0LCB7XG4gICAgICAgIGtleUdlbmVyYXRvcjogc25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3JcbiAgICAgIH0pLmZsYXRNYXAoKGJsb2NrKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEJsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICBibG9jayxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByZWZyZXNoS2V5czogITEsXG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VkQmxvY2sgPyBbcGFyc2VkQmxvY2tdIDogW107XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZWRCbG9ja3MubGVuZ3RoID09PSAwID8ge1xuICAgICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgcmVhc29uOiBcIk5vIGJsb2NrcyBkZXNlcmlhbGl6ZWRcIlxuICAgICAgfSA6IHtcbiAgICAgICAgdHlwZTogXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgICAgICBkYXRhOiBwYXJzZWRCbG9ja3MsXG4gICAgICAgIG1pbWVUeXBlOiBcInRleHQvcGxhaW5cIlxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBlbnRpdHlNYXAgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImIzM5O1wiLFxuICBcIi9cIjogXCImI3gyRjtcIixcbiAgXCJgXCI6IFwiJiN4NjA7XCIsXG4gIFwiPVwiOiBcIiYjeDNEO1wiXG59O1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoL1smPD5cIidgPS9dL2csIChzKSA9PiBlbnRpdHlNYXBbc10pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29yZUNvbnZlcnRlcnMobGVnYWN5U2NoZW1hKSB7XG4gIHJldHVybiBbY29udmVydGVySnNvbiwgY29udmVydGVyUG9ydGFibGVUZXh0LCBjcmVhdGVDb252ZXJ0ZXJUZXh0SHRtbChsZWdhY3lTY2hlbWEpLCBjcmVhdGVDb252ZXJ0ZXJUZXh0UGxhaW4obGVnYWN5U2NoZW1hKV07XG59XG5jb25zdCBkZWJ1ZyRoID0gZGVidWdXaXRoTmFtZShcIm9wZXJhdGlvblRvUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZU9wZXJhdGlvblRvUGF0Y2hlcyhlZGl0b3JBY3Rvcikge1xuICBjb25zdCB0ZXh0QmxvY2tOYW1lID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lO1xuICBmdW5jdGlvbiBpbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgZGVidWckaC5lbmFibGVkICYmIGRlYnVnJGgoXCJPcGVyYXRpb25cIiwgSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLCBudWxsLCAyKSk7XG4gICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gICAgY29uc3QgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pICYmIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICBpZiAoIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGNoaWxkXCIpO1xuICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdGV4dENoaWxkLl9rZXlcbiAgICB9LCBcInRleHRcIl0sIHByZXZCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldkNoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKHByZXZCbG9jaykgJiYgcHJldkJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2Q2hpbGQpID8gcHJldkNoaWxkLnRleHQgOiBcIlwiLCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoJDEocHJldlRleHQsIHRleHRDaGlsZC50ZXh0LCBwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2gudmFsdWUubGVuZ3RoID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGVkaXRvciAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghYmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgICBjb25zdCBjaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIHx8IHZvaWQgMCwgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpID8gY2hpbGQgOiB2b2lkIDA7XG4gICAgaWYgKGNoaWxkICYmICF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzcGFuXCIpO1xuICAgIGlmICghdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBfa2V5OiB0ZXh0Q2hpbGQuX2tleVxuICAgIH0sIFwidGV4dFwiXSwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHByZXZUZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmVmb3JlQmxvY2spICYmIGJlZm9yZUJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2VGV4dENoaWxkKSAmJiBwcmV2VGV4dENoaWxkLnRleHQsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCB8fCBcIlwiLCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2suX2tleSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9jayB0byBoYXZlIGEgX2tleVwiKTtcbiAgICAgIGNvbnN0IHNldE5vZGUgPSBvbWl0Qnkoe1xuICAgICAgICAuLi5lZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dLFxuICAgICAgICAuLi5vcGVyYXRpb24ubmV3UHJvcGVydGllc1xuICAgICAgfSwgaXNVbmRlZmluZWQpO1xuICAgICAgcmV0dXJuIFtzZXQoZnJvbVNsYXRlVmFsdWUoW3NldE5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXSwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pXTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrS2V5ID0gYmxvY2suX2tleSwgY2hpbGRLZXkgPSBjaGlsZC5fa2V5LCBwYXRjaGVzID0gW10sIGtleXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24ubmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgcmV0dXJuIGtleXMuZm9yRWFjaCgoa2V5TmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleU5hbWUgPT09IFwiX2tleVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICAgIHBhdGNoZXMucHVzaChzZXQodmFsLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIGtleU5hbWVdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9ja0tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZEtleVxuICAgICAgICAgICAgICB9LCBrZXlOYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBwYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgY2hpbGRcIik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkIGJsb2NrXCIpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHBhdGggZW5jb3VudGVyZWQ6ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIGluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgaXNUZXh0QmxvY2syID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5wYXRoWzBdID09PSAwID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIiwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXSAtIDFdLCB0YXJnZXRLZXkgPSBvcGVyYXRpb24ucGF0aFswXSA9PT0gMCA/IGJsb2NrPy5fa2V5IDogYmVmb3JlQmxvY2s/Ll9rZXk7XG4gICAgICByZXR1cm4gdGFyZ2V0S2V5ID8gW2luc2VydChbZnJvbVNsYXRlVmFsdWUoW29wZXJhdGlvbi5ub2RlXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBwb3NpdGlvbiwgW3tcbiAgICAgICAgX2tleTogdGFyZ2V0S2V5XG4gICAgICB9XSldIDogW3NldElmTWlzc2luZyhiZWZvcmVWYWx1ZSwgW10pLCBpbnNlcnQoW2Zyb21TbGF0ZVZhbHVlKFtvcGVyYXRpb24ubm9kZV0sIHRleHRCbG9ja05hbWUpWzBdXSwgXCJiZWZvcmVcIiwgW29wZXJhdGlvbi5wYXRoWzBdXSldO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0QmxvY2syICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCAhYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIsIG5vZGUgPSB7XG4gICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlXG4gICAgICB9O1xuICAgICAgIW5vZGUuX3R5cGUgJiYgVGV4dC5pc1RleHQobm9kZSkgJiYgKG5vZGUuX3R5cGUgPSBcInNwYW5cIiwgbm9kZS5tYXJrcyA9IFtdKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gZnJvbVNsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogXCJib2d1c1wiLFxuICAgICAgICBfdHlwZTogdGV4dEJsb2NrTmFtZSxcbiAgICAgICAgY2hpbGRyZW46IFtub2RlXVxuICAgICAgfV0sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuWzBdO1xuICAgICAgcmV0dXJuIFtpbnNlcnQoW2NoaWxkXSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoIDw9IDEgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyAwIDoge1xuICAgICAgICBfa2V5OiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdLl9rZXlcbiAgICAgIH1dKV07XG4gICAgfVxuICAgIHJldHVybiBkZWJ1ZyRoKFwiU29tZXRoaW5nIHdhcyBpbnNlcnRlZCBpbnRvIGEgdm9pZCBibG9jay4gTm90IHByb2R1Y2luZyBlZGl0b3IgcGF0Y2hlcy5cIiksIFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgc3BsaXRCbG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soc3BsaXRCbG9jaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggcGF0aCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5wYXRoWzBdKX0gaXMgbm90IGEgdGV4dCBibG9jayBhbmQgY2FuJ3QgYmUgc3BsaXRgKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBvbGRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sob2xkQmxvY2spKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZnJvbVNsYXRlVmFsdWUoW2VkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXSArIDFdXSwgdGV4dEJsb2NrTmFtZSlbMF07XG4gICAgICAgIHRhcmdldFZhbHVlICYmIChwYXRjaGVzLnB1c2goaW5zZXJ0KFt0YXJnZXRWYWx1ZV0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICBfa2V5OiBzcGxpdEJsb2NrLl9rZXlcbiAgICAgICAgfV0pKSwgb2xkQmxvY2suY2hpbGRyZW4uc2xpY2Uob3BlcmF0aW9uLnBvc2l0aW9uKS5mb3JFYWNoKChzcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICAgICAgICBfa2V5OiBvbGRCbG9jay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXlcbiAgICAgICAgICB9XTtcbiAgICAgICAgICBwYXRjaGVzLnB1c2godW5zZXQocGF0aCkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICB9XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qgc3BsaXRTcGFuID0gc3BsaXRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oc3BsaXRTcGFuKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTcGFucyA9IGZyb21TbGF0ZVZhbHVlKFt7XG4gICAgICAgICAgLi4uc3BsaXRCbG9jayxcbiAgICAgICAgICBjaGlsZHJlbjogc3BsaXRCbG9jay5jaGlsZHJlbi5zbGljZShvcGVyYXRpb24ucGF0aFsxXSArIDEsIG9wZXJhdGlvbi5wYXRoWzFdICsgMilcbiAgICAgICAgfV0sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuO1xuICAgICAgICBwYXRjaGVzLnB1c2goaW5zZXJ0KHRhcmdldFNwYW5zLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwbGl0U3Bhbi5fa2V5XG4gICAgICAgIH1dKSksIHBhdGNoZXMucHVzaChzZXQoc3BsaXRTcGFuLnRleHQsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwbGl0U3Bhbi5fa2V5XG4gICAgICAgIH0sIFwidGV4dFwiXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgYmxvY2suX2tleSlcbiAgICAgICAgcmV0dXJuIFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0pXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIG5vdCBmb3VuZFwiKTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBzcGFuVG9SZW1vdmUgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICByZXR1cm4gc3BhblRvUmVtb3ZlID8gYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IG9wZXJhdGlvbi5ub2RlLl9rZXkpLmxlbmd0aCA+IDEgPyAoY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHtvcGVyYXRpb24ubm9kZS5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHJlbW92ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpLCBbXSkgOiBbdW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHNwYW5Ub1JlbW92ZS5fa2V5XG4gICAgICB9XSldIDogKGRlYnVnJGgoXCJTcGFuIG5vdCBmb3VuZCBpbiBlZGl0b3IgdHJ5aW5nIHRvIHJlbW92ZSBub2RlXCIpLCBbXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZGVidWckaChcIk5vdCBjcmVhdGluZyBwYXRjaCBpbnNpZGUgb2JqZWN0IGJsb2NrXCIpLCBbXTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCB1cGRhdGVkQmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpXG4gICAgICBpZiAoYmxvY2s/Ll9rZXkpIHtcbiAgICAgICAgY29uc3QgbmV3QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdIC0gMV1dLCB0ZXh0QmxvY2tOYW1lKVswXTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHNldChuZXdCbG9jaywgW3tcbiAgICAgICAgICBfa2V5OiBuZXdCbG9jay5fa2V5XG4gICAgICAgIH1dKSksIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0pKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQga2V5IG5vdCBmb3VuZCFcIik7XG4gICAgZWxzZSBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2sodXBkYXRlZEJsb2NrKSAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTcGFuID0gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gJiYgZWRpdG9yLmlzVGV4dFNwYW4odXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0pID8gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gOiB2b2lkIDAsIHJlbW92ZWRTcGFuID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSkgPyBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gOiB2b2lkIDA7XG4gICAgICB1cGRhdGVkU3BhbiAmJiAoYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IHVwZGF0ZWRTcGFuLl9rZXkpLmxlbmd0aCA9PT0gMSA/IHBhdGNoZXMucHVzaChzZXQodXBkYXRlZFNwYW4udGV4dCwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHVwZGF0ZWRTcGFuLl9rZXlcbiAgICAgIH0sIFwidGV4dFwiXSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHt1cGRhdGVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHVwZGF0ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKSwgcmVtb3ZlZFNwYW4gJiYgKGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSByZW1vdmVkU3Bhbi5fa2V5KS5sZW5ndGggPT09IDEgPyBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHJlbW92ZWRTcGFuLl9rZXlcbiAgICAgIH1dKSkgOiBjb25zb2xlLndhcm4oYE11bHRpcGxlIHNwYW5zIGhhdmUgXFxgX2tleVxcYCAke3JlbW92ZWRTcGFuLl9rZXl9LiBJdCdzIGFtYmlndW91cyB3aGljaCBvbmUgdG8gcmVtb3ZlLmAsIEpTT04uc3RyaW5naWZ5KGJsb2NrLCBudWxsLCAyKSkpO1xuICAgIH0gZWxzZVxuICAgICAgZGVidWckaChcIlZvaWQgbm9kZXMgY2FuJ3QgYmUgbWVyZ2VkLCBub3QgY3JlYXRpbmcgYW55IHBhdGNoZXNcIik7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCB0YXJnZXRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5uZXdQYXRoWzBdXTtcbiAgICBpZiAoIXRhcmdldEJsb2NrKVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA+IG9wZXJhdGlvbi5uZXdQYXRoWzBdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRCbG9jay5fa2V5XG4gICAgICB9XSkpO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKHRhcmdldEJsb2NrKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHRhcmdldENoaWxkID0gdGFyZ2V0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLm5ld1BhdGhbMV1dLCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5uZXdQYXRoWzFdID09PSB0YXJnZXRCbG9jay5jaGlsZHJlbi5sZW5ndGggPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiLCBjaGlsZFRvSW5zZXJ0ID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF0uY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtjaGlsZFRvSW5zZXJ0XSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IHRhcmdldEJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiB0YXJnZXRDaGlsZC5fa2V5XG4gICAgICB9XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc2VydE5vZGVQYXRjaCxcbiAgICBpbnNlcnRUZXh0UGF0Y2gsXG4gICAgbWVyZ2VOb2RlUGF0Y2gsXG4gICAgbW92ZU5vZGVQYXRjaCxcbiAgICByZW1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlVGV4dFBhdGNoLFxuICAgIHNldE5vZGVQYXRjaCxcbiAgICBzcGxpdE5vZGVQYXRjaFxuICB9O1xufVxuY29uc3QgaW5zZXJ0VGV4dE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIG9wZXJhdGlvbi5lZGl0b3IubWFya3MgPyBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICB0ZXh0OiBvcGVyYXRpb24udGV4dCxcbiAgICAuLi5vcGVyYXRpb24uZWRpdG9yLm1hcmtzXG4gIH0pIDogVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KG9wZXJhdGlvbi5lZGl0b3IsIG9wZXJhdGlvbi50ZXh0KSwgb3BlcmF0aW9uLmVkaXRvci5tYXJrcyA9IG51bGw7XG59O1xuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwic3BhblwiICYmIFwidGV4dFwiIGluIG5vZGUgJiYgdHlwZW9mIG5vZGUudGV4dCA9PSBcInN0cmluZ1wiICYmICh0eXBlb2Ygbm9kZS5tYXJrcyA+IFwidVwiIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5ldmVyeSgobWFyaykgPT4gdHlwZW9mIG1hcmsgPT0gXCJzdHJpbmdcIikpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBibG9jayBkb2Vzbid0IF9oYXZlXyB0byBiZSBuYW1lZCAnYmxvY2snIC0gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgLy8gYWxsb3dlZCBjaGlsZCB0eXBlcyBhbmQgbWFya3MsIG9uZSBtaWdodCBuYW1lIHRoZW0gZGlmZmVyZW50bHlcbiAgICB0eXBlb2Ygbm9kZS5fdHlwZSA9PSBcInN0cmluZ1wiICYmIC8vIFRvb2xraXQtdHlwZXMgbGlrZSBuZXN0ZWQgc3BhbnMgYXJlIEAtcHJlZml4ZWRcbiAgICBub2RlLl90eXBlWzBdICE9PSBcIkBcIiAmJiAvLyBgbWFya0RlZnNgIGlzbid0IF9yZXF1aXJlZF8gcGVyIHNheSwgYnV0IGlmIGl0J3MgdGhlcmUsIGl0IG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgKCEoXCJtYXJrRGVmc1wiIGluIG5vZGUpIHx8ICFub2RlLm1hcmtEZWZzIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiYgLy8gRXZlcnkgbWFyayBkZWZpbml0aW9uIG5lZWRzIHRvIGhhdmUgYW4gYF9rZXlgIHRvIGJlIG1hcHBhYmxlIGluIGNoaWxkIHNwYW5zXG4gICAgbm9kZS5tYXJrRGVmcy5ldmVyeSgoZGVmKSA9PiB0eXBlb2YgZGVmLl9rZXkgPT0gXCJzdHJpbmdcIikpICYmIC8vIGBjaGlsZHJlbmAgaXMgcmVxdWlyZWQgYW5kIG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSAmJiAvLyBBbGwgY2hpbGRyZW4gYXJlIG9iamVjdHMgd2l0aCBgX3R5cGVgICh1c3VhbGx5IHNwYW5zLCBidXQgY2FuIGNvbnRhaW4gb3RoZXIgc3R1ZmYpXG4gICAgbm9kZS5jaGlsZHJlbi5ldmVyeSgoY2hpbGQpID0+IHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIFwiX3R5cGVcIiBpbiBjaGlsZClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzU3Bhbih7XG4gIGVkaXRvcixcbiAgYmxvY2tQYXRoLFxuICBzcGFuUGF0aFxufSkge1xuICBsZXQgcHJldmlvdXNTcGFuO1xuICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoLCB7XG4gICAgcmV2ZXJzZTogITBcbiAgfSkpXG4gICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQmVmb3JlKGNoaWxkUGF0aCwgc3BhblBhdGgpKSB7XG4gICAgICBwcmV2aW91c1NwYW4gPSBjaGlsZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIHByZXZpb3VzU3Bhbjtcbn1cbmZ1bmN0aW9uIGdldE5leHRTcGFuKHtcbiAgZWRpdG9yLFxuICBibG9ja1BhdGgsXG4gIHNwYW5QYXRoXG59KSB7XG4gIGxldCBuZXh0U3BhbjtcbiAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCkpXG4gICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQWZ0ZXIoY2hpbGRQYXRoLCBzcGFuUGF0aCkpIHtcbiAgICAgIG5leHRTcGFuID0gY2hpbGQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBuZXh0U3Bhbjtcbn1cbmZ1bmN0aW9uIHdpdGhSZW1vdGVDaGFuZ2VzKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpIHx8ICExO1xuICBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpIHtcbiAgcmV0dXJuIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuZ2V0KGVkaXRvcik7XG59XG5jb25zdCBJU19VRE9JTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfUkVET0lORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aFVuZG9pbmcoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNVbmRvaW5nKGVkaXRvcik7XG4gIElTX1VET0lORy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1VET0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzVW5kb2luZyhlZGl0b3IpIHtcbiAgcmV0dXJuIElTX1VET0lORy5nZXQoZWRpdG9yKSA/PyAhMTtcbn1cbmZ1bmN0aW9uIHNldElzVW5kb2luZyhlZGl0b3IsIGlzVW5kb2luZzIpIHtcbiAgSVNfVURPSU5HLnNldChlZGl0b3IsIGlzVW5kb2luZzIpO1xufVxuZnVuY3Rpb24gd2l0aFJlZG9pbmcoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNSZWRvaW5nKGVkaXRvcik7XG4gIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgITApLCBmbigpLCBJU19SRURPSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNSZWRvaW5nKGVkaXRvcikge1xuICByZXR1cm4gSVNfUkVET0lORy5nZXQoZWRpdG9yKSA/PyAhMTtcbn1cbmZ1bmN0aW9uIHNldElzUmVkb2luZyhlZGl0b3IsIGlzUmVkb2luZzIpIHtcbiAgSVNfUkVET0lORy5zZXQoZWRpdG9yLCBpc1JlZG9pbmcyKTtcbn1cbmNvbnN0IGRlYnVnJGcgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWxcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0TWFya01vZGVsKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyLFxuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3IsIGRlY29yYXRvcnMgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMubWFwKCh0KSA9PiB0Lm5hbWUpO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IG5vZGVFbnRyeTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBub2RlLmNoaWxkcmVuW2NoaWxkUGF0aFsxXSArIDFdO1xuICAgICAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgZWRpdG9yLmlzVGV4dFNwYW4obmV4dE5vZGUpICYmIGNoaWxkLm1hcmtzPy5ldmVyeSgobWFyaykgPT4gbmV4dE5vZGUubWFya3M/LmluY2x1ZGVzKG1hcmspKSAmJiBuZXh0Tm9kZS5tYXJrcz8uZXZlcnkoKG1hcmspID0+IGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSkpIHtcbiAgICAgICAgICAgIGRlYnVnJGcoXCJNZXJnaW5nIHNwYW5zXCIsIEpTT04uc3RyaW5naWZ5KGNoaWxkLCBudWxsLCAyKSwgSlNPTi5zdHJpbmdpZnkobmV4dE5vZGUsIG51bGwsIDIpKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IFtjaGlsZFBhdGhbMF0sIGNoaWxkUGF0aFsxXSArIDFdLFxuICAgICAgICAgICAgICB2b2lkczogITBcbiAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiAhQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSkge1xuICAgICAgICBkZWJ1ZyRnKFwiQWRkaW5nIC5tYXJrRGVmcyB0byBibG9jayBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya0RlZnM6IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSAmJiAhQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSkge1xuICAgICAgICBkZWJ1ZyRnKFwiQWRkaW5nIC5tYXJrcyB0byBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrUGF0aCA9IFBhdGgucGFyZW50KHBhdGgpLCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBibG9ja1BhdGgpLCBkZWNvcmF0b3JzMiA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpLCBhbm5vdGF0aW9ucyA9IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgbm9kZS50ZXh0ID09PSBcIlwiICYmIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZyRnKFwiUmVtb3ZpbmcgYW5ub3RhdGlvbnMgZnJvbSBlbXB0eSBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrczogbm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvcnMyID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSk7XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIW5vZGUubWFya0RlZnM/LmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZGVidWckZyhcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpLCBtYXJrcyA9IG5vZGUubWFya3MgPz8gW10sIG9ycGhhbmVkQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSAmJiAhYmxvY2subWFya0RlZnM/LmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgICAgICBpZiAob3JwaGFuZWRBbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyRnKFwiUmVtb3Zpbmcgb3JwaGFuZWQgYW5ub3RhdGlvbnMgZnJvbSBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBtYXJrczogbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhb3JwaGFuZWRBbm5vdGF0aW9ucy5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBtYXJrRGVmcyA9IG5vZGUubWFya0RlZnMgPz8gW10sIG1hcmtEZWZLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbmV3TWFya0RlZnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtYXJrRGVmIG9mIG1hcmtEZWZzKVxuICAgICAgICAgIG1hcmtEZWZLZXlzLmhhcyhtYXJrRGVmLl9rZXkpIHx8IChtYXJrRGVmS2V5cy5hZGQobWFya0RlZi5fa2V5KSwgbmV3TWFya0RlZnMucHVzaChtYXJrRGVmKSk7XG4gICAgICAgIGlmIChtYXJrRGVmcy5sZW5ndGggIT09IG5ld01hcmtEZWZzLmxlbmd0aCkge1xuICAgICAgICAgIGRlYnVnJGcoXCJSZW1vdmluZyBkdXBsaWNhdGUgbWFya0RlZnNcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmICFlZGl0b3Iub3BlcmF0aW9ucy5zb21lKChvcCkgPT4gb3AudHlwZSA9PT0gXCJtZXJnZV9ub2RlXCIgJiYgXCJtYXJrRGVmc1wiIGluIG9wLnByb3BlcnRpZXMgJiYgb3AucGF0aC5sZW5ndGggPT09IDEpKSB7XG4gICAgICAgIGNvbnN0IG5ld01hcmtEZWZzID0gKG5vZGUubWFya0RlZnMgfHwgW10pLmZpbHRlcigoZGVmKSA9PiBub2RlLmNoaWxkcmVuLmZpbmQoKGNoaWxkKSA9PiBUZXh0LmlzVGV4dChjaGlsZCkgJiYgQXJyYXkuaXNBcnJheShjaGlsZC5tYXJrcykgJiYgY2hpbGQubWFya3MuaW5jbHVkZXMoZGVmLl9rZXkpKSk7XG4gICAgICAgIGlmIChub2RlLm1hcmtEZWZzICYmICFpc0VxdWFsKG5ld01hcmtEZWZzLCBub2RlLm1hcmtEZWZzKSkge1xuICAgICAgICAgIGRlYnVnJGcoXCJSZW1vdmluZyBtYXJrRGVmIG5vdCBpbiB1c2VcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3JtYWxpemVOb2RlKG5vZGVFbnRyeSk7XG4gICAgfSwgZWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBFZGl0b3IubWFya3MoZWRpdG9yKSAmJiBvcC5wcm9wZXJ0aWVzICYmIG9wLm5ld1Byb3BlcnRpZXMgJiYgb3AucHJvcGVydGllcy5hbmNob3IgJiYgb3AucHJvcGVydGllcy5mb2N1cyAmJiBvcC5uZXdQcm9wZXJ0aWVzLmFuY2hvciAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBSYW5nZS5pc0NvbGxhcHNlZCh7XG4gICAgICAgICAgYW5jaG9yOiBvcC5wcm9wZXJ0aWVzLmFuY2hvcixcbiAgICAgICAgICBmb2N1czogb3AucHJvcGVydGllcy5mb2N1c1xuICAgICAgICB9KSwgbmV3U2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBSYW5nZS5pc0NvbGxhcHNlZCh7XG4gICAgICAgICAgYW5jaG9yOiBvcC5uZXdQcm9wZXJ0aWVzLmFuY2hvcixcbiAgICAgICAgICBmb2N1czogb3AubmV3UHJvcGVydGllcy5mb2N1c1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0aW9uSXNDb2xsYXBzZWQgJiYgbmV3U2VsZWN0aW9uSXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICBjb25zdCBmb2N1c1NwYW4gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogb3AucHJvcGVydGllcy5mb2N1cyxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0/LlswXSwgbmV3Rm9jdXNTcGFuID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMsXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdPy5bMF0sIG1vdmVkVG9OZXh0U3BhbiA9IGZvY3VzU3BhbiAmJiBuZXdGb2N1c1NwYW4gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzBdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzFdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gKyAxICYmIGZvY3VzU3Bhbi50ZXh0Lmxlbmd0aCA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5vZmZzZXQgJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5vZmZzZXQgPT09IDAsIG1vdmVkVG9QcmV2aW91c1NwYW4gPSBmb2N1c1NwYW4gJiYgbmV3Rm9jdXNTcGFuICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFswXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzBdICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFsxXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzFdIC0gMSAmJiBvcC5wcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCA9PT0gMCAmJiBuZXdGb2N1c1NwYW4udGV4dC5sZW5ndGggPT09IG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMub2Zmc2V0O1xuICAgICAgICAgIGlmIChtb3ZlZFRvTmV4dFNwYW4gfHwgbW92ZWRUb1ByZXZpb3VzU3BhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwiaW5zZXJ0X25vZGVcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBbX2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSksIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aDogb3AucGF0aFxuICAgICAgICAgIH0pLCBwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucyA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgOiBbXSwgbmV4dFNwYW4gPSBnZXROZXh0U3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aDogW29wLnBhdGhbMF0sIG9wLnBhdGhbMV0gLSAxXVxuICAgICAgICAgIH0pLCBuZXh0U3BhbkFubm90YXRpb25zID0gbmV4dFNwYW4gPyBuZXh0U3Bhbi5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgOiBbXSwgYW5ub3RhdGlvbnNFbmRpbmcgPSBwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucz8uZmlsdGVyKChhbm5vdGF0aW9uKSA9PiAhbmV4dFNwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMoYW5ub3RhdGlvbikpID8/IFtdLCBhdFRoZUVuZE9mQW5ub3RhdGlvbiA9IGFubm90YXRpb25zRW5kaW5nLmxlbmd0aCA+IDA7XG4gICAgICAgICAgaWYgKGF0VGhlRW5kT2ZBbm5vdGF0aW9uICYmIGlzUG9ydGFibGVUZXh0U3BhbihvcC5ub2RlKSAmJiBvcC5ub2RlLm1hcmtzPy5zb21lKChtYXJrKSA9PiBhbm5vdGF0aW9uc0VuZGluZy5pbmNsdWRlcyhtYXJrKSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIC4uLm9wLm5vZGUsXG4gICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSA/PyBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zU3RhcnRpbmcgPSBuZXh0U3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMoYW5ub3RhdGlvbikpID8/IFtdLCBhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNTdGFydGluZy5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uICYmIGlzUG9ydGFibGVUZXh0U3BhbihvcC5ub2RlKSAmJiBvcC5ub2RlLm1hcmtzPy5zb21lKChtYXJrKSA9PiBhbm5vdGF0aW9uc1N0YXJ0aW5nLmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgLi4ub3Aubm9kZSxcbiAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICBtYXJrczogb3Aubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhYW5ub3RhdGlvbnNTdGFydGluZy5pbmNsdWRlcyhtYXJrKSkgPz8gW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXh0U3BhbkRlY29yYXRvcnMgPSBuZXh0U3Bhbj8ubWFya3M/LmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgPz8gW107XG4gICAgICAgICAgaWYgKG5leHRTcGFuRGVjb3JhdG9ycy5sZW5ndGggPiAwICYmIGF0VGhlRW5kT2ZBbm5vdGF0aW9uICYmICFhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uICYmIGlzUG9ydGFibGVUZXh0U3BhbihvcC5ub2RlKSAmJiBvcC5ub2RlLm1hcmtzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIC4uLm9wLm5vZGUsXG4gICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgbWFya3M6IG5leHRTcGFuRGVjb3JhdG9yc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvciwgY29sbGFwc2VkU2VsZWN0aW9uID0gc2VsZWN0aW9uID8gUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSA6ICExO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIGNvbGxhcHNlZFNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IFtfYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgW3NwYW4sIHNwYW5QYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBzZWxlY3Rpb24uZm9jdXMsXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdID8/IFt2b2lkIDAsIHZvaWQgMF0sIG1hcmtzID0gc3Bhbi5tYXJrcyA/PyBbXSwgbWFya3NXaXRob3V0QW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpLCBzcGFuSGFzQW5ub3RhdGlvbnMgPSBtYXJrcy5sZW5ndGggPiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9ucy5sZW5ndGgsIHNwYW5Jc0VtcHR5ID0gc3Bhbi50ZXh0Lmxlbmd0aCA9PT0gMCwgYXRUaGVCZWdpbm5pbmdPZlNwYW4gPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCwgYXRUaGVFbmRPZlNwYW4gPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gc3Bhbi50ZXh0Lmxlbmd0aCwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgfSksIG5leHRTcGFuID0gZ2V0TmV4dFNwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICB9KSwgbmV4dFNwYW5Bbm5vdGF0aW9ucyA9IG5leHRTcGFuPy5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgPz8gW10sIHNwYW5Bbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpLCBwcmV2aW91c1NwYW5IYXNBbm5vdGF0aW9ucyA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uc29tZSgobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpIDogITEsIHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9ucyA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkuZXZlcnkoKG1hcmspID0+IG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uc29tZSgobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykgJiYgbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIHByZXZpb3VzU3Bhbkhhc1NhbWVNYXJrcyA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uZXZlcnkoKG1hcmspID0+IG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucyA9IHNwYW5Bbm5vdGF0aW9ucy5zb21lKChtYXJrKSA9PiBuZXh0U3BhbkFubm90YXRpb25zPy5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgICAgaWYgKHNwYW5IYXNBbm5vdGF0aW9ucyAmJiAhc3BhbklzRW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChhdFRoZUJlZ2lubmluZ09mU3Bhbikge1xuICAgICAgICAgICAgICBpZiAocHJldmlvdXNTcGFuSGFzU2FtZU1hcmtzKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogcHJldmlvdXNTcGFuPy5tYXJrcyA/PyBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBwcmV2aW91c1NwYW4/Lm1hcmtzID8/IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXByZXZpb3VzU3Bhbikge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRUaGVFbmRPZlNwYW4pIHtcbiAgICAgICAgICAgICAgaWYgKG5leHRTcGFuICYmIG5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zICYmIG5leHRTcGFuQW5ub3RhdGlvbnMubGVuZ3RoIDwgc3BhbkFubm90YXRpb25zLmxlbmd0aCB8fCAhbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBuZXh0U3Bhbj8ubWFya3MgPz8gW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFuZXh0U3Bhbikge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdFRoZUJlZ2lubmluZ09mU3BhbiAmJiAhc3BhbklzRW1wdHkgJiYgcHJldmlvdXNTcGFuKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbkhhc0Fubm90YXRpb25zID8gW10gOiAocHJldmlvdXNTcGFuLm1hcmtzID8/IFtdKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcInJlbW92ZV90ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBbc3Bhbiwgc3BhblBhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IHtcbiAgICAgICAgICAgICAgcGF0aDogb3AucGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvcC5vZmZzZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gICAgICAgICAgaWYgKHNwYW4gJiYgYmxvY2sgJiYgaXNQb3J0YWJsZVRleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW10sIG1hcmtzID0gc3Bhbi5tYXJrcyA/PyBbXSwgc3Bhbkhhc0Fubm90YXRpb25zID0gbWFya3Muc29tZSgobWFyaykgPT4gbWFya0RlZnMuZmluZCgobWFya0RlZikgPT4gbWFya0RlZi5fa2V5ID09PSBtYXJrKSksIGRlbGV0aW5nRnJvbVRoZUVuZCA9IG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBzcGFuLnRleHQubGVuZ3RoLCBkZWxldGluZ0FsbFRleHQgPSBvcC5vZmZzZXQgPT09IDAgJiYgZGVsZXRpbmdGcm9tVGhlRW5kLCBwcmV2aW91c1NwYW4gPSBnZXRQcmV2aW91c1NwYW4oe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICAgIH0pLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBuZXh0U3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gbmV4dFNwYW4gPyBuZXh0U3Bhbi5tYXJrcz8uc29tZSgobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykgJiYgbWFya3MuaW5jbHVkZXMobWFyaykpIDogITE7XG4gICAgICAgICAgICBpZiAoc3Bhbkhhc0Fubm90YXRpb25zICYmIGRlbGV0aW5nQWxsVGV4dCAmJiAhcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gJiYgIW5leHRTcGFuSGFzU2FtZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFya3NXaXRob3V0QW5ub3RhdGlvbk1hcmtzID0gKHtcbiAgICAgICAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgICAgICAgICB9Lm1hcmtzIHx8IFtdKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpO1xuICAgICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFwcGx5MihvcCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBtYXJrczogbWFya3NXaXRob3V0QW5ub3RhdGlvbk1hcmtzXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgYXQ6IG9wLnBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJtZXJnZV9ub2RlXCIgJiYgb3AucGF0aC5sZW5ndGggPT09IDEgJiYgXCJtYXJrRGVmc1wiIGluIG9wLnByb3BlcnRpZXMgJiYgb3AucHJvcGVydGllcy5fdHlwZSA9PT0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lICYmIEFycmF5LmlzQXJyYXkob3AucHJvcGVydGllcy5tYXJrRGVmcykgJiYgb3AucHJvcGVydGllcy5tYXJrRGVmcy5sZW5ndGggPiAwICYmIG9wLnBhdGhbMF0gLSAxID49IDApIHtcbiAgICAgICAgY29uc3QgW3RhcmdldEJsb2NrLCB0YXJnZXRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgW29wLnBhdGhbMF0gLSAxXSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sodGFyZ2V0QmxvY2spKSB7XG4gICAgICAgICAgY29uc3Qgb2xkRGVmcyA9IEFycmF5LmlzQXJyYXkodGFyZ2V0QmxvY2subWFya0RlZnMpICYmIHRhcmdldEJsb2NrLm1hcmtEZWZzIHx8IFtdLCBuZXdNYXJrRGVmcyA9IHVuaXEoWy4uLm9sZERlZnMsIC4uLm9wLnByb3BlcnRpZXMubWFya0RlZnNdKTtcbiAgICAgICAgICBkZWJ1ZyRnKFwiQ29weWluZyBtYXJrRGVmcyBvdmVyIHRvIG1lcmdlZCBibG9ja1wiLCBvcCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pLCBhcHBseTIob3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXBwbHkyKG9wKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCByZW1vdmVEZWNvcmF0b3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBvcGVyYXRpb24uZWRpdG9yLCBtYXJrID0gb3BlcmF0aW9uLmRlY29yYXRvciwge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSlcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgIHNwbGl0OiAhMCxcbiAgICAgICAgaGFuZ2luZzogITBcbiAgICAgIH0pLCBlZGl0b3Iuc2VsZWN0aW9uICYmIFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgIH0pXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bcGF0aFswXV07XG4gICAgICAgIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmluY2x1ZGVzKG5vZGUpICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IChBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksXG4gICAgICAgICAgX3R5cGU6IFwic3BhblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pLCBsb25lbHlFbXB0eVNwYW4gPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlblswXSkgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIiA/IGJsb2NrLmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICAgICAgaWYgKGxvbmVseUVtcHR5U3Bhbikge1xuICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvciA9IChsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10pLmZpbHRlcigoZXhpc3RpbmdNYXJrKSA9PiBleGlzdGluZ01hcmsgIT09IG1hcmspO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvclxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrcyA9IHtcbiAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgICB9Lm1hcmtzIHx8IFtdLCBtYXJrcyA9IHtcbiAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSxcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyaylcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0ge1xuICAgICAgICAgIG1hcmtzOiBtYXJrcy5tYXJrcyxcbiAgICAgICAgICBfdHlwZTogXCJzcGFuXCJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbjIgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4uc2VsZWN0aW9uMlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc0RlY29yYXRvckFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgZGVjb3JhdG9yXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKTtcbiAgcmV0dXJuIHNlbGVjdGVkVGV4dE5vZGVzLmxlbmd0aCA9PT0gMCA/ICExIDogUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSA/IHNlbGVjdGVkVGV4dE5vZGVzLmV2ZXJ5KChuKSA9PiB7XG4gICAgY29uc3QgW25vZGVdID0gbjtcbiAgICByZXR1cm4gbm9kZS5tYXJrcz8uaW5jbHVkZXMoZGVjb3JhdG9yKTtcbiAgfSkgOiAoe1xuICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gIH0ubWFya3MgfHwgW10pLmluY2x1ZGVzKGRlY29yYXRvcik7XG59XG5mdW5jdGlvbiBjbG9uZURpZmYoZGlmZjIpIHtcbiAgY29uc3QgW3R5cGUsIHBhdGNoXSA9IGRpZmYyO1xuICByZXR1cm4gW3R5cGUsIHBhdGNoXTtcbn1cbmZ1bmN0aW9uIGdldENvbW1vbk92ZXJsYXAodGV4dEEsIHRleHRCKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIGlmICh0ZXh0MUxlbmd0aCA9PT0gMCB8fCB0ZXh0Mkxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIHRleHQxTGVuZ3RoID4gdGV4dDJMZW5ndGggPyB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoKSA6IHRleHQxTGVuZ3RoIDwgdGV4dDJMZW5ndGggJiYgKHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxTGVuZ3RoKSk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSBNYXRoLm1pbih0ZXh0MUxlbmd0aCwgdGV4dDJMZW5ndGgpO1xuICBpZiAodGV4dDEgPT09IHRleHQyKSByZXR1cm4gdGV4dExlbmd0aDtcbiAgbGV0IGJlc3QgPSAwLCBsZW5ndGggPSAxO1xuICBmb3IgKGxldCBmb3VuZCA9IDA7IGZvdW5kICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBpZiAoZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pLCBmb3VuZCA9PT0gLTEpIHJldHVybiBiZXN0O1xuICAgIGxlbmd0aCArPSBmb3VuZCwgKGZvdW5kID09PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKSA9PT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpICYmIChiZXN0ID0gbGVuZ3RoLCBsZW5ndGgrKyk7XG4gIH1cbiAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxWzBdICE9PSB0ZXh0MlswXSkgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJTdGFydCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJTdGFydCwgcG9pbnRlck1pZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJTdGFydCA9IHBvaW50ZXJNaW4pIDogcG9pbnRlck1heCA9IHBvaW50ZXJNaWQsIHBvaW50ZXJNaWQgPSBNYXRoLmZsb29yKChwb2ludGVyTWF4IC0gcG9pbnRlck1pbikgLyAyICsgcG9pbnRlck1pbik7XG4gIHJldHVybiBwb2ludGVyTWlkO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVt0ZXh0MS5sZW5ndGggLSAxXSAhPT0gdGV4dDJbdGV4dDIubGVuZ3RoIC0gMV0pIHJldHVybiAwO1xuICBsZXQgcG9pbnRlck1pbiA9IDAsIHBvaW50ZXJNYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCksIHBvaW50ZXJNaWQgPSBwb2ludGVyTWF4LCBwb2ludGVyRW5kID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyRW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJFbmQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyRW5kID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU1Mjk2ICYmIGNoYXJDb2RlIDw9IDU2MzE5O1xufVxuZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhcikge1xuICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDU2MzIwICYmIGNoYXJDb2RlIDw9IDU3MzQzO1xufVxuZnVuY3Rpb24gYmlzZWN0KHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFMZW5ndGggPSB0ZXh0MS5sZW5ndGgsIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoLCBtYXhEID0gTWF0aC5jZWlsKCh0ZXh0MUxlbmd0aCArIHRleHQyTGVuZ3RoKSAvIDIpLCB2T2Zmc2V0ID0gbWF4RCwgdkxlbmd0aCA9IDIgKiBtYXhELCB2MSA9IG5ldyBBcnJheSh2TGVuZ3RoKSwgdjIgPSBuZXcgQXJyYXkodkxlbmd0aCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdkxlbmd0aDsgeCsrKSB2MVt4XSA9IC0xLCB2Mlt4XSA9IC0xO1xuICB2MVt2T2Zmc2V0ICsgMV0gPSAwLCB2Mlt2T2Zmc2V0ICsgMV0gPSAwO1xuICBjb25zdCBkZWx0YSA9IHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgsIGZyb250ID0gZGVsdGEgJSAyICE9PSAwO1xuICBsZXQgazFzdGFydCA9IDAsIGsxZW5kID0gMCwgazJzdGFydCA9IDAsIGsyZW5kID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBtYXhEICYmICEoRGF0ZS5ub3coKSA+IGRlYWRsaW5lKTsgZCsrKSB7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgazE7XG4gICAgICBsZXQgeDE7XG4gICAgICBrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFPZmZzZXQgLSAxXSA8IHYxW2sxT2Zmc2V0ICsgMV0gPyB4MSA9IHYxW2sxT2Zmc2V0ICsgMV0gOiB4MSA9IHYxW2sxT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkxID0geDEgLSBrMTtcbiAgICAgIGZvciAoOyB4MSA8IHRleHQxTGVuZ3RoICYmIHkxIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKTsgKSB4MSsrLCB5MSsrO1xuICAgICAgaWYgKHYxW2sxT2Zmc2V0XSA9IHgxLCB4MSA+IHRleHQxTGVuZ3RoKSBrMWVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTEgPiB0ZXh0Mkxlbmd0aCkgazFzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyT2Zmc2V0ID49IDAgJiYgazJPZmZzZXQgPCB2TGVuZ3RoICYmIHYyW2syT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MiA9IHRleHQxTGVuZ3RoIC0gdjJbazJPZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4MikgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgazI7XG4gICAgICBsZXQgeDI7XG4gICAgICBrMiA9PT0gLWQgfHwgazIgIT09IGQgJiYgdjJbazJPZmZzZXQgLSAxXSA8IHYyW2syT2Zmc2V0ICsgMV0gPyB4MiA9IHYyW2syT2Zmc2V0ICsgMV0gOiB4MiA9IHYyW2syT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkyID0geDIgLSBrMjtcbiAgICAgIGZvciAoOyB4MiA8IHRleHQxTGVuZ3RoICYmIHkyIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHRleHQxTGVuZ3RoIC0geDIgLSAxKSA9PT0gdGV4dDIuY2hhckF0KHRleHQyTGVuZ3RoIC0geTIgLSAxKTsgKSB4MisrLCB5MisrO1xuICAgICAgaWYgKHYyW2syT2Zmc2V0XSA9IHgyLCB4MiA+IHRleHQxTGVuZ3RoKSBrMmVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTIgPiB0ZXh0Mkxlbmd0aCkgazJzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoIWZyb250KSB7XG4gICAgICAgIGNvbnN0IGsxT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMU9mZnNldCA+PSAwICYmIGsxT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MVtrMU9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDEgPSB2MVtrMU9mZnNldF0sIHkxID0gdk9mZnNldCArIHgxIC0gazFPZmZzZXQ7XG4gICAgICAgICAgaWYgKHgyID0gdGV4dDFMZW5ndGggLSB4MiwgeDEgPj0geDIpIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbn1cbmZ1bmN0aW9uIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpLCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSksIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KSwgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpLCBkaWZmcyA9IGRvRGlmZih0ZXh0MWEsIHRleHQyYSwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pLCBkaWZmc2IgPSBkb0RpZmYodGV4dDFiLCB0ZXh0MmIsIHtcbiAgICBjaGVja0xpbmVzOiAhMSxcbiAgICBkZWFkbGluZVxuICB9KTtcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufVxuZnVuY3Rpb24gZmluZEhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIsIHRpbWVvdXQgPSAxKSB7XG4gIGlmICh0aW1lb3V0IDw9IDApIHJldHVybiBudWxsO1xuICBjb25zdCBsb25nVGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDIsIHNob3J0VGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25nVGV4dC5sZW5ndGggPCA0IHx8IHNob3J0VGV4dC5sZW5ndGggKiAyIDwgbG9uZ1RleHQubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgaGFsZk1hdGNoMSA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKSwgaGFsZk1hdGNoMiA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhhbGZNYXRjaDtcbiAgaWYgKGhhbGZNYXRjaDEgJiYgaGFsZk1hdGNoMikgaGFsZk1hdGNoID0gaGFsZk1hdGNoMVs0XS5sZW5ndGggPiBoYWxmTWF0Y2gyWzRdLmxlbmd0aCA/IGhhbGZNYXRjaDEgOiBoYWxmTWF0Y2gyO1xuICBlbHNlIHtcbiAgICBpZiAoIWhhbGZNYXRjaDEgJiYgIWhhbGZNYXRjaDIpIHJldHVybiBudWxsO1xuICAgIGhhbGZNYXRjaDIgPyBoYWxmTWF0Y2gxIHx8IChoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gyKSA6IGhhbGZNYXRjaCA9IGhhbGZNYXRjaDE7XG4gIH1cbiAgaWYgKCFoYWxmTWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgaGFsZiBtYXRjaC5cIik7XG4gIGxldCB0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkI7XG4gIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/ICh0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10pIDogKHRleHQyQSA9IGhhbGZNYXRjaFswXSwgdGV4dDJCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMl0sIHRleHQxQiA9IGhhbGZNYXRjaFszXSk7XG4gIGNvbnN0IG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XTtcbiAgcmV0dXJuIFt0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkIsIG1pZENvbW1vbl07XG59XG5mdW5jdGlvbiBoYWxmTWF0Y2hJKGxvbmdUZXh0LCBzaG9ydFRleHQsIGkpIHtcbiAgY29uc3Qgc2VlZCA9IGxvbmdUZXh0LnNsaWNlKGksIGkgKyBNYXRoLmZsb29yKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKTtcbiAgbGV0IGogPSAtMSwgYmVzdENvbW1vbiA9IFwiXCIsIGJlc3RMb25nVGV4dEEsIGJlc3RMb25nVGV4dEIsIGJlc3RTaG9ydFRleHRBLCBiZXN0U2hvcnRUZXh0QjtcbiAgZm9yICg7IChqID0gc2hvcnRUZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPT0gLTE7ICkge1xuICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IGdldENvbW1vblByZWZpeChsb25nVGV4dC5zbGljZShpKSwgc2hvcnRUZXh0LnNsaWNlKGopKSwgc3VmZml4TGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KGxvbmdUZXh0LnNsaWNlKDAsIGkpLCBzaG9ydFRleHQuc2xpY2UoMCwgaikpO1xuICAgIGJlc3RDb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoICYmIChiZXN0Q29tbW9uID0gc2hvcnRUZXh0LnNsaWNlKGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnRUZXh0LnNsaWNlKGosIGogKyBwcmVmaXhMZW5ndGgpLCBiZXN0TG9uZ1RleHRBID0gbG9uZ1RleHQuc2xpY2UoMCwgaSAtIHN1ZmZpeExlbmd0aCksIGJlc3RMb25nVGV4dEIgPSBsb25nVGV4dC5zbGljZShpICsgcHJlZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEEgPSBzaG9ydFRleHQuc2xpY2UoMCwgaiAtIHN1ZmZpeExlbmd0aCksIGJlc3RTaG9ydFRleHRCID0gc2hvcnRUZXh0LnNsaWNlKGogKyBwcmVmaXhMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gYmVzdENvbW1vbi5sZW5ndGggKiAyID49IGxvbmdUZXh0Lmxlbmd0aCA/IFtiZXN0TG9uZ1RleHRBIHx8IFwiXCIsIGJlc3RMb25nVGV4dEIgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEEgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEIgfHwgXCJcIiwgYmVzdENvbW1vbiB8fCBcIlwiXSA6IG51bGw7XG59XG5mdW5jdGlvbiBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVBcnJheSkge1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgY2hhcnMgPSBkaWZmc1t4XVsxXSwgdGV4dCA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVzVG9DaGFycyh0ZXh0QSwgdGV4dEIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW10sIGxpbmVIYXNoID0ge307XG4gIGxpbmVBcnJheVswXSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGRpZmZMaW5lc1RvTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCIsIGxpbmVTdGFydCA9IDAsIGxpbmVFbmQgPSAtMSwgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDsgbGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMTsgKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKGBcbmAsIGxpbmVTdGFydCksIGxpbmVFbmQgPT09IC0xICYmIChsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkgPyBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKSA6IChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzICYmIChsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQpLCBsaW5lRW5kID0gdGV4dC5sZW5ndGgpLCBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCksIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoLCBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZSksIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb011bmdlKHRleHRBKTtcbiAgbWF4TGluZXMgPSA2NTUzNTtcbiAgY29uc3QgY2hhcnMyID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0Qik7XG4gIHJldHVybiB7XG4gICAgY2hhcnMxLFxuICAgIGNoYXJzMixcbiAgICBsaW5lQXJyYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvTGluZU1vZGVEaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgYSA9IGxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxLCB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgbGV0IGRpZmZzID0gZG9EaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gIH0pO1xuICBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnREZWxldGUgPj0gMSAmJiBjb3VudEluc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IGFhID0gZG9EaWZmKHRleHREZWxldGUsIHRleHRJbnNlcnQsIHtcbiAgICAgICAgICAgIGNoZWNrTGluZXM6ICExLFxuICAgICAgICAgICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gYWEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhYVtqXSk7XG4gICAgICAgICAgcG9pbnRlciArPSBhYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcy5wb3AoKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdHMpIHtcbiAgbGV0IGRpZmZzO1xuICBpZiAoIXRleHQxKSByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgaWYgKCF0ZXh0MikgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIGNvbnN0IGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MSwgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT09IC0xKSByZXR1cm4gZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLCBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSwgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV0sIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCAmJiAoZGlmZnNbMF1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURSksIGRpZmZzO1xuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBjb25zdCBoYWxmTWF0Y2ggPSBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChoYWxmTWF0Y2gpIHtcbiAgICBjb25zdCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10sIG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XSwgZGlmZnNBID0gZG9EaWZmKHRleHQxQSwgdGV4dDJBLCBvcHRzKSwgZGlmZnNCID0gZG9EaWZmKHRleHQxQiwgdGV4dDJCLCBvcHRzKTtcbiAgICByZXR1cm4gZGlmZnNBLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZENvbW1vbl1dLCBkaWZmc0IpO1xuICB9XG4gIHJldHVybiBvcHRzLmNoZWNrTGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCA/IGRvTGluZU1vZGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykgOiBiaXNlY3QodGV4dDEsIHRleHQyLCBvcHRzLmRlYWRsaW5lKTtcbn1cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpIF9faGFzT3duUHJvcCQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDIpIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQyKGIpKSBfX3Byb3BJc0VudW0kMi5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn07XG5jb25zdCBESUZGX0RFTEVURSA9IC0xLCBESUZGX0lOU0VSVCA9IDEsIERJRkZfRVFVQUwgPSAwO1xuZnVuY3Rpb24gZGlmZih0ZXh0QSwgdGV4dEIsIG9wdHMpIHtcbiAgaWYgKHRleHRBID09PSBudWxsIHx8IHRleHRCID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAoZGlmZilcIik7XG4gIGNvbnN0IGRpZmZzID0gZG9EaWZmKHRleHRBLCB0ZXh0QiwgY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMgfHwge30pKTtcbiAgcmV0dXJuIGFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyhkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gZG9EaWZmKHRleHRBLCB0ZXh0Qiwgb3B0aW9ucykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgaWYgKHRleHQxID09PSB0ZXh0MikgcmV0dXJuIHRleHQxID8gW1tESUZGX0VRVUFMLCB0ZXh0MV1dIDogW107XG4gIGxldCBjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgbGV0IGRpZmZzID0gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbW1vbnByZWZpeCAmJiBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKSwgY29tbW9uc3VmZml4ICYmIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pLCBkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVhZExpbmUodGltZW91dCkge1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB0eXBlb2YgdGltZW91dCA8IFwidVwiICYmICh0ID0gdGltZW91dCA8PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IHRpbWVvdXQpLCBEYXRlLm5vdygpICsgdCAqIDFlMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQyKHtcbiAgICBjaGVja0xpbmVzOiAhMCxcbiAgICBkZWFkbGluZTogY3JlYXRlRGVhZExpbmUob3B0cy50aW1lb3V0IHx8IDEpXG4gIH0sIG9wdHMpO1xufVxuZnVuY3Rpb24gY29tYmluZUNoYXIoZGF0YSwgY2hhciwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkYXRhICsgY2hhciA6IGNoYXIgKyBkYXRhO1xufVxuZnVuY3Rpb24gc3BsaXRDaGFyKGRhdGEsIGRpcikge1xuICByZXR1cm4gZGlyID09PSAxID8gW2RhdGEuc3Vic3RyaW5nKDAsIGRhdGEubGVuZ3RoIC0gMSksIGRhdGFbZGF0YS5sZW5ndGggLSAxXV0gOiBbZGF0YS5zdWJzdHJpbmcoMSksIGRhdGFbMF1dO1xufVxuZnVuY3Rpb24gaGFzU2hhcmVkQ2hhcihkaWZmcywgaSwgaiwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkaWZmc1tpXVsxXVtkaWZmc1tpXVsxXS5sZW5ndGggLSAxXSA9PT0gZGlmZnNbal1bMV1bZGlmZnNbal1bMV0ubGVuZ3RoIC0gMV0gOiBkaWZmc1tpXVsxXVswXSA9PT0gZGlmZnNbal1bMV1bMF07XG59XG5mdW5jdGlvbiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCBkaXIpIHtcbiAgY29uc3QgaW52ID0gZGlyID09PSAxID8gLTEgOiAxO1xuICBsZXQgaW5zZXJ0SWR4ID0gbnVsbCwgZGVsZXRlSWR4ID0gbnVsbCwgaiA9IGkgKyBkaXI7XG4gIGZvciAoOyBqID49IDAgJiYgaiA8IGRpZmZzLmxlbmd0aCAmJiAoaW5zZXJ0SWR4ID09PSBudWxsIHx8IGRlbGV0ZUlkeCA9PT0gbnVsbCk7IGogKz0gZGlyKSB7XG4gICAgY29uc3QgW29wLCB0ZXh0Ml0gPSBkaWZmc1tqXTtcbiAgICBpZiAodGV4dDIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAob3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGluc2VydElkeCA9PT0gbnVsbCAmJiAoaW5zZXJ0SWR4ID0gaik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgZGVsZXRlSWR4ID09PSBudWxsICYmIChkZWxldGVJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgIGlmIChpbnNlcnRJZHggPT09IG51bGwgJiYgZGVsZXRlSWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW3Jlc3QsIGNoYXIyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgICAgICAgICBkaWZmc1tpXVsxXSA9IHJlc3QsIGRpZmZzW2pdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbal1bMV0sIGNoYXIyLCBpbnYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluc2VydElkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggIT09IG51bGwgJiYgaGFzU2hhcmVkQ2hhcihkaWZmcywgaW5zZXJ0SWR4LCBkZWxldGVJZHgsIGRpcikpIHtcbiAgICBjb25zdCBbaW5zZXJ0VGV4dCwgaW5zZXJ0Q2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgaW52KSwgW2RlbGV0ZVRleHRdID0gc3BsaXRDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGludik7XG4gICAgZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGluc2VydFRleHQsIGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBkZWxldGVUZXh0LCBkaWZmc1tpXVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2ldWzFdLCBpbnNlcnRDaGFyLCBkaXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbdGV4dCwgY2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaV1bMV0sIGRpcik7XG4gIGRpZmZzW2ldWzFdID0gdGV4dCwgaW5zZXJ0SWR4ID09PSBudWxsID8gKGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9JTlNFUlQsIGNoYXJdKSwgZGVsZXRlSWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCA+PSBqICYmIGRlbGV0ZUlkeCsrKSA6IGRpZmZzW2luc2VydElkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tpbnNlcnRJZHhdWzFdLCBjaGFyLCBpbnYpLCBkZWxldGVJZHggPT09IG51bGwgPyBkaWZmcy5zcGxpY2UoaiwgMCwgW0RJRkZfREVMRVRFLCBjaGFyXSkgOiBkaWZmc1tkZWxldGVJZHhdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbZGVsZXRlSWR4XVsxXSwgY2hhciwgaW52KTtcbn1cbmZ1bmN0aW9uIGFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyhkaWZmcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2RpZmZUeXBlLCBkaWZmVGV4dF0gPSBkaWZmc1tpXTtcbiAgICBpZiAoZGlmZlRleHQubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICBjb25zdCBmaXJzdENoYXIgPSBkaWZmVGV4dFswXSwgbGFzdENoYXIgPSBkaWZmVGV4dFtkaWZmVGV4dC5sZW5ndGggLSAxXTtcbiAgICBpc0hpZ2hTdXJyb2dhdGUobGFzdENoYXIpICYmIGRpZmZUeXBlID09PSBESUZGX0VRVUFMICYmIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIDEpLCBpc0xvd1N1cnJvZ2F0ZShmaXJzdENoYXIpICYmIGRpZmZUeXBlID09PSBESUZGX0VRVUFMICYmIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIC0xKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSBkaWZmc1tpXVsxXS5sZW5ndGggPT09IDAgJiYgZGlmZnMuc3BsaWNlKGksIDEpO1xufVxuZnVuY3Rpb24gY2xlYW51cFNlbWFudGljKHJhd0RpZmZzKSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLCBoYXNDaGFuZ2VzID0gITE7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwb2ludGVyID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwLCBsZW5ndGhEZWxldGlvbnMxID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgbGVuZ3RoSW5zZXJ0aW9uczEgPSBsZW5ndGhJbnNlcnRpb25zMiwgbGVuZ3RoRGVsZXRpb25zMSA9IGxlbmd0aERlbGV0aW9uczIsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDAsIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdKSA6IChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQgPyBsZW5ndGhJbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggOiBsZW5ndGhEZWxldGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCwgbGFzdEVxdWFsaXR5ICYmIGxhc3RFcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoSW5zZXJ0aW9uczEsIGxlbmd0aERlbGV0aW9uczEpICYmIGxhc3RFcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczIpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBlcXVhbGl0aWVzTGVuZ3RoLS0sIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTEsIGxlbmd0aEluc2VydGlvbnMxID0gMCwgbGVuZ3RoRGVsZXRpb25zMSA9IDAsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIGZvciAoaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnMgPSBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyksIHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0RFTEVURSAmJiBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLCBpbnNlcnRpb24gPSBkaWZmc1twb2ludGVyXVsxXSwgb3ZlcmxhcExlbmd0aDEgPSBnZXRDb21tb25PdmVybGFwKGRlbGV0aW9uLCBpbnNlcnRpb24pLCBvdmVybGFwTGVuZ3RoMiA9IGdldENvbW1vbk92ZXJsYXAoaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICBvdmVybGFwTGVuZ3RoMSA+PSBvdmVybGFwTGVuZ3RoMiA/IChvdmVybGFwTGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBMZW5ndGgxID49IGluc2VydGlvbi5sZW5ndGggLyAyKSAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0VRVUFMLCBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgxKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcoMCwgZGVsZXRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDEpLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBpbnNlcnRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgxKSwgcG9pbnRlcisrKSA6IChvdmVybGFwTGVuZ3RoMiA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBMZW5ndGgyID49IGluc2VydGlvbi5sZW5ndGggLyAyKSAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0VRVUFMLCBkZWxldGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcExlbmd0aDIpXSksIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IERJRkZfSU5TRVJULCBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIGluc2VydGlvbi5sZW5ndGggLSBvdmVybGFwTGVuZ3RoMiksIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERJRkZfREVMRVRFLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDIpLCBwb2ludGVyKyspLCBwb2ludGVyKys7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59XG5jb25zdCBub25BbHBoYU51bWVyaWNSZWdleCA9IC9bXmEtekEtWjAtOV0vLCB3aGl0ZXNwYWNlUmVnZXggPSAvXFxzLywgbGluZWJyZWFrUmVnZXggPSAvW1xcclxcbl0vLCBibGFua2xpbmVFbmRSZWdleCA9IC9cXG5cXHI/XFxuJC8sIGJsYW5rbGluZVN0YXJ0UmVnZXggPSAvXlxccj9cXG5cXHI/XFxuLztcbmZ1bmN0aW9uIGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKHJhd0RpZmZzKSB7XG4gIGNvbnN0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSk7XG4gIGZ1bmN0aW9uIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShvbmUsIHR3bykge1xuICAgIGlmICghb25lIHx8ICF0d28pIHJldHVybiA2O1xuICAgIGNvbnN0IGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSksIGNoYXIyID0gdHdvLmNoYXJBdCgwKSwgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4KSwgbm9uQWxwaGFOdW1lcmljMiA9IGNoYXIyLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4KSwgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmIGNoYXIxLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJiBjaGFyMi5tYXRjaCh3aGl0ZXNwYWNlUmVnZXgpLCBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiYgY2hhcjEubWF0Y2gobGluZWJyZWFrUmVnZXgpLCBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiYgY2hhcjIubWF0Y2gobGluZWJyZWFrUmVnZXgpLCBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJiBvbmUubWF0Y2goYmxhbmtsaW5lRW5kUmVnZXgpLCBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJiB0d28ubWF0Y2goYmxhbmtsaW5lU3RhcnRSZWdleCk7XG4gICAgcmV0dXJuIGJsYW5rTGluZTEgfHwgYmxhbmtMaW5lMiA/IDUgOiBsaW5lQnJlYWsxIHx8IGxpbmVCcmVhazIgPyA0IDogbm9uQWxwaGFOdW1lcmljMSAmJiAhd2hpdGVzcGFjZTEgJiYgd2hpdGVzcGFjZTIgPyAzIDogd2hpdGVzcGFjZTEgfHwgd2hpdGVzcGFjZTIgPyAyIDogbm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyID8gMSA6IDA7XG4gIH1cbiAgbGV0IHBvaW50ZXIgPSAxO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDE7ICkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBsZXQgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLCBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV0sIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgIGNvbnN0IGNvbW1vbk9mZnNldCA9IGdldENvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICBjb25zdCBjb21tb25TdHJpbmcgPSBlZGl0LnN1YnN0cmluZyhlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCksIGVkaXQgPSBjb21tb25TdHJpbmcgKyBlZGl0LnN1YnN0cmluZygwLCBlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCksIGVxdWFsaXR5MiA9IGNvbW1vblN0cmluZyArIGVxdWFsaXR5MjtcbiAgICAgIH1cbiAgICAgIGxldCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIsIGJlc3RTY29yZSA9IGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICsgZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICBmb3IgKDsgZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCk7ICkge1xuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCksIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCksIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgc2NvcmUgPj0gYmVzdFNjb3JlICYmIChiZXN0U2NvcmUgPSBzY29yZSwgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MSwgYmVzdEVkaXQgPSBlZGl0LCBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyKTtcbiAgICAgIH1cbiAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPT0gYmVzdEVxdWFsaXR5MSAmJiAoYmVzdEVxdWFsaXR5MSA/IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGJlc3RFcXVhbGl0eTEgOiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKSwgcG9pbnRlci0tKSwgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdCwgYmVzdEVxdWFsaXR5MiA/IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTIgOiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKSwgcG9pbnRlci0tKSk7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59XG5mdW5jdGlvbiBjbGVhbnVwTWVyZ2UocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSk7XG4gIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIFwiXCJdKTtcbiAgbGV0IHBvaW50ZXIgPSAwLCBjb3VudERlbGV0ZSA9IDAsIGNvdW50SW5zZXJ0ID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiLCBjb21tb25sZW5ndGg7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgY291bnRJbnNlcnQrKywgdGV4dEluc2VydCArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV0sIHBvaW50ZXIrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQgPiAxID8gKGNvdW50RGVsZXRlICE9PSAwICYmIGNvdW50SW5zZXJ0ICE9PSAwICYmIChjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dEluc2VydCwgdGV4dERlbGV0ZSksIGNvbW1vbmxlbmd0aCAhPT0gMCAmJiAocG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgPiAwICYmIGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMF0gPT09IERJRkZfRVFVQUwgPyBkaWZmc1twb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCAtIDFdWzFdICs9IHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCkgOiAoZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLCB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpLCB0ZXh0RGVsZXRlID0gdGV4dERlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChkaWZmc1twb2ludGVyXVsxXSA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKHRleHRJbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdLCB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgdGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpLCB0ZXh0RGVsZXRlID0gdGV4dERlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dERlbGV0ZS5sZW5ndGggLSBjb21tb25sZW5ndGgpKSksIHBvaW50ZXIgLT0gY291bnREZWxldGUgKyBjb3VudEluc2VydCwgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQpLCB0ZXh0RGVsZXRlLmxlbmd0aCAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0RFTEVURSwgdGV4dERlbGV0ZV0pLCBwb2ludGVyKyspLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0lOU0VSVCwgdGV4dEluc2VydF0pLCBwb2ludGVyKyspLCBwb2ludGVyKyspIDogcG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSkpIDogcG9pbnRlcisrLCBjb3VudEluc2VydCA9IDAsIGNvdW50RGVsZXRlID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb25cIik7XG4gIH1cbiAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09IFwiXCIgJiYgZGlmZnMucG9wKCk7XG4gIGxldCBoYXNDaGFuZ2VzID0gITE7XG4gIGZvciAocG9pbnRlciA9IDE7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxOyApIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdID8gKGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkgOiBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSAmJiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIHRydWVDb3VudCguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZSgobiwgYm9vbCkgPT4gbiArIChib29sID8gMSA6IDApLCAwKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZpY2llbmN5KHJhd0RpZmZzLCBlZGl0Q29zdCA9IDQpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBwcmVJbnMgPSAhMSwgcHJlRGVsID0gITEsIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCA/IChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCBlZGl0Q29zdCAmJiAocG9zdElucyB8fCBwb3N0RGVsKSA/IChlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyLCBwcmVJbnMgPSBwb3N0SW5zLCBwcmVEZWwgPSBwb3N0RGVsLCBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXSkgOiAoZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwpLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMSkgOiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfREVMRVRFID8gcG9zdERlbCA9ICEwIDogcG9zdElucyA9ICEwLCBsYXN0RXF1YWxpdHkgJiYgKHByZUlucyAmJiBwcmVEZWwgJiYgcG9zdElucyAmJiBwb3N0RGVsIHx8IGxhc3RFcXVhbGl0eS5sZW5ndGggPCBlZGl0Q29zdCAvIDIgJiYgdHJ1ZUNvdW50KHByZUlucywgcHJlRGVsLCBwb3N0SW5zLCBwb3N0RGVsKSA9PT0gMykgJiYgKGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgW0RJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHldKSwgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJULCBlcXVhbGl0aWVzTGVuZ3RoLS0sIGxhc3RFcXVhbGl0eSA9IG51bGwsIHByZUlucyAmJiBwcmVEZWwgPyAocG9zdElucyA9ICEwLCBwb3N0RGVsID0gITAsIGVxdWFsaXRpZXNMZW5ndGggPSAwKSA6IChlcXVhbGl0aWVzTGVuZ3RoLS0sIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTEsIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExKSwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgcmV0dXJuIGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzO1xufVxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2dldE93blByb3BTeW1ib2xzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSQxID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMSA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSkgX19oYXNPd25Qcm9wJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMSkgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDEoYikpIF9fcHJvcElzRW51bSQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLyoqXG4gICAqIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxuICAgKi9cbiAgdGhyZXNob2xkOiAwLjUsXG4gIC8qKlxuICAgKiBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cbiAgICogQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXG4gICAqIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxuICAgKi9cbiAgZGlzdGFuY2U6IDFlM1xufTtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMkMShfX3NwcmVhZFZhbHVlcyQxKHt9LCBERUZBVUxUX09QVElPTlMpLCBvcHRpb25zKTtcbn1cbmNvbnN0IE1BWF9CSVRTJDEgPSAzMjtcbmZ1bmN0aW9uIGJpdGFwKHRleHQsIHBhdHRlcm4sIGxvYywgb3B0cyA9IHt9KSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTJDEpIHRocm93IG5ldyBFcnJvcihcIlBhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci5cIik7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRzKG9wdHMpLCBzID0gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKTtcbiAgZnVuY3Rpb24gZ2V0Qml0YXBTY29yZShlLCB4KSB7XG4gICAgY29uc3QgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGgsIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgIHJldHVybiBvcHRpb25zLmRpc3RhbmNlID8gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBvcHRpb25zLmRpc3RhbmNlIDogcHJveGltaXR5ID8gMSA6IGFjY3VyYWN5O1xuICB9XG4gIGxldCBzY29yZVRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLCBiZXN0TG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSwgYmVzdExvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpLCBiZXN0TG9jICE9PSAtMSAmJiAoc2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihnZXRCaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCkpKTtcbiAgY29uc3QgbWF0Y2htYXNrID0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIDE7XG4gIGJlc3RMb2MgPSAtMTtcbiAgbGV0IGJpbk1pbiwgYmluTWlkLCBiaW5NYXggPSBwYXR0ZXJuLmxlbmd0aCArIHRleHQubGVuZ3RoLCBsYXN0UmQgPSBbXTtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XG4gICAgZm9yIChiaW5NaW4gPSAwLCBiaW5NaWQgPSBiaW5NYXg7IGJpbk1pbiA8IGJpbk1pZDsgKSBnZXRCaXRhcFNjb3JlKGQsIGxvYyArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQgPyBiaW5NaW4gPSBiaW5NaWQgOiBiaW5NYXggPSBiaW5NaWQsIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluTWlkICsgMSk7XG4gICAgY29uc3QgZmluaXNoID0gTWF0aC5taW4obG9jICsgYmluTWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aCwgcmQgPSBuZXcgQXJyYXkoZmluaXNoICsgMik7XG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICBjb25zdCBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCA/IHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggOiByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIHwgKChsYXN0UmRbaiArIDFdIHwgbGFzdFJkW2pdKSA8PCAxIHwgMSkgfCBsYXN0UmRbaiArIDFdLCByZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICBjb25zdCBzY29yZSA9IGdldEJpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVUaHJlc2hvbGQpIGlmIChzY29yZVRocmVzaG9sZCA9IHNjb3JlLCBiZXN0TG9jID0gaiAtIDEsIGJlc3RMb2MgPiBsb2MpIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RMb2MpO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0Qml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlVGhyZXNob2xkKSBicmVhaztcbiAgICBsYXN0UmQgPSByZDtcbiAgfVxuICByZXR1cm4gYmVzdExvYztcbn1cbmZ1bmN0aW9uIGdldEFscGhhYmV0RnJvbVBhdHRlcm4ocGF0dGVybikge1xuICBjb25zdCBzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybi5sZW5ndGggLSBpIC0gMTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBtYXRjaCh0ZXh0LCBwYXR0ZXJuLCBzZWFyY2hMb2NhdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0ZXh0ID09PSBudWxsIHx8IHBhdHRlcm4gPT09IG51bGwgfHwgc2VhcmNoTG9jYXRpb24gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChtYXRjaCgpKVwiKTtcbiAgY29uc3QgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VhcmNoTG9jYXRpb24sIHRleHQubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09PSBwYXR0ZXJuKSByZXR1cm4gMDtcbiAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgaWYgKHRleHQuc3Vic3RyaW5nKGxvYywgbG9jICsgcGF0dGVybi5sZW5ndGgpID09PSBwYXR0ZXJuKSByZXR1cm4gbG9jO1xuICB9IGVsc2UgcmV0dXJuIC0xO1xuICByZXR1cm4gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCAmJiAodGV4dFt4XSA9IGRpZmZzW3hdWzFdKTtcbiAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MihkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSAmJiAodGV4dFt4XSA9IGRpZmZzW3hdWzFdKTtcbiAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGxldmVuc2h0ZWluKGRpZmZzKSB7XG4gIGxldCBsZXZlbiA9IDAsIGluc2VydGlvbnMgPSAwLCBkZWxldGlvbnMgPSAwO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3Qgb3AgPSBkaWZmc1t4XVswXSwgZGF0YSA9IGRpZmZzW3hdWzFdO1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgbGV2ZW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKSwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvbi5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBsZXZlbjtcbn1cbmZ1bmN0aW9uIHhJbmRleChkaWZmcywgbG9jYXRpb24pIHtcbiAgbGV0IGNoYXJzMSA9IDAsIGNoYXJzMiA9IDAsIGxhc3RDaGFyczEgPSAwLCBsYXN0Q2hhcnMyID0gMCwgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aCAmJiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmIChjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmIChjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgIShjaGFyczEgPiBsb2NhdGlvbikpOyB4KyspIGxhc3RDaGFyczEgPSBjaGFyczEsIGxhc3RDaGFyczIgPSBjaGFyczI7XG4gIHJldHVybiBkaWZmcy5sZW5ndGggIT09IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFID8gbGFzdENoYXJzMiA6IGxhc3RDaGFyczIgKyAobG9jYXRpb24gLSBsYXN0Q2hhcnMxKTtcbn1cbmZ1bmN0aW9uIGNvdW50VXRmOEJ5dGVzKHN0cikge1xuICBsZXQgYnl0ZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICBpZiAodHlwZW9mIGNvZGVQb2ludCA+IFwidVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNvZGVwb2ludFwiKTtcbiAgICBieXRlcyArPSB1dGY4bGVuKGNvZGVQb2ludCk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYWRqdXN0SW5kaWNpZXNUb1VjczIocGF0Y2hlcywgYmFzZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBieXRlT2Zmc2V0ID0gMCwgaWR4ID0gMDtcbiAgZnVuY3Rpb24gYWR2YW5jZVRvKHRhcmdldCkge1xuICAgIGZvciAoOyBieXRlT2Zmc2V0IDwgdGFyZ2V0OyApIHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGJhc2UuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpIHJldHVybiBpZHg7XG4gICAgICBieXRlT2Zmc2V0ICs9IHV0ZjhsZW4oY29kZVBvaW50KSwgY29kZVBvaW50ID4gNjU1MzUgPyBpZHggKz0gMiA6IGlkeCArPSAxO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dFeGNlZWRpbmdJbmRpY2VzICYmIGJ5dGVPZmZzZXQgIT09IHRhcmdldCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRldGVybWluZSBieXRlIG9mZnNldFwiKTtcbiAgICByZXR1cm4gaWR4O1xuICB9XG4gIGNvbnN0IGFkanVzdGVkID0gW107XG4gIGZvciAoY29uc3QgcGF0Y2ggb2YgcGF0Y2hlcykgYWRqdXN0ZWQucHVzaCh7XG4gICAgZGlmZnM6IHBhdGNoLmRpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLFxuICAgIHN0YXJ0MTogYWR2YW5jZVRvKHBhdGNoLnN0YXJ0MSksXG4gICAgc3RhcnQyOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQyKSxcbiAgICB1dGY4U3RhcnQxOiBwYXRjaC51dGY4U3RhcnQxLFxuICAgIHV0ZjhTdGFydDI6IHBhdGNoLnV0ZjhTdGFydDIsXG4gICAgbGVuZ3RoMTogcGF0Y2gubGVuZ3RoMSxcbiAgICBsZW5ndGgyOiBwYXRjaC5sZW5ndGgyLFxuICAgIHV0ZjhMZW5ndGgxOiBwYXRjaC51dGY4TGVuZ3RoMSxcbiAgICB1dGY4TGVuZ3RoMjogcGF0Y2gudXRmOExlbmd0aDJcbiAgfSk7XG4gIHJldHVybiBhZGp1c3RlZDtcbn1cbmZ1bmN0aW9uIHV0ZjhsZW4oY29kZVBvaW50KSB7XG4gIHJldHVybiBjb2RlUG9pbnQgPD0gMTI3ID8gMSA6IGNvZGVQb2ludCA8PSAyMDQ3ID8gMiA6IGNvZGVQb2ludCA8PSA2NTUzNSA/IDMgOiA0O1xufVxuY29uc3QgTUFYX0JJVFMgPSAzMiwgREVGQVVMVF9NQVJHSU4gPSA0O1xuZnVuY3Rpb24gYWRkUGFkZGluZyhwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gbWFyZ2luO1xuICBsZXQgbnVsbFBhZGRpbmcgPSBcIlwiO1xuICBmb3IgKGxldCB4ID0gMTsgeCA8PSBwYWRkaW5nTGVuZ3RoOyB4KyspIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIGZvciAoY29uc3QgcCBvZiBwYXRjaGVzKSBwLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDEgKz0gcGFkZGluZ0xlbmd0aCwgcC51dGY4U3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGxldCBwYXRjaCA9IHBhdGNoZXNbMF0sIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbMF1bMF0gIT09IERJRkZfRVFVQUwpIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLnN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlyc3REaWZmTGVuZ3RoID0gZGlmZnNbMF1bMV0ubGVuZ3RoLCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBmaXJzdERpZmZMZW5ndGg7XG4gICAgZGlmZnNbMF1bMV0gPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoZmlyc3REaWZmTGVuZ3RoKSArIGRpZmZzWzBdWzFdLCBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MiAtPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG4gIGlmIChwYXRjaCA9IHBhdGNoZXNbcGF0Y2hlcy5sZW5ndGggLSAxXSwgZGlmZnMgPSBwYXRjaC5kaWZmcywgZGlmZnMubGVuZ3RoID09PSAwIHx8IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzBdICE9PSBESUZGX0VRVUFMKSBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pLCBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIGNvbnN0IGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSArPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoMCwgZXh0cmFMZW5ndGgpLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hPYmplY3Qoc3RhcnQxLCBzdGFydDIpIHtcbiAgcmV0dXJuIHtcbiAgICBkaWZmczogW10sXG4gICAgc3RhcnQxLFxuICAgIHN0YXJ0MixcbiAgICB1dGY4U3RhcnQxOiBzdGFydDEsXG4gICAgdXRmOFN0YXJ0Mjogc3RhcnQyLFxuICAgIGxlbmd0aDE6IDAsXG4gICAgbGVuZ3RoMjogMCxcbiAgICB1dGY4TGVuZ3RoMTogMCxcbiAgICB1dGY4TGVuZ3RoMjogMFxuICB9O1xufVxuZnVuY3Rpb24gc3BsaXRNYXgocGF0Y2hlcywgbWFyZ2luID0gREVGQVVMVF9NQVJHSU4pIHtcbiAgY29uc3QgcGF0Y2hTaXplID0gTUFYX0JJVFM7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPD0gcGF0Y2hTaXplKSBjb250aW51ZTtcbiAgICBjb25zdCBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgcGF0Y2hlcy5zcGxpY2UoeC0tLCAxKTtcbiAgICBsZXQgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxLCBzdGFydDIgPSBiaWdwYXRjaC5zdGFydDIsIHByZUNvbnRleHQgPSBcIlwiO1xuICAgIGZvciAoOyBiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDA7ICkge1xuICAgICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEgLSBwcmVDb250ZXh0Lmxlbmd0aCwgc3RhcnQyIC0gcHJlQ29udGV4dC5sZW5ndGgpO1xuICAgICAgbGV0IGVtcHR5ID0gITA7XG4gICAgICBpZiAocHJlQ29udGV4dCAhPT0gXCJcIikge1xuICAgICAgICBjb25zdCBwcmVjb250ZXh0Qnl0ZUNvdW50ID0gY291bnRVdGY4Qnl0ZXMocHJlQ29udGV4dCk7XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5sZW5ndGgyID0gcHJlQ29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyID0gcHJlY29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlQ29udGV4dF0pO1xuICAgICAgfVxuICAgICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJiBwYXRjaC5sZW5ndGgxIDwgcGF0Y2hTaXplIC0gbWFyZ2luOyApIHtcbiAgICAgICAgY29uc3QgZGlmZlR5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcbiAgICAgICAgbGV0IGRpZmZUZXh0ID0gYmlncGF0Y2guZGlmZnNbMF1bMV0sIGRpZmZUZXh0Qnl0ZUNvdW50ID0gY291bnRVdGY4Qnl0ZXMoZGlmZlRleHQpO1xuICAgICAgICBpZiAoZGlmZlR5cGUgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDIgKz0gZGlmZlRleHQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGRpZmYyID0gYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICBkaWZmMiAmJiBwYXRjaC5kaWZmcy5wdXNoKGRpZmYyKSwgZW1wdHkgPSAhMTtcbiAgICAgICAgfSBlbHNlIGRpZmZUeXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT09IDEgJiYgcGF0Y2guZGlmZnNbMF1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZlRleHQubGVuZ3RoID4gMiAqIHBhdGNoU2l6ZSA/IChwYXRjaC5sZW5ndGgxICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MSArPSBkaWZmVGV4dC5sZW5ndGgsIGVtcHR5ID0gITEsIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZUeXBlLCBkaWZmVGV4dF0pLCBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKSA6IChkaWZmVGV4dCA9IGRpZmZUZXh0LnN1YnN0cmluZygwLCBwYXRjaFNpemUgLSBwYXRjaC5sZW5ndGgxIC0gbWFyZ2luKSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCksIHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgPyAocGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDIgKz0gZGlmZlRleHQubGVuZ3RoKSA6IGVtcHR5ID0gITEsIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZUeXBlLCBkaWZmVGV4dF0pLCBkaWZmVGV4dCA9PT0gYmlncGF0Y2guZGlmZnNbMF1bMV0gPyBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpIDogYmlncGF0Y2guZGlmZnNbMF1bMV0gPSBiaWdwYXRjaC5kaWZmc1swXVsxXS5zdWJzdHJpbmcoZGlmZlRleHQubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBwcmVDb250ZXh0ID0gZGlmZlRleHQyKHBhdGNoLmRpZmZzKSwgcHJlQ29udGV4dCA9IHByZUNvbnRleHQuc3Vic3RyaW5nKHByZUNvbnRleHQubGVuZ3RoIC0gbWFyZ2luKTtcbiAgICAgIGNvbnN0IHBvc3RDb250ZXh0ID0gZGlmZlRleHQxKGJpZ3BhdGNoLmRpZmZzKS5zdWJzdHJpbmcoMCwgbWFyZ2luKSwgcG9zdENvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwb3N0Q29udGV4dCk7XG4gICAgICBwb3N0Q29udGV4dCAhPT0gXCJcIiAmJiAocGF0Y2gubGVuZ3RoMSArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gcG9zdENvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gcG9zdENvbnRleHRCeXRlQ291bnQsIHBhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJiBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3RDb250ZXh0IDogcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcG9zdENvbnRleHRdKSksIGVtcHR5IHx8IHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwbHkocGF0Y2hlcywgb3JpZ2luYWxUZXh0LCBvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVvZiBwYXRjaGVzID09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIlBhdGNoZXMgbXVzdCBiZSBhbiBhcnJheSAtIHBhc3MgdGhlIHBhdGNoIHRvIGBwYXJzZVBhdGNoKClgIGZpcnN0XCIpO1xuICBsZXQgdGV4dCA9IG9yaWdpbmFsVGV4dDtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW3RleHQsIFtdXTtcbiAgY29uc3QgcGFyc2VkID0gYWRqdXN0SW5kaWNpZXNUb1VjczIocGF0Y2hlcywgdGV4dCwge1xuICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogb3B0cy5hbGxvd0V4Y2VlZGluZ0luZGljZXNcbiAgfSksIG1hcmdpbiA9IG9wdHMubWFyZ2luIHx8IERFRkFVTFRfTUFSR0lOLCBkZWxldGVUaHJlc2hvbGQgPSBvcHRzLmRlbGV0ZVRocmVzaG9sZCB8fCAwLjQsIG51bGxQYWRkaW5nID0gYWRkUGFkZGluZyhwYXJzZWQsIG1hcmdpbik7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZywgc3BsaXRNYXgocGFyc2VkLCBtYXJnaW4pO1xuICBsZXQgZGVsdGEgPSAwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGFyc2VkLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRMb2MgPSBwYXJzZWRbeF0uc3RhcnQyICsgZGVsdGEsIHRleHQxID0gZGlmZlRleHQxKHBhcnNlZFt4XS5kaWZmcyk7XG4gICAgbGV0IHN0YXJ0TG9jLCBlbmRMb2MgPSAtMTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgPyAoc3RhcnRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgTUFYX0JJVFMpLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jICE9PSAtMSAmJiAoZW5kTG9jID0gbWF0Y2godGV4dCwgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgZXhwZWN0ZWRMb2MgKyB0ZXh0MS5sZW5ndGggLSBNQVhfQklUUyksIChlbmRMb2MgPT09IC0xIHx8IHN0YXJ0TG9jID49IGVuZExvYykgJiYgKHN0YXJ0TG9jID0gLTEpKSkgOiBzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jID09PSAtMSkgcmVzdWx0c1t4XSA9ICExLCBkZWx0YSAtPSBwYXJzZWRbeF0ubGVuZ3RoMiAtIHBhcnNlZFt4XS5sZW5ndGgxO1xuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0c1t4XSA9ICEwLCBkZWx0YSA9IHN0YXJ0TG9jIC0gZXhwZWN0ZWRMb2M7XG4gICAgICBsZXQgdGV4dDI7XG4gICAgICBpZiAoZW5kTG9jID09PSAtMSA/IHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MsIHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKSA6IHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MsIGVuZExvYyArIE1BWF9CSVRTKSwgdGV4dDEgPT09IHRleHQyKSB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MpICsgZGlmZlRleHQyKHBhcnNlZFt4XS5kaWZmcykgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGRpZmZzID0gZGlmZih0ZXh0MSwgdGV4dDIsIHtcbiAgICAgICAgICBjaGVja0xpbmVzOiAhMVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IE1BWF9CSVRTICYmIGxldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+IGRlbGV0ZVRocmVzaG9sZCkgcmVzdWx0c1t4XSA9ICExO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICBsZXQgaW5kZXgxID0gMCwgaW5kZXgyID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHBhcnNlZFt4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgY29uc3QgbW9kID0gcGFyc2VkW3hdLmRpZmZzW3ldO1xuICAgICAgICAgICAgbW9kWzBdICE9PSBESUZGX0VRVUFMICYmIChpbmRleDIgPSB4SW5kZXgoZGlmZnMsIGluZGV4MSkpLCBtb2RbMF0gPT09IERJRkZfSU5TRVJUID8gdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIG1vZFsxXSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgaW5kZXgyKSA6IG1vZFswXSA9PT0gRElGRl9ERUxFVEUgJiYgKHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYyArIGluZGV4MikgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHhJbmRleChkaWZmcywgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpKSwgbW9kWzBdICE9PSBESUZGX0RFTEVURSAmJiAoaW5kZXgxICs9IG1vZFsxXS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpLCBbdGV4dCwgcmVzdWx0c107XG59XG5jb25zdCBwYXRjaEhlYWRlciA9IC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC87XG5mdW5jdGlvbiBwYXJzZSh0ZXh0bGluZSkge1xuICBpZiAoIXRleHRsaW5lKSByZXR1cm4gW107XG4gIGNvbnN0IHBhdGNoZXMgPSBbXSwgbGluZXMgPSB0ZXh0bGluZS5zcGxpdChgXG5gKTtcbiAgbGV0IHRleHRQb2ludGVyID0gMDtcbiAgZm9yICg7IHRleHRQb2ludGVyIDwgbGluZXMubGVuZ3RoOyApIHtcbiAgICBjb25zdCBtID0gbGluZXNbdGV4dFBvaW50ZXJdLm1hdGNoKHBhdGNoSGVhZGVyKTtcbiAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXRjaCBzdHJpbmc6ICR7bGluZXNbdGV4dFBvaW50ZXJdfWApO1xuICAgIGNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hPYmplY3QodG9JbnQobVsxXSksIHRvSW50KG1bM10pKTtcbiAgICBmb3IgKHBhdGNoZXMucHVzaChwYXRjaCksIG1bMl0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQxLS0sIHBhdGNoLnV0ZjhTdGFydDEtLSwgcGF0Y2gubGVuZ3RoMSA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgxID0gMSkgOiBtWzJdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgxID0gMCwgcGF0Y2gudXRmOExlbmd0aDEgPSAwKSA6IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHRvSW50KG1bMl0pLCBwYXRjaC5sZW5ndGgxID0gcGF0Y2gudXRmOExlbmd0aDEpLCBtWzRdID09PSBcIlwiID8gKHBhdGNoLnN0YXJ0Mi0tLCBwYXRjaC51dGY4U3RhcnQyLS0sIHBhdGNoLmxlbmd0aDIgPSAxLCBwYXRjaC51dGY4TGVuZ3RoMiA9IDEpIDogbVs0XSA9PT0gXCIwXCIgPyAocGF0Y2gubGVuZ3RoMiA9IDAsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMCkgOiAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gudXRmOExlbmd0aDIgPSB0b0ludChtWzRdKSwgcGF0Y2gubGVuZ3RoMiA9IHBhdGNoLnV0ZjhMZW5ndGgyKSwgdGV4dFBvaW50ZXIrKzsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgY3VycmVudExpbmUgPSBsaW5lc1t0ZXh0UG9pbnRlcl0sIHNpZ24gPSBjdXJyZW50TGluZS5jaGFyQXQoMCk7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJAXCIpIGJyZWFrO1xuICAgICAgaWYgKHNpZ24gPT09IFwiXCIpIHtcbiAgICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbGluZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpbmUgPSBkZWNvZGVVUkkoY3VycmVudExpbmUuc2xpY2UoMSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBlc2NhcGUgaW4gcGFyc2U6ICR7Y3VycmVudExpbmV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1dGY4RGlmZiA9IGNvdW50VXRmOEJ5dGVzKGxpbmUpIC0gbGluZS5sZW5ndGg7XG4gICAgICBpZiAoc2lnbiA9PT0gXCItXCIpIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfREVMRVRFLCBsaW5lXSksIHBhdGNoLmxlbmd0aDEgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIGlmIChzaWduID09PSBcIitcIikgcGF0Y2guZGlmZnMucHVzaChbRElGRl9JTlNFUlQsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiIFwiKSBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBsaW5lXSksIHBhdGNoLmxlbmd0aDEgLT0gdXRmOERpZmYsIHBhdGNoLmxlbmd0aDIgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXRjaCBtb2RlIFwiJHtzaWdufVwiIGluOiAke2xpbmV9YCk7XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIHRvSW50KG51bSkge1xuICByZXR1cm4gcGFyc2VJbnQobnVtLCAxMCk7XG59XG5jb25zdCBDVVJSRU5UX1VORE9fU1RFUCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aFVuZG9TdGVwKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgY3VycmVudCA9IENVUlJFTlRfVU5ET19TVEVQLmdldChlZGl0b3IpO1xuICBpZiAoY3VycmVudCkge1xuICAgIGZuKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIENVUlJFTlRfVU5ET19TVEVQLnNldChlZGl0b3IsIGN1cnJlbnQgPz8ge1xuICAgIHVuZG9TdGVwSWQ6IGRlZmF1bHRLZXlHZW5lcmF0b3IoKVxuICB9KSwgZm4oKSwgQ1VSUkVOVF9VTkRPX1NURVAuc2V0KGVkaXRvciwgdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRVbmRvU3RlcElkKGVkaXRvcikge1xuICByZXR1cm4gQ1VSUkVOVF9VTkRPX1NURVAuZ2V0KGVkaXRvcik/LnVuZG9TdGVwSWQ7XG59XG5jb25zdCBkZWJ1ZyRmID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoVW5kb1JlZG9cIiksIFNBVklORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBSRU1PVEVfUEFUQ0hFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBVTkRPX1NURVBfTElNSVQgPSAxZTMsIGlzU2F2aW5nID0gKGVkaXRvcikgPT4ge1xuICBjb25zdCBzdGF0ZSA9IFNBVklORy5nZXQoZWRpdG9yKTtcbiAgcmV0dXJuIHN0YXRlID09PSB2b2lkIDAgPyAhMCA6IHN0YXRlO1xufSwgZ2V0UmVtb3RlUGF0Y2hlcyA9IChlZGl0b3IpID0+IChSRU1PVEVfUEFUQ0hFUy5nZXQoZWRpdG9yKSB8fCBSRU1PVEVfUEFUQ0hFUy5zZXQoZWRpdG9yLCBbXSksIFJFTU9URV9QQVRDSEVTLmdldChlZGl0b3IpIHx8IFtdKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhVbmRvUmVkbyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3JBY3RvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIChlZGl0b3IpID0+IHtcbiAgICBsZXQgcHJldmlvdXNTbmFwc2hvdCA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lKTtcbiAgICBjb25zdCByZW1vdGVQYXRjaGVzID0gZ2V0UmVtb3RlUGF0Y2hlcyhlZGl0b3IpO1xuICAgIGxldCBwcmV2aW91c1VuZG9TdGVwSWQgPSBnZXRDdXJyZW50VW5kb1N0ZXBJZChlZGl0b3IpO1xuICAgIG9wdGlvbnMuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGYoXCJTdWJzY3JpYmluZyB0byBwYXRjaGVzXCIpO1xuICAgICAgY29uc3Qgc3ViID0gZWRpdG9yQWN0b3Iub24oXCJwYXRjaGVzXCIsICh7XG4gICAgICAgIHBhdGNoZXMsXG4gICAgICAgIHNuYXBzaG90XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGxldCByZXNldCA9ICExO1xuICAgICAgICBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNldCAmJiBwYXRjaC5vcmlnaW4gIT09IFwibG9jYWxcIiAmJiByZW1vdGVQYXRjaGVzKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGRlYnVnJGYoXCJTb21lb25lIGVsc2UgY2xlYXJlZCB0aGUgY29udGVudCwgcmVzZXR0aW5nIHVuZG8vcmVkbyBoaXN0b3J5XCIpLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgICAgICAgICAgICB1bmRvczogW10sXG4gICAgICAgICAgICAgICAgcmVkb3M6IFtdXG4gICAgICAgICAgICAgIH0sIHJlbW90ZVBhdGNoZXMuc3BsaWNlKDAsIHJlbW90ZVBhdGNoZXMubGVuZ3RoKSwgU0FWSU5HLnNldChlZGl0b3IsICEwKSwgcmVzZXQgPSAhMDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3RlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0Y2gsXG4gICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgICAgICAgcHJldmlvdXNTbmFwc2hvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcHJldmlvdXNTbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkZWJ1ZyRmKFwiVW5zdWJzY3JpYmluZyB0byBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgdW5kb3M6IFtdLFxuICAgICAgcmVkb3M6IFtdXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgIGhpc3RvcnlcbiAgICAgIH0gPSBlZGl0b3IsIHtcbiAgICAgICAgdW5kb3NcbiAgICAgIH0gPSBoaXN0b3J5LCBzdGVwID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV0sIGxhc3RPcCA9IHN0ZXAgJiYgc3RlcC5vcGVyYXRpb25zICYmIHN0ZXAub3BlcmF0aW9uc1tzdGVwLm9wZXJhdGlvbnMubGVuZ3RoIC0gMV0sIG92ZXJ3cml0ZSA9IHNob3VsZE92ZXJ3cml0ZShvcCwgbGFzdE9wKSwgc2F2ZSA9IGlzU2F2aW5nKGVkaXRvciksIGN1cnJlbnRVbmRvU3RlcElkID0gZ2V0Q3VycmVudFVuZG9TdGVwSWQoZWRpdG9yKTtcbiAgICAgIGxldCBtZXJnZSA9IGN1cnJlbnRVbmRvU3RlcElkICE9PSB2b2lkIDAgJiYgcHJldmlvdXNVbmRvU3RlcElkID09PSB2b2lkIDAgPyAhMSA6IGN1cnJlbnRVbmRvU3RlcElkICE9PSB2b2lkIDAgJiYgcHJldmlvdXNVbmRvU3RlcElkICE9PSB2b2lkIDAgPyBjdXJyZW50VW5kb1N0ZXBJZCA9PT0gcHJldmlvdXNVbmRvU3RlcElkIDogITA7XG4gICAgICBpZiAoc2F2ZSkge1xuICAgICAgICBpZiAoc3RlcCA/IG9wZXJhdGlvbnMubGVuZ3RoID09PSAwICYmIChtZXJnZSA9IGN1cnJlbnRVbmRvU3RlcElkID09PSB2b2lkIDAgJiYgcHJldmlvdXNVbmRvU3RlcElkID09PSB2b2lkIDAgPyBzaG91bGRNZXJnZShvcCwgbGFzdE9wKSB8fCBvdmVyd3JpdGUgOiBtZXJnZSkgOiBtZXJnZSA9ICExLCBzdGVwICYmIG1lcmdlKVxuICAgICAgICAgIHN0ZXAub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RlcCA9IHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFsuLi5lZGl0b3Iuc2VsZWN0aW9uID09PSBudWxsID8gW10gOiBbY3JlYXRlU2VsZWN0T3BlcmF0aW9uKGVkaXRvcildLCBvcF0sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1bmRvcy5wdXNoKG5ld1N0ZXApLCBkZWJ1ZyRmKFwiQ3JlYXRlZCBuZXcgdW5kbyBzdGVwXCIsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyB1bmRvcy5sZW5ndGggPiBVTkRPX1NURVBfTElNSVQ7IClcbiAgICAgICAgICB1bmRvcy5zaGlmdCgpO1xuICAgICAgICBzaG91bGRDbGVhcihvcCkgJiYgKGhpc3RvcnkucmVkb3MgPSBbXSk7XG4gICAgICB9XG4gICAgICBwcmV2aW91c1VuZG9TdGVwSWQgPSBjdXJyZW50VW5kb1N0ZXBJZCwgYXBwbHkyKG9wKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBoaXN0b3J5VW5kb09wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICB1bmRvc1xuICB9ID0gZWRpdG9yLmhpc3RvcnksIHJlbW90ZVBhdGNoZXMgPSBnZXRSZW1vdGVQYXRjaGVzKGVkaXRvcik7XG4gIGlmICh1bmRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChkZWJ1ZyRmKFwiVW5kb2luZ1wiLCBzdGVwKSwgc3RlcC5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG90aGVyUGF0Y2hlcyA9IHJlbW90ZVBhdGNoZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRpbWUgPj0gc3RlcC50aW1lc3RhbXApO1xuICAgICAgbGV0IHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IHN0ZXAub3BlcmF0aW9ucztcbiAgICAgIG90aGVyUGF0Y2hlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IGZsYXR0ZW4odHJhbnNmb3JtZWRPcGVyYXRpb25zLm1hcCgob3ApID0+IHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIGl0ZW0ucGF0Y2gsIG9wLCBpdGVtLnNuYXBzaG90LCBpdGVtLnByZXZpb3VzU25hcHNob3QpKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJldmVyc2VkT3BlcmF0aW9ucyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoT3BlcmF0aW9uLmludmVyc2UpLnJldmVyc2UoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aFVuZG9pbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICByZXZlcnNlZE9wZXJhdGlvbnMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuYXBwbHkob3ApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZWJ1ZyRmKFwiQ291bGQgbm90IHBlcmZvcm0gdW5kbyBzdGVwXCIsIGVyciksIHJlbW90ZVBhdGNoZXMuc3BsaWNlKDAsIHJlbW90ZVBhdGNoZXMubGVuZ3RoKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgICAgICB1bmRvczogW10sXG4gICAgICAgICAgcmVkb3M6IFtdXG4gICAgICAgIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHNldElzVW5kb2luZyhlZGl0b3IsICExKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5oaXN0b3J5LnJlZG9zLnB1c2goc3RlcCksIGVkaXRvci5oaXN0b3J5LnVuZG9zLnBvcCgpO1xuICAgIH1cbiAgfVxufSwgaGlzdG9yeVJlZG9PcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgcmVkb3NcbiAgfSA9IGVkaXRvci5oaXN0b3J5LCByZW1vdGVQYXRjaGVzID0gZ2V0UmVtb3RlUGF0Y2hlcyhlZGl0b3IpO1xuICBpZiAocmVkb3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSByZWRvc1tyZWRvcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoZGVidWckZihcIlJlZG9pbmdcIiwgc3RlcCksIHN0ZXAub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBvdGhlclBhdGNoZXMgPSByZW1vdGVQYXRjaGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50aW1lID49IHN0ZXAudGltZXN0YW1wKTtcbiAgICAgIGxldCB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBzdGVwLm9wZXJhdGlvbnM7XG4gICAgICBvdGhlclBhdGNoZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBmbGF0dGVuKHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KSkpO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhSZWRvaW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVidWckZihcIkNvdWxkIG5vdCBwZXJmb3JtIHJlZG8gc3RlcFwiLCBlcnIpLCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICB9LCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCBzZXRJc1JlZG9pbmcoZWRpdG9yLCAhMSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3IuaGlzdG9yeS51bmRvcy5wdXNoKHN0ZXApLCBlZGl0b3IuaGlzdG9yeS5yZWRvcy5wb3AoKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBwYXRjaCwgb3BlcmF0aW9uLCBzbmFwc2hvdCwgcHJldmlvdXNTbmFwc2hvdCkge1xuICBjb25zdCB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAuLi5vcGVyYXRpb25cbiAgfTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBpbnNlcnRCbG9ja0luZGV4ID0gKHNuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgICBfa2V5OiBibGsuX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pKTtcbiAgICByZXR1cm4gZGVidWckZihgQWRqdXN0aW5nIGJsb2NrIHBhdGggKCske3BhdGNoLml0ZW1zLmxlbmd0aH0pIGZvciAnJHt0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlfScgb3BlcmF0aW9uIGFuZCBwYXRjaCAnJHtwYXRjaC50eXBlfSdgKSwgW2FkanVzdEJsb2NrUGF0aCh0cmFuc2Zvcm1lZE9wZXJhdGlvbiwgcGF0Y2guaXRlbXMubGVuZ3RoLCBpbnNlcnRCbG9ja0luZGV4KV07XG4gIH1cbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHVuc2V0QmxvY2tJbmRleCA9IChwcmV2aW91c1NuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgICBfa2V5OiBibGsuX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pKTtcbiAgICByZXR1cm4gXCJwYXRoXCIgaW4gdHJhbnNmb3JtZWRPcGVyYXRpb24gJiYgQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoKSAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdID09PSB1bnNldEJsb2NrSW5kZXggPyAoZGVidWckZihcIlNraXBwaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgdGFyZ2V0ZWQgcmVtb3ZlZCBibG9ja1wiKSwgW10pIDogW2FkanVzdEJsb2NrUGF0aCh0cmFuc2Zvcm1lZE9wZXJhdGlvbiwgLTEsIHVuc2V0QmxvY2tJbmRleCldO1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGRlYnVnJGYoYEFkanVzdGluZyBzZWxlY3Rpb24gZm9yIHVuc2V0IGV2ZXJ5dGhpbmcgcGF0Y2ggYW5kICR7b3BlcmF0aW9uLnR5cGV9IG9wZXJhdGlvbmApLCBbXTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiZGlmZk1hdGNoUGF0Y2hcIikge1xuICAgIGNvbnN0IG9wZXJhdGlvblRhcmdldEJsb2NrID0gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgdHJhbnNmb3JtZWRPcGVyYXRpb24pO1xuICAgIHJldHVybiAhb3BlcmF0aW9uVGFyZ2V0QmxvY2sgfHwgIWlzRXF1YWwoe1xuICAgICAgX2tleTogb3BlcmF0aW9uVGFyZ2V0QmxvY2suX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pID8gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXSA6IChwYXJzZShwYXRjaC52YWx1ZSkuZm9yRWFjaCgoZGlmZlBhdGNoKSA9PiB7XG4gICAgICBsZXQgYWRqdXN0T2Zmc2V0QnkgPSAwLCBjaGFuZ2VkT2Zmc2V0ID0gZGlmZlBhdGNoLnV0ZjhTdGFydDE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpZmZzXG4gICAgICB9ID0gZGlmZlBhdGNoO1xuICAgICAgaWYgKGRpZmZzLmZvckVhY2goKGRpZmYyLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBbZGlmZlR5cGUsIHRleHRdID0gZGlmZjI7XG4gICAgICAgIGRpZmZUeXBlID09PSBESUZGX0lOU0VSVCA/IChhZGp1c3RPZmZzZXRCeSArPSB0ZXh0Lmxlbmd0aCwgY2hhbmdlZE9mZnNldCArPSB0ZXh0Lmxlbmd0aCkgOiBkaWZmVHlwZSA9PT0gRElGRl9ERUxFVEUgPyAoYWRqdXN0T2Zmc2V0QnkgLT0gdGV4dC5sZW5ndGgsIGNoYW5nZWRPZmZzZXQgLT0gdGV4dC5sZW5ndGgpIDogZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzLnNsaWNlKGluZGV4KS5ldmVyeSgoW2RUeXBlXSkgPT4gZFR5cGUgPT09IERJRkZfRVFVQUwpIHx8IChjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSk7XG4gICAgICB9KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIGNoYW5nZWRPZmZzZXQgPCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiAmJiBjaGFuZ2VkT2Zmc2V0IDw9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCAtIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnRleHQubGVuZ3RoICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIikge1xuICAgICAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0gOiB2b2lkIDAsIGN1cnJlbnRBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ucHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuYW5jaG9yXG4gICAgICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSA6IHZvaWQgMCwgbmV3QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICAoY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgfHwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yKSAmJiAoW2N1cnJlbnRGb2N1cywgY3VycmVudEFuY2hvciwgbmV3Rm9jdXMsIG5ld0FuY2hvcl0uZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgICAgICBwb2ludCAmJiBjaGFuZ2VkT2Zmc2V0IDwgcG9pbnQub2Zmc2V0ICYmIChwb2ludC5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpO1xuICAgICAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgZm9jdXM6IGN1cnJlbnRGb2N1cyxcbiAgICAgICAgICBhbmNob3I6IGN1cnJlbnRBbmNob3JcbiAgICAgICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgICAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgICAgICAgYW5jaG9yOiBuZXdBbmNob3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pLCBbdHJhbnNmb3JtZWRPcGVyYXRpb25dKTtcbiAgfVxuICByZXR1cm4gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXTtcbn1cbmZ1bmN0aW9uIGFkanVzdEJsb2NrUGF0aChvcGVyYXRpb24sIGxldmVsLCBibG9ja0luZGV4KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0ge1xuICAgIC4uLm9wZXJhdGlvblxuICB9O1xuICBpZiAoYmxvY2tJbmRleCA+PSAwICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCkgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSA+PSBibG9ja0luZGV4ICsgbGV2ZWwgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSArIGxldmVsID4gLTEpIHtcbiAgICBjb25zdCBuZXdQYXRoID0gW3RyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gKyBsZXZlbCwgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aC5zbGljZSgxKV07XG4gICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCA9IG5ld1BhdGg7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgY29uc3QgY3VycmVudEZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5wcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1c1xuICAgIH0gOiB2b2lkIDAsIG5ld0FuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDA7XG4gICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICBwb2ludCAmJiBwb2ludC5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiBwb2ludC5wYXRoWzBdICsgbGV2ZWwgPiAtMSAmJiAocG9pbnQucGF0aCA9IFtwb2ludC5wYXRoWzBdICsgbGV2ZWwsIC4uLnBvaW50LnBhdGguc2xpY2UoMSldKTtcbiAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmNvbnN0IHNob3VsZE1lcmdlID0gKG9wLCBwcmV2KSA9PiAhIShvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiB8fCBwcmV2ICYmIG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBwcmV2LnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpICYmIG9wLnRleHQgIT09IFwiIFwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBwcmV2Lm9mZnNldCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSwgc2hvdWxkT3ZlcndyaXRlID0gKG9wLCBwcmV2KSA9PiAhIShwcmV2ICYmIG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIHByZXYudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpLCBzaG91bGRDbGVhciA9IChvcCkgPT4gb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCI7XG5mdW5jdGlvbiB3aXRob3V0U2F2aW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzU2F2aW5nKGVkaXRvcik7XG4gIFNBVklORy5zZXQoZWRpdG9yLCAhMSksIGZuKCksIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldF9zZWxlY3Rpb25cIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSxcbiAgICBuZXdQcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgb3BlcmF0aW9uKSB7XG4gIGxldCBibG9jaztcbiAgcmV0dXJuIG9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBlZGl0b3Iuc2VsZWN0aW9uID8gYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdXSA6IFwicGF0aFwiIGluIG9wZXJhdGlvbiAmJiAoYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSwgYmxvY2s7XG59XG5jb25zdCBhZGRBbm5vdGF0aW9uT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgcGFyc2VkQW5ub3RhdGlvbiA9IHBhcnNlQW5ub3RhdGlvbih7XG4gICAgYW5ub3RhdGlvbjoge1xuICAgICAgX3R5cGU6IG9wZXJhdGlvbi5hbm5vdGF0aW9uLm5hbWUsXG4gICAgICAuLi5vcGVyYXRpb24uYW5ub3RhdGlvbi52YWx1ZVxuICAgIH0sXG4gICAgY29udGV4dCxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWZyZXNoS2V5czogITEsXG4gICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBhcnNlZEFubm90YXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYW5ub3RhdGlvbiAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hbm5vdGF0aW9uKX1gKTtcbiAgY29uc3QgZWRpdG9yID0gb3BlcmF0aW9uLmVkaXRvcjtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKVxuICAgIHJldHVybjtcbiAgbGV0IHBhdGhzLCBzcGFuUGF0aCwgbWFya0RlZlBhdGg7XG4gIGNvbnN0IG1hcmtEZWZQYXRocyA9IFtdLCBzZWxlY3RlZEJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKSxcbiAgICByZXZlcnNlOiBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pXG4gIH0pO1xuICBsZXQgYmxvY2tJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdIG9mIHNlbGVjdGVkQmxvY2tzKSB7XG4gICAgaWYgKGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGFubm90YXRpb25LZXkgPSBibG9ja0luZGV4ID09PSAwID8gcGFyc2VkQW5ub3RhdGlvbi5fa2V5IDogY29udGV4dC5rZXlHZW5lcmF0b3IoKSwgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXTtcbiAgICBtYXJrRGVmcy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBwYXJzZWRBbm5vdGF0aW9uLl90eXBlICYmIG1hcmtEZWYuX2tleSA9PT0gYW5ub3RhdGlvbktleSkgPT09IHZvaWQgMCAmJiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIG1hcmtEZWZzOiBbLi4ubWFya0RlZnMsIHtcbiAgICAgICAgLi4ucGFyc2VkQW5ub3RhdGlvbixcbiAgICAgICAgX2tleTogYW5ub3RhdGlvbktleVxuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBhdDogYmxvY2tQYXRoXG4gICAgfSksIG1hcmtEZWZQYXRoID0gW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9LCBcIm1hcmtEZWZzXCIsIHtcbiAgICAgIF9rZXk6IGFubm90YXRpb25LZXlcbiAgICB9XSwgUmFuZ2UuaXNCYWNrd2FyZChlZGl0b3Iuc2VsZWN0aW9uKSA/IG1hcmtEZWZQYXRocy51bnNoaWZ0KG1hcmtEZWZQYXRoKSA6IG1hcmtEZWZQYXRocy5wdXNoKG1hcmtEZWZQYXRoKSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgc3BsaXQ6ICEwXG4gICAgfSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0U3BhbihzcGFuKSB8fCAhUmFuZ2UuaW5jbHVkZXMoZWRpdG9yLnNlbGVjdGlvbiwgcGF0aCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyayAmJiBtYXJrRGVmLl90eXBlID09PSBwYXJzZWRBbm5vdGF0aW9uLl90eXBlKSk7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXJrczogWy4uLm1hcmtzLmZpbHRlcigobWFyaykgPT4gIWV4aXN0aW5nU2FtZVR5cGVBbm5vdGF0aW9ucy5pbmNsdWRlcyhtYXJrKSksIGFubm90YXRpb25LZXldXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KSwgc3BhblBhdGggPSBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogc3Bhbi5fa2V5XG4gICAgICB9XTtcbiAgICB9XG4gICAgYmxvY2tJbmRleCsrO1xuICB9XG4gIHJldHVybiBtYXJrRGVmUGF0aCAmJiBzcGFuUGF0aCAmJiAocGF0aHMgPSB7XG4gICAgbWFya0RlZlBhdGgsXG4gICAgbWFya0RlZlBhdGhzLFxuICAgIHNwYW5QYXRoXG4gIH0pLCBwYXRocztcbn0sIHJlbW92ZUFubm90YXRpb25PcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBvcGVyYXRpb24uZWRpdG9yO1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbilcbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMVxuICAgICAgfSk7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBvdGVudGlhbEFubm90YXRpb25zID0gKGJsb2NrLm1hcmtEZWZzID8/IFtdKS5maWx0ZXIoKG1hcmtEZWYpID0+IG1hcmtEZWYuX3R5cGUgPT09IG9wZXJhdGlvbi5hbm5vdGF0aW9uLm5hbWUpLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAyXG4gICAgICB9KTtcbiAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oc2VsZWN0ZWRDaGlsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGFubm90YXRpb25Ub1JlbW92ZSA9IHNlbGVjdGVkQ2hpbGQubWFya3M/LmZpbmQoKG1hcmspID0+IHBvdGVudGlhbEFubm90YXRpb25zLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgaWYgKCFhbm5vdGF0aW9uVG9SZW1vdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgsIHtcbiAgICAgICAgcmV2ZXJzZTogITBcbiAgICAgIH0pKVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNCZWZvcmUoY2hpbGRQYXRoLCBzZWxlY3RlZENoaWxkUGF0aCkpXG4gICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgcHJldmlvdXNTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbi5wdXNoKFtjaGlsZCwgY2hpbGRQYXRoXSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBuZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNBZnRlcihjaGlsZFBhdGgsIHNlbGVjdGVkQ2hpbGRQYXRoKSlcbiAgICAgICAgICBpZiAoY2hpbGQubWFya3M/LmluY2x1ZGVzKGFubm90YXRpb25Ub1JlbW92ZSkpXG4gICAgICAgICAgICBuZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb24ucHVzaChbY2hpbGQsIGNoaWxkUGF0aF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgWy4uLnByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24sIFtzZWxlY3RlZENoaWxkLCBzZWxlY3RlZENoaWxkUGF0aF0sIC4uLm5leHRTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbl0pXG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IGNoaWxkLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IG1hcmsgIT09IGFubm90YXRpb25Ub1JlbW92ZSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpLFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdIG9mIGJsb2Nrcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBjaGlsZFBhdGgpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXSwgbWFya3MgPSBjaGlsZC5tYXJrcyA/PyBbXSwgbWFya3NXaXRob3V0QW5ub3RhdGlvbiA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gbWFya0RlZnMuZmluZCgobWFya0RlZjIpID0+IG1hcmtEZWYyLl9rZXkgPT09IG1hcmspPy5fdHlwZSAhPT0gb3BlcmF0aW9uLmFubm90YXRpb24ubmFtZSk7XG4gICAgICAgICAgbWFya3NXaXRob3V0QW5ub3RhdGlvbi5sZW5ndGggIT09IG1hcmtzLmxlbmd0aCAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG1hcmtzV2l0aG91dEFubm90YXRpb25cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59LCBibG9ja1NldE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGxvY2F0aW9uID0gdG9TbGF0ZVJhbmdlKHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGg6IG9wZXJhdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IG9wZXJhdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH1cbiAgfSwgb3BlcmF0aW9uLmVkaXRvcik7XG4gIGlmICghbG9jYXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29udmVydCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5hdCl9IGludG8gYSBTbGF0ZSBSYW5nZWApO1xuICBjb25zdCBibG9jayA9IEVkaXRvci5ub2RlKG9wZXJhdGlvbi5lZGl0b3IsIGxvY2F0aW9uLCB7XG4gICAgZGVwdGg6IDFcbiAgfSk/LlswXTtcbiAgaWYgKCFibG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgY29uc3QgcGFyc2VkQmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQob3BlcmF0aW9uLmVkaXRvcikpLmF0KDApO1xuICBpZiAoIXBhcnNlZEJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgY29uc3Qge1xuICAgIF90eXBlLFxuICAgIC4uLmZpbHRlcmVkUHJvcHNcbiAgfSA9IG9wZXJhdGlvbi5wcm9wcywgdXBkYXRlZEJsb2NrID0gcGFyc2VCbG9jayh7XG4gICAgY29udGV4dCxcbiAgICBibG9jazoge1xuICAgICAgLi4ucGFyc2VkQmxvY2ssXG4gICAgICAuLi5maWx0ZXJlZFByb3BzXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZWZyZXNoS2V5czogITEsXG4gICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICB9XG4gIH0pO1xuICBpZiAoIXVwZGF0ZWRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1cGRhdGUgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfWApO1xuICBjb25zdCBzbGF0ZUJsb2NrID0gdG9TbGF0ZVZhbHVlKFt1cGRhdGVkQmxvY2tdLCB7XG4gICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gIH0pPy5hdCgwKTtcbiAgaWYgKCFzbGF0ZUJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb252ZXJ0IGJsb2NrIHRvIFNsYXRlIHZhbHVlXCIpO1xuICBUcmFuc2Zvcm1zLnNldE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHNsYXRlQmxvY2ssIHtcbiAgICBhdDogbG9jYXRpb25cbiAgfSk7XG59LCBibG9ja1Vuc2V0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgbG9jYXRpb24gPSB0b1NsYXRlUmFuZ2Uoe1xuICAgIGFuY2hvcjoge1xuICAgICAgcGF0aDogb3BlcmF0aW9uLmF0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aDogb3BlcmF0aW9uLmF0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9LCBvcGVyYXRpb24uZWRpdG9yKTtcbiAgaWYgKCFsb2NhdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX0gaW50byBhIFNsYXRlIFJhbmdlYCk7XG4gIGNvbnN0IGJsb2NrID0gRWRpdG9yLm5vZGUob3BlcmF0aW9uLmVkaXRvciwgbG9jYXRpb24sIHtcbiAgICBkZXB0aDogMVxuICB9KT8uWzBdO1xuICBpZiAoIWJsb2NrKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfWApO1xuICBjb25zdCBwYXJzZWRCbG9jayA9IGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChvcGVyYXRpb24uZWRpdG9yKSkuYXQoMCk7XG4gIGlmICghcGFyc2VkQmxvY2spXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgYmxvY2sgYXQgJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24uYXQpfWApO1xuICBpZiAoaXNUZXh0QmxvY2soY29udGV4dCwgcGFyc2VkQmxvY2spKSB7XG4gICAgY29uc3QgcHJvcHNUb1JlbW92ZSA9IG9wZXJhdGlvbi5wcm9wcy5maWx0ZXIoKHByb3ApID0+IHByb3AgIT09IFwiX3R5cGVcIiksIHVwZGF0ZWRUZXh0QmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBibG9jazogb21pdChwYXJzZWRCbG9jaywgcHJvcHNUb1JlbW92ZSksXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlZnJlc2hLZXlzOiAhMSxcbiAgICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF1cGRhdGVkVGV4dEJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gdXBkYXRlIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgICBjb25zdCBwcm9wc1RvU2V0ID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzVG9SZW1vdmUpXG4gICAgICBwcm9wIGluIHVwZGF0ZWRUZXh0QmxvY2sgPyBwcm9wc1RvU2V0W3Byb3BdID0gdXBkYXRlZFRleHRCbG9ja1twcm9wXSA6IHByb3BzVG9TZXRbcHJvcF0gPSB2b2lkIDA7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCBwcm9wc1RvU2V0LCB7XG4gICAgICBhdDogbG9jYXRpb25cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXBkYXRlZEJsb2NrT2JqZWN0ID0gcGFyc2VCbG9jayh7XG4gICAgY29udGV4dCxcbiAgICBibG9jazogb21pdChwYXJzZWRCbG9jaywgb3BlcmF0aW9uLnByb3BzLmZpbHRlcigocHJvcCkgPT4gcHJvcCAhPT0gXCJfdHlwZVwiKSksXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVmcmVzaEtleXM6ICExLFxuICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgfVxuICB9KTtcbiAgaWYgKCF1cGRhdGVkQmxvY2tPYmplY3QpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gdXBkYXRlIGJsb2NrIGF0ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgY29uc3Qge1xuICAgIF90eXBlLFxuICAgIF9rZXksXG4gICAgLi4ucHJvcHNcbiAgfSA9IHVwZGF0ZWRCbG9ja09iamVjdDtcbiAgVHJhbnNmb3Jtcy5zZXROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgX3R5cGUsXG4gICAgX2tleSxcbiAgICB2YWx1ZTogcHJvcHNcbiAgfSwge1xuICAgIGF0OiBsb2NhdGlvblxuICB9KTtcbn0sIGRlY29yYXRvckFkZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IG9wZXJhdGlvbi5lZGl0b3IsIG1hcmsgPSBvcGVyYXRpb24uZGVjb3JhdG9yLCB2YWx1ZSA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBtYW51YWxBbmNob3IgPSBvcGVyYXRpb24uYXQ/LmFuY2hvciA/IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0sXG4gICAgYmxvY2tPZmZzZXQ6IG9wZXJhdGlvbi5hdC5hbmNob3IsXG4gICAgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCJcbiAgfSkgOiB2b2lkIDAsIG1hbnVhbEZvY3VzID0gb3BlcmF0aW9uLmF0Py5mb2N1cyA/IGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0sXG4gICAgYmxvY2tPZmZzZXQ6IG9wZXJhdGlvbi5hdC5mb2N1cyxcbiAgICBkaXJlY3Rpb246IFwiZm9yd2FyZFwiXG4gIH0pIDogdm9pZCAwLCBtYW51YWxTZWxlY3Rpb24gPSBtYW51YWxBbmNob3IgJiYgbWFudWFsRm9jdXMgPyB7XG4gICAgYW5jaG9yOiBtYW51YWxBbmNob3IsXG4gICAgZm9jdXM6IG1hbnVhbEZvY3VzXG4gIH0gOiB2b2lkIDAsIHNlbGVjdGlvbiA9IG1hbnVhbFNlbGVjdGlvbiA/IHRvU2xhdGVSYW5nZShtYW51YWxTZWxlY3Rpb24sIG9wZXJhdGlvbi5lZGl0b3IpID8/IGVkaXRvci5zZWxlY3Rpb24gOiBlZGl0b3Iuc2VsZWN0aW9uO1xuICBpZiAoIXNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGVkaXRvclNlbGVjdGlvbiA9IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICBlZGl0b3IsXG4gICAgcmFuZ2U6IHNlbGVjdGlvblxuICB9KSwgYW5jaG9yT2Zmc2V0ID0gZWRpdG9yU2VsZWN0aW9uID8gc2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICBjb250ZXh0OiB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9LFxuICAgIHNlbGVjdGlvblBvaW50OiBlZGl0b3JTZWxlY3Rpb24uYW5jaG9yXG4gIH0pIDogdm9pZCAwLCBmb2N1c09mZnNldCA9IGVkaXRvclNlbGVjdGlvbiA/IHNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgY29udGV4dDoge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfSxcbiAgICBzZWxlY3Rpb25Qb2ludDogZWRpdG9yU2VsZWN0aW9uLmZvY3VzXG4gIH0pIDogdm9pZCAwO1xuICBpZiAoIWFuY2hvck9mZnNldCB8fCAhZm9jdXNPZmZzZXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYW5jaG9yIG9yIGZvY3VzIG9mZnNldFwiKTtcbiAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgYXQ6IHNlbGVjdGlvbixcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHNwbGl0OiAhMCxcbiAgICAgIGhhbmdpbmc6ICEwXG4gICAgfSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgbmV3U2VsZWN0aW9uID0gYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24oe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgIH0sXG4gICAgICBvZmZzZXRzOiB7XG4gICAgICAgIGFuY2hvcjogYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1czogZm9jdXNPZmZzZXRcbiAgICAgIH0sXG4gICAgICBiYWNrd2FyZDogZWRpdG9yU2VsZWN0aW9uPy5iYWNrd2FyZFxuICAgIH0pLCB0cmltbWVkU2VsZWN0aW9uID0gZ2V0VHJpbW1lZFNlbGVjdGlvbih7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGFjdGl2ZURlY29yYXRvcnM6IFtdLFxuICAgICAgICBjb252ZXJ0ZXJzOiBbXSxcbiAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgcmVhZE9ubHk6ICExLFxuICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgICBzZWxlY3Rpb246IG5ld1NlbGVjdGlvbixcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0cmltbWVkU2VsZWN0aW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdHJpbW1lZCBzZWxlY3Rpb25cIik7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSB0b1NsYXRlUmFuZ2UodHJpbW1lZFNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICBpZiAoIW5ld1JhbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbmV3IHNlbGVjdGlvblwiKTtcbiAgICBjb25zdCBzcGxpdFRleHROb2RlcyA9IFJhbmdlLmlzUmFuZ2UobmV3UmFuZ2UpID8gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBuZXdSYW5nZSxcbiAgICAgIG1hdGNoOiAobm9kZSkgPT4gVGV4dC5pc1RleHQobm9kZSlcbiAgICB9KV0gOiBbXTtcbiAgICBmb3IgKGNvbnN0IFtub2RlLCBwYXRoXSBvZiBzcGxpdFRleHROb2Rlcykge1xuICAgICAgY29uc3QgbWFya3MgPSBbLi4uKEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgPyBub2RlLm1hcmtzIDogW10pLmZpbHRlcigoZU1hcmspID0+IGVNYXJrICE9PSBtYXJrKSwgbWFya107XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXJrc1xuICAgICAgfSwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBzZWxlY3Rpb24sXG4gICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpXG4gICAgfSkpPy5hdCgwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgZGVwdGg6IDFcbiAgICB9KSwgbG9uZWx5RW1wdHlTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bMF0pICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIgPyBibG9jay5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgICBpZiAobG9uZWx5RW1wdHlTcGFuKSB7XG4gICAgICBjb25zdCBleGlzdGluZ01hcmtzID0gbG9uZWx5RW1wdHlTcGFuLm1hcmtzID8/IFtdLCBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvciA9IGV4aXN0aW5nTWFya3MuZmlsdGVyKChleGlzdGluZ01hcmspID0+IGV4aXN0aW5nTWFyayAhPT0gbWFyayk7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5sZW5ndGggPT09IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yLmxlbmd0aCA/IFsuLi5leGlzdGluZ01hcmtzLCBtYXJrXSA6IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ01hcmtzID0ge1xuICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgfS5tYXJrcyB8fCBbXSwgbWFya3MgPSB7XG4gICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9LFxuICAgICAgICBtYXJrczogWy4uLmV4aXN0aW5nTWFya3MsIG1hcmtdXG4gICAgICB9O1xuICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgfVxuICB9XG4gIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uMiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgZWRpdG9yLnNlbGVjdGlvbiA9IHtcbiAgICAgIC4uLnNlbGVjdGlvbjJcbiAgICB9O1xuICB9XG59LCBkZWxldGVPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZShvcGVyYXRpb24uYXQsIG9wZXJhdGlvbi5lZGl0b3IpO1xuICBpZiAoIXJhbmdlKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBTbGF0ZSBSYW5nZSBmb3Igc2VsZWN0aW9uICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLmF0KX1gKTtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIGNvbnN0IFtmb2N1c0Jsb2NrXSA9IGdldEZvY3VzQmxvY2soe1xuICAgICAgZWRpdG9yOiB7XG4gICAgICAgIC4uLm9wZXJhdGlvbi5lZGl0b3IsXG4gICAgICAgIHNlbGVjdGlvbjogcmFuZ2VcbiAgICAgIH1cbiAgICB9KSwgW2ZvY3VzQ2hpbGRdID0gZ2V0Rm9jdXNDaGlsZCh7XG4gICAgICBlZGl0b3I6IHtcbiAgICAgICAgLi4ub3BlcmF0aW9uLmVkaXRvcixcbiAgICAgICAgc2VsZWN0aW9uOiByYW5nZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmb2N1c0Jsb2NrICYmIGZvY3VzQmxvY2suX3R5cGUgPT09IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUgJiYgZm9jdXNDaGlsZCAmJiBmb2N1c0NoaWxkLl90eXBlID09PSBjb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUpXG4gICAgICByZXR1cm47XG4gIH1cbiAgb3BlcmF0aW9uLmVkaXRvci5kZWxldGUoe1xuICAgIGF0OiByYW5nZVxuICB9KTtcbn0sIGRlbGV0ZUJhY2t3YXJkT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgZGVsZXRlQmFja3dhcmQob3BlcmF0aW9uLmVkaXRvciwgb3BlcmF0aW9uLnVuaXQpO1xufSwgZGVsZXRlQmxvY2tPcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZSh7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoOiBvcGVyYXRpb24uYXQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBwYXRoOiBvcGVyYXRpb24uYXQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XG4gIH0sIG9wZXJhdGlvbi5lZGl0b3IpO1xuICBpZiAoIXJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBmaW5kIFNsYXRlIHJhbmdlIGZyb20gc2VsZWN0aW9uIHBvaW50c1wiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgYXQ6IHJhbmdlXG4gIH0pO1xufSwgZGVsZXRlRm9yd2FyZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIGRlbGV0ZUZvcndhcmQob3BlcmF0aW9uLmVkaXRvciwgb3BlcmF0aW9uLnVuaXQpO1xufSwgaW5zZXJ0SW5saW5lT2JqZWN0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgcGFyc2VkSW5saW5lT2JqZWN0ID0gcGFyc2VJbmxpbmVPYmplY3Qoe1xuICAgIGNvbnRleHQsXG4gICAgaW5saW5lT2JqZWN0OiB7XG4gICAgICBfdHlwZTogb3BlcmF0aW9uLmlubGluZU9iamVjdC5uYW1lLFxuICAgICAgLi4ub3BlcmF0aW9uLmlubGluZU9iamVjdC52YWx1ZSA/PyB7fVxuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVmcmVzaEtleXM6ICExLFxuICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJzZWRJbmxpbmVPYmplY3QpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgaW5saW5lIG9iamVjdCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5pbmxpbmVPYmplY3QpfWApO1xuICBpZiAoIW9wZXJhdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbnNlcnQgaW5saW5lIG9iamVjdCB3aXRob3V0IHNlbGVjdGlvblwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW2ZvY3VzVGV4dEJsb2NrXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICBhdDogb3BlcmF0aW9uLmVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aCxcbiAgICBtYXRjaDogKG5vZGUpID0+IG9wZXJhdGlvbi5lZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSkpLmF0KDApID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gIGlmICghZm9jdXNUZXh0QmxvY2spIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIHBlcmZvcm0gYWN0aW9uIHdpdGhvdXQgZm9jdXMgdGV4dCBibG9ja1wiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGQgPSB0b1NsYXRlVmFsdWUoW3tcbiAgICBfdHlwZTogY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgIGNoaWxkcmVuOiBbcGFyc2VkSW5saW5lT2JqZWN0XVxuICB9XSwge1xuICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICB9KS5hdCgwKT8uY2hpbGRyZW4uYXQoMCk7XG4gIGlmICghY2hpbGQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCBpbmxpbmUgb2JqZWN0XCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIGNoaWxkKTtcbn0sIGluc2VydFNwYW5PcGVyYXRpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIG9wZXJhdGlvblxufSkgPT4ge1xuICBpZiAoIW9wZXJhdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwZXJmb3JtIGFjdGlvbiB3aXRob3V0IHNlbGVjdGlvblwiLCBvcGVyYXRpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMob3BlcmF0aW9uLmVkaXRvciwge1xuICAgIGF0OiBvcGVyYXRpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gb3BlcmF0aW9uLmVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFmb2N1c0Jsb2NrIHx8ICFmb2N1c0Jsb2NrUGF0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGVyZm9ybSBhY3Rpb24gd2l0aG91dCBmb2N1cyBibG9ja1wiLCBvcGVyYXRpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXJrRGVmcyA9IGZvY3VzQmxvY2subWFya0RlZnMgPz8gW10sIGFubm90YXRpb25zID0gb3BlcmF0aW9uLmFubm90YXRpb25zID8gb3BlcmF0aW9uLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICBfdHlwZTogYW5ub3RhdGlvbi5uYW1lLFxuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgLi4uYW5ub3RhdGlvbi52YWx1ZVxuICB9KSkgOiB2b2lkIDA7XG4gIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgbWFya0RlZnM6IFsuLi5tYXJrRGVmcywgLi4uYW5ub3RhdGlvbnNdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKG9wZXJhdGlvbi5lZGl0b3IsIHtcbiAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICB0ZXh0OiBvcGVyYXRpb24udGV4dCxcbiAgICBtYXJrczogWy4uLmFubm90YXRpb25zPy5tYXAoKGFubm90YXRpb24pID0+IGFubm90YXRpb24uX2tleSkgPz8gW10sIC4uLm9wZXJhdGlvbi5kZWNvcmF0b3JzID8/IFtdXVxuICB9KTtcbn0sIGluc2VydEJsb2NrT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgcGFyc2VkQmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICBibG9jazogb3BlcmF0aW9uLmJsb2NrLFxuICAgIGNvbnRleHQsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVmcmVzaEtleXM6ICExLFxuICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJzZWRCbG9jaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBibG9jayAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5ibG9jayl9YCk7XG4gIGNvbnN0IGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKFtwYXJzZWRCbG9ja10sIHtcbiAgICBzY2hlbWFUeXBlczogY29udGV4dC5zY2hlbWFcbiAgfSlbMF07XG4gIGlmICghZnJhZ21lbnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29udmVydCBibG9jayB0byBTbGF0ZSBmcmFnbWVudCAke0pTT04uc3RyaW5naWZ5KHBhcnNlZEJsb2NrKX1gKTtcbiAgaW5zZXJ0QmxvY2soe1xuICAgIGJsb2NrOiBmcmFnbWVudCxcbiAgICBwbGFjZW1lbnQ6IG9wZXJhdGlvbi5wbGFjZW1lbnQsXG4gICAgc2VsZWN0OiBvcGVyYXRpb24uc2VsZWN0ID8/IFwic3RhcnRcIixcbiAgICBlZGl0b3I6IG9wZXJhdGlvbi5lZGl0b3IsXG4gICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICB9KTtcbn07XG5mdW5jdGlvbiBpbnNlcnRCbG9jayh7XG4gIGJsb2NrLFxuICBwbGFjZW1lbnQsXG4gIHNlbGVjdCxcbiAgZWRpdG9yLFxuICBzY2hlbWFcbn0pIHtcbiAgY29uc3QgW3N0YXJ0QmxvY2ssIHN0YXJ0QmxvY2tQYXRoXSA9IGdldFNlbGVjdGlvblN0YXJ0QmxvY2soe1xuICAgIGVkaXRvclxuICB9KSwgW2VuZEJsb2NrLCBlbmRCbG9ja1BhdGhdID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2soe1xuICAgIGVkaXRvclxuICB9KTtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFzdGFydEJsb2NrIHx8ICFzdGFydEJsb2NrUGF0aCB8fCAhZW5kQmxvY2sgfHwgIWVuZEJsb2NrUGF0aCkge1xuICAgIHNlbGVjdCAhPT0gXCJub25lXCIgJiYgRE9NRWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgY29uc3QgW2xhc3RCbG9jaywgbGFzdEJsb2NrUGF0aF0gPSBnZXRMYXN0QmxvY2soe1xuICAgICAgZWRpdG9yXG4gICAgfSk7XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gXCJiZWZvcmVcIilcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgIGF0OiBbMF1cbiAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgWzBdKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgWzBdKSk7XG4gICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIGNvbnN0IG5leHRQYXRoID0gbGFzdEJsb2NrUGF0aCA/IFtsYXN0QmxvY2tQYXRoWzBdICsgMV0gOiBbMF07XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICBhdDogbmV4dFBhdGgsXG4gICAgICAgIHNlbGVjdDogITFcbiAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgbmV4dFBhdGgpKSA6IHNlbGVjdCA9PT0gXCJlbmRcIiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBuZXh0UGF0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGFzdEJsb2NrICYmIGlzRXF1YWxUb0VtcHR5RWRpdG9yKFtsYXN0QmxvY2tdLCBzY2hlbWEpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxhc3RCbG9ja1BhdGhcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbYmxvY2tdLCB7XG4gICAgICAgICAgYXQ6IGxhc3RCbG9ja1BhdGgsXG4gICAgICAgICAgc2VsZWN0OiAhMVxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgbGFzdEJsb2NrUGF0aCkpIDogc2VsZWN0ID09PSBcImVuZFwiICYmIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLmVuZChlZGl0b3IsIGxhc3RCbG9ja1BhdGgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgbGFzdEJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhsYXN0QmxvY2spKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkJlZm9yZSA9IEVkaXRvci5lbmQoZWRpdG9yLCBsYXN0QmxvY2tQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgICBhdDogRWRpdG9yLmVuZChlZGl0b3IsIGxhc3RCbG9ja1BhdGgpXG4gICAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uQmVmb3JlKSA6IHNlbGVjdCA9PT0gXCJub25lXCIgJiYgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGF0aCA9IGxhc3RCbG9ja1BhdGggPyBbbGFzdEJsb2NrUGF0aFswXSArIDFdIDogWzBdO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgYXQ6IG5leHRQYXRoLFxuICAgICAgICBzZWxlY3Q6ICExXG4gICAgICB9KSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGxhY2VtZW50ID09PSBcImJlZm9yZVwiKSB7XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBSYW5nZS5zdGFydChjdXJyZW50U2VsZWN0aW9uKTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgYXQ6IFtzZWxlY3Rpb25TdGFydFBvaW50LnBhdGhbMF1dLFxuICAgICAgc2VsZWN0OiAhMVxuICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW3NlbGVjdGlvblN0YXJ0UG9pbnQucGF0aFswXV0pKSA6IHNlbGVjdCA9PT0gXCJlbmRcIiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBbc2VsZWN0aW9uU3RhcnRQb2ludC5wYXRoWzBdXSkpO1xuICB9IGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gXCJhZnRlclwiKSB7XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIG5leHRQYXRoID0gW1JhbmdlLmVuZChjdXJyZW50U2VsZWN0aW9uKS5wYXRoWzBdICsgMV07XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgIGF0OiBuZXh0UGF0aCxcbiAgICAgIHNlbGVjdDogITFcbiAgICB9KSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiwgZW5kQmxvY2tFbmRQb2ludCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGVuZEJsb2NrUGF0aCk7XG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoY3VycmVudFNlbGVjdGlvbikgJiYgIWVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICBhdDogY3VycmVudFNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICB2b2lkczogITBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWRqdXN0ZWRTZWxlY3Rpb24gPSBuZXdTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCA/IFJhbmdlLnRyYW5zZm9ybShuZXdTZWxlY3Rpb24sIHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnRfbm9kZVwiLFxuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW25ld1NlbGVjdGlvbi5hbmNob3IucGF0aFswXV1cbiAgICAgIH0pIDogbmV3U2VsZWN0aW9uO1xuICAgICAgc2VsZWN0ID09PSBcIm5vbmVcIiAmJiBhZGp1c3RlZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGFkanVzdGVkU2VsZWN0aW9uKSwgZm9jdXNCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbZm9jdXNCbG9ja10sIHNjaGVtYSkgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGZvY3VzQmxvY2tQYXRoXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhlbmRCbG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRQb2ludCA9IFJhbmdlLnN0YXJ0KGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgaWYgKHNlbGVjdCA9PT0gXCJlbmRcIikge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgYXQ6IGN1cnJlbnRTZWxlY3Rpb24sXG4gICAgICAgIHZvaWRzOiAhMFxuICAgICAgfSksIHNlbGVjdCA9PT0gXCJzdGFydFwiID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb25TdGFydFBvaW50KSA6IFBvaW50LmVxdWFscyhzZWxlY3Rpb25TdGFydFBvaW50LCBlbmRCbG9ja0VuZFBvaW50KSB8fCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvblN0YXJ0UG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGVuZEJsb2NrKSkge1xuICAgICAgY29uc3QgZW5kQmxvY2tTdGFydFBvaW50ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgZW5kQmxvY2tQYXRoKSwgZW5kQmxvY2tFbmRQb2ludDIgPSBFZGl0b3IuZW5kKGVkaXRvciwgZW5kQmxvY2tQYXRoKSwgc2VsZWN0aW9uU3RhcnRQb2ludCA9IFJhbmdlLnN0YXJ0KGN1cnJlbnRTZWxlY3Rpb24pLCBzZWxlY3Rpb25FbmRQb2ludCA9IFJhbmdlLmVuZChjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChjdXJyZW50U2VsZWN0aW9uKSAmJiBQb2ludC5lcXVhbHMoc2VsZWN0aW9uU3RhcnRQb2ludCwgZW5kQmxvY2tTdGFydFBvaW50KSlcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgICBhdDogZW5kQmxvY2tQYXRoLFxuICAgICAgICAgIHNlbGVjdDogITFcbiAgICAgICAgfSksIChzZWxlY3QgPT09IFwic3RhcnRcIiB8fCBzZWxlY3QgPT09IFwiZW5kXCIpICYmIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgZW5kQmxvY2tQYXRoKSksIGlzRXF1YWxUb0VtcHR5RWRpdG9yKFtlbmRCbG9ja10sIHNjaGVtYSkgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogUGF0aC5uZXh0KGVuZEJsb2NrUGF0aClcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmIChSYW5nZS5pc0NvbGxhcHNlZChjdXJyZW50U2VsZWN0aW9uKSAmJiBQb2ludC5lcXVhbHMoc2VsZWN0aW9uRW5kUG9pbnQsIGVuZEJsb2NrRW5kUG9pbnQyKSkge1xuICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFtlbmRCbG9ja1BhdGhbMF0gKyAxXTtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIFtibG9ja10sIHtcbiAgICAgICAgICBhdDogbmV4dFBhdGgsXG4gICAgICAgICAgc2VsZWN0OiAhMVxuICAgICAgICB9KSwgKHNlbGVjdCA9PT0gXCJzdGFydFwiIHx8IHNlbGVjdCA9PT0gXCJlbmRcIikgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBuZXh0UGF0aCkpO1xuICAgICAgfSBlbHNlIGlmIChSYW5nZS5pc0V4cGFuZGVkKGN1cnJlbnRTZWxlY3Rpb24pICYmIFBvaW50LmVxdWFscyhzZWxlY3Rpb25TdGFydFBvaW50LCBlbmRCbG9ja1N0YXJ0UG9pbnQpICYmIFBvaW50LmVxdWFscyhzZWxlY3Rpb25FbmRQb2ludCwgZW5kQmxvY2tFbmRQb2ludDIpKVxuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgIGF0OiBjdXJyZW50U2VsZWN0aW9uXG4gICAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgZW5kQmxvY2tQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgZW5kQmxvY2tQYXRoKSk7XG4gICAgICBlbHNlIGlmIChSYW5nZS5pc0V4cGFuZGVkKGN1cnJlbnRTZWxlY3Rpb24pICYmIFBvaW50LmVxdWFscyhzZWxlY3Rpb25TdGFydFBvaW50LCBlbmRCbG9ja1N0YXJ0UG9pbnQpKVxuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgIGF0OiBjdXJyZW50U2VsZWN0aW9uXG4gICAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgZW5kQmxvY2tQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgZW5kQmxvY2tQYXRoKSk7XG4gICAgICBlbHNlIGlmIChSYW5nZS5pc0V4cGFuZGVkKGN1cnJlbnRTZWxlY3Rpb24pICYmIFBvaW50LmVxdWFscyhzZWxlY3Rpb25FbmRQb2ludCwgZW5kQmxvY2tFbmRQb2ludDIpKVxuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgIGF0OiBjdXJyZW50U2VsZWN0aW9uXG4gICAgICAgIH0pLCBzZWxlY3QgPT09IFwic3RhcnRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgUGF0aC5uZXh0KGVuZEJsb2NrUGF0aCkpKSA6IHNlbGVjdCA9PT0gXCJlbmRcIiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5lbmQoZWRpdG9yLCBQYXRoLm5leHQoZW5kQmxvY2tQYXRoKSkpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24yID0gZWRpdG9yLnNlbGVjdGlvbiwgW2ZvY3VzQ2hpbGRdID0gZ2V0Rm9jdXNDaGlsZCh7XG4gICAgICAgICAgZWRpdG9yXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZm9jdXNDaGlsZCAmJiBlZGl0b3IuaXNUZXh0U3Bhbihmb2N1c0NoaWxkKSlcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgICAgYXQ6IGN1cnJlbnRTZWxlY3Rpb24yXG4gICAgICAgICAgfSksIHNlbGVjdCA9PT0gXCJzdGFydFwiIHx8IHNlbGVjdCA9PT0gXCJlbmRcIiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgW2VuZEJsb2NrUGF0aFswXSArIDFdKSA6IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgY3VycmVudFNlbGVjdGlvbjIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFtlbmRCbG9ja1BhdGhbMF0gKyAxXTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICAgICAgYXQ6IG5leHRQYXRoLFxuICAgICAgICAgICAgc2VsZWN0OiAhMVxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGN1cnJlbnRTZWxlY3Rpb24yKSwgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgW2Jsb2NrXSwge1xuICAgICAgICBzZWxlY3Q6ICExXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHRQYXRoID0gW2VuZEJsb2NrUGF0aFswXSArIDFdO1xuICAgICAgc2VsZWN0ID09PSBcInN0YXJ0XCIgPyBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIG5leHRQYXRoKSkgOiBzZWxlY3QgPT09IFwiZW5kXCIgJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBFZGl0b3IuZW5kKGVkaXRvciwgbmV4dFBhdGgpKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG1vdmVCYWNrd2FyZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIFRyYW5zZm9ybXMubW92ZShvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgdW5pdDogXCJjaGFyYWN0ZXJcIixcbiAgICBkaXN0YW5jZTogb3BlcmF0aW9uLmRpc3RhbmNlLFxuICAgIHJldmVyc2U6ICEwXG4gIH0pO1xufSwgbW92ZUJsb2NrT3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgYXQgPSBbdG9TbGF0ZVBhdGgob3BlcmF0aW9uLmF0LCBvcGVyYXRpb24uZWRpdG9yKVswXV0sIHRvID0gW3RvU2xhdGVQYXRoKG9wZXJhdGlvbi50bywgb3BlcmF0aW9uLmVkaXRvcilbMF1dO1xuICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgYXQsXG4gICAgdG8sXG4gICAgbW9kZTogXCJoaWdoZXN0XCJcbiAgfSk7XG59LCBtb3ZlRm9yd2FyZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgb3BlcmF0aW9uXG59KSA9PiB7XG4gIFRyYW5zZm9ybXMubW92ZShvcGVyYXRpb24uZWRpdG9yLCB7XG4gICAgdW5pdDogXCJjaGFyYWN0ZXJcIixcbiAgICBkaXN0YW5jZTogb3BlcmF0aW9uLmRpc3RhbmNlXG4gIH0pO1xufSwgc2VsZWN0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBvcGVyYXRpb25cbn0pID0+IHtcbiAgY29uc3QgbmV3U2VsZWN0aW9uID0gdG9TbGF0ZVJhbmdlKG9wZXJhdGlvbi5hdCwgb3BlcmF0aW9uLmVkaXRvcik7XG4gIG5ld1NlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KG9wZXJhdGlvbi5lZGl0b3IsIG5ld1NlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KG9wZXJhdGlvbi5lZGl0b3IpO1xufSwgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnMgPSB7XG4gIFwiYW5ub3RhdGlvbi5hZGRcIjogYWRkQW5ub3RhdGlvbk9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImFubm90YXRpb24ucmVtb3ZlXCI6IHJlbW92ZUFubm90YXRpb25PcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJibG9jay5zZXRcIjogYmxvY2tTZXRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJibG9jay51bnNldFwiOiBibG9ja1Vuc2V0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiZGVjb3JhdG9yLmFkZFwiOiBkZWNvcmF0b3JBZGRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWNvcmF0b3IucmVtb3ZlXCI6IHJlbW92ZURlY29yYXRvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBkZWxldGU6IGRlbGV0ZU9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlbGV0ZS5iYWNrd2FyZFwiOiBkZWxldGVCYWNrd2FyZE9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlbGV0ZS5mb3J3YXJkXCI6IGRlbGV0ZUZvcndhcmRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWxldGUuYmxvY2tcIjogZGVsZXRlQmxvY2tPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJoaXN0b3J5LnJlZG9cIjogaGlzdG9yeVJlZG9PcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJoaXN0b3J5LnVuZG9cIjogaGlzdG9yeVVuZG9PcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuYmxvY2tcIjogaW5zZXJ0QmxvY2tPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiBpbnNlcnRJbmxpbmVPYmplY3RPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuc3BhblwiOiBpbnNlcnRTcGFuT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LnRleHRcIjogaW5zZXJ0VGV4dE9wZXJhdGlvbkltcGxlbWVudGF0aW9uLFxuICBcIm1vdmUuYmFja3dhcmRcIjogbW92ZUJhY2t3YXJkT3BlcmF0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwibW92ZS5ibG9ja1wiOiBtb3ZlQmxvY2tPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJtb3ZlLmZvcndhcmRcIjogbW92ZUZvcndhcmRPcGVyYXRpb25JbXBsZW1lbnRhdGlvbixcbiAgc2VsZWN0OiBzZWxlY3RPcGVyYXRpb25JbXBsZW1lbnRhdGlvblxufTtcbmZ1bmN0aW9uIHBlcmZvcm1PcGVyYXRpb24oe1xuICBjb250ZXh0LFxuICBvcGVyYXRpb25cbn0pIHtcbiAgdHJ5IHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiYW5ub3RhdGlvbi5hZGRcIjoge1xuICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24uYWRkXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYW5ub3RhdGlvbi5yZW1vdmVcIjoge1xuICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24ucmVtb3ZlXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYmxvY2suc2V0XCI6IHtcbiAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJibG9jay5zZXRcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJibG9jay51bnNldFwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiYmxvY2sudW5zZXRcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWNvcmF0b3IuYWRkXCI6IHtcbiAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWNvcmF0b3IuYWRkXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVjb3JhdG9yLnJlbW92ZVwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVjb3JhdG9yLnJlbW92ZVwiXSh7XG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZVwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zLmRlbGV0ZSh7XG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS5iYWNrd2FyZFwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlLmJhY2t3YXJkXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLmJsb2NrXCI6IHtcbiAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUuYmxvY2tcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUuZm9yd2FyZFwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlLmZvcndhcmRcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJoaXN0b3J5LnJlZG9cIjoge1xuICAgICAgICBiZWhhdmlvck9wZXJhdGlvbkltcGxlbWVudGF0aW9uc1tcImhpc3RvcnkucmVkb1wiXSh7XG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImhpc3RvcnkudW5kb1wiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiaGlzdG9yeS51bmRvXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiaW5zZXJ0LmJsb2NrXCI6IHtcbiAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQuYmxvY2tcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LmlubGluZSBvYmplY3RcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJpbnNlcnQuc3BhblwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LnNwYW5cIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJpbnNlcnQudGV4dFwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LnRleHRcIl0oe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtb3ZlLmJhY2t3YXJkXCI6IHtcbiAgICAgICAgYmVoYXZpb3JPcGVyYXRpb25JbXBsZW1lbnRhdGlvbnNbXCJtb3ZlLmJhY2t3YXJkXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibW92ZS5ibG9ja1wiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5ibG9ja1wiXSh7XG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1vdmUuZm9yd2FyZFwiOiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5mb3J3YXJkXCJdKHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJlaGF2aW9yT3BlcmF0aW9uSW1wbGVtZW50YXRpb25zLnNlbGVjdCh7XG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgRXhlY3V0aW5nIFwiJHtvcGVyYXRpb24udHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICB9XG59XG5jb25zdCBDVVJSRU5UX09QRVJBVElPTl9JRCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aEFwcGx5aW5nQmVoYXZpb3JPcGVyYXRpb25zKGVkaXRvciwgZm4pIHtcbiAgQ1VSUkVOVF9PUEVSQVRJT05fSUQuc2V0KGVkaXRvciwgZGVmYXVsdEtleUdlbmVyYXRvcigpKSwgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZuKSwgQ1VSUkVOVF9PUEVSQVRJT05fSUQuc2V0KGVkaXRvciwgdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRPcGVyYXRpb25JZChlZGl0b3IpIHtcbiAgcmV0dXJuIENVUlJFTlRfT1BFUkFUSU9OX0lELmdldChlZGl0b3IpO1xufVxuZnVuY3Rpb24gaXNBcHBseWluZ0JlaGF2aW9yT3BlcmF0aW9ucyhlZGl0b3IpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnRPcGVyYXRpb25JZChlZGl0b3IpICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoRXZlbnRMaXN0ZW5lcnMoZWRpdG9yQWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQubWF4QmxvY2tzICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIGluc2VydFRleHQsXG4gICAgICBzZWxlY3RcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvck9wZXJhdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBjYWxsIHRvIC5kZWxldGVCYWNrd2FyZCguLi4pXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmRlbGV0ZUZvcndhcmQgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvck9wZXJhdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBjYWxsIHRvIC5kZWxldGVGb3J3YXJkKC4uLilcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS5mb3J3YXJkXCIsXG4gICAgICAgICAgdW5pdFxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICAgIGlmIChpc0FwcGx5aW5nQmVoYXZpb3JPcGVyYXRpb25zKGVkaXRvcikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgY2FsbCB0byAuaW5zZXJ0QnJlYWsoLi4uKVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LmJyZWFrXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0RGF0YSA9IChkYXRhVHJhbnNmZXIpID0+IHtcbiAgICAgIGlmIChpc0FwcGx5aW5nQmVoYXZpb3JPcGVyYXRpb25zKGVkaXRvcikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgY2FsbCB0byAuaW5zZXJ0RGF0YSguLi4pXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnB1dC4qXCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrID0gKCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvck9wZXJhdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBpbnNlcnRUZXh0T3BlcmF0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgICAgICB0ZXh0OiBgXG5gLFxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LnNvZnQgYnJlYWtcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRUZXh0ID0gKHRleHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpc0FwcGx5aW5nQmVoYXZpb3JPcGVyYXRpb25zKGVkaXRvcikpIHtcbiAgICAgICAgaW5zZXJ0VGV4dCh0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnJlZG8gPSAoKSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yT3BlcmF0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIHBlcmZvcm1PcGVyYXRpb24oe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcImhpc3RvcnkucmVkb1wiLFxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS5yZWRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3Iuc2VsZWN0ID0gKGxvY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yT3BlcmF0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIHNlbGVjdChsb2NhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgbG9jYXRpb24pO1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgYXQ6IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnNldEZyYWdtZW50RGF0YSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGNhbGwgdG8gLnNldEZyYWdtZW50RGF0YSguLi4pXCIpO1xuICAgIH0sIGVkaXRvci51bmRvID0gKCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvck9wZXJhdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBwZXJmb3JtT3BlcmF0aW9uKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJoaXN0b3J5LnVuZG9cIixcbiAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImhpc3RvcnkudW5kb1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlV2l0aE1heEJsb2NrcyhlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQubWF4QmxvY2tzID8/IC0xO1xuICAgICAgcm93cyA+IDAgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+PSByb3dzICYmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiIHx8IG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxIHx8IGFwcGx5MihvcGVyYXRpb24pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhPYmplY3RLZXlzKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyLFxuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IFsuLi5Ob2RlLmRlc2NlbmRhbnRzKGVkaXRvcildLm1hcCgoW25vZGVdKSA9PiBub2RlLl9rZXkpO1xuICAgICAgICBhcHBseTIoe1xuICAgICAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb24ucHJvcGVydGllcyxcbiAgICAgICAgICAgIF9rZXk6IG9wZXJhdGlvbi5wcm9wZXJ0aWVzLl9rZXkgPT09IHZvaWQgMCB8fCBleGlzdGluZ0tleXMuaW5jbHVkZXMob3BlcmF0aW9uLnByb3BlcnRpZXMuX2tleSkgPyBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCkgOiBvcGVyYXRpb24ucHJvcGVydGllcy5fa2V5XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcImluc2VydF9ub2RlXCIgJiYgIUVkaXRvci5pc0VkaXRvcihvcGVyYXRpb24ubm9kZSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gWy4uLk5vZGUuZGVzY2VuZGFudHMoZWRpdG9yKV0ubWFwKChbbm9kZV0pID0+IG5vZGUuX2tleSk7XG4gICAgICAgIGFwcGx5Mih7XG4gICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlLFxuICAgICAgICAgICAgX2tleTogb3BlcmF0aW9uLm5vZGUuX2tleSA9PT0gdm9pZCAwIHx8IGV4aXN0aW5nS2V5cy5pbmNsdWRlcyhvcGVyYXRpb24ubm9kZS5fa2V5KSA/IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSA6IG9wZXJhdGlvbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBub2RlLl90eXBlID09PSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUpIHtcbiAgICAgICAgaWYgKCFub2RlLl9rZXkpIHtcbiAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgaWYgKCFjaGlsZC5fa2V5KSB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGUgPSBkZWJ1Z1dpdGhOYW1lKFwiYXBwbHlQYXRjaGVzXCIpLCBkZWJ1Z1ZlcmJvc2UgPSBkZWJ1ZyRlLmVuYWJsZWQgJiYgITA7XG5mdW5jdGlvbiBjcmVhdGVBcHBseVBhdGNoKHNjaGVtYSkge1xuICByZXR1cm4gKGVkaXRvciwgcGF0Y2gpID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgIGRlYnVnVmVyYm9zZSAmJiAoZGVidWckZShgXG5cbk5FVyBQQVRDSCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09YCksIGRlYnVnJGUoSlNPTi5zdHJpbmdpZnkocGF0Y2gsIG51bGwsIDIpKSk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAocGF0Y2gudHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSB1bnNldFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IHNldFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGlmZk1hdGNoUGF0Y2hcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVidWckZShcIlVuaGFuZGxlZCBwYXRjaFwiLCBwYXRjaC50eXBlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG59XG5mdW5jdGlvbiBkaWZmTWF0Y2hQYXRjaChlZGl0b3IsIHBhdGNoKSB7XG4gIGNvbnN0IHtcbiAgICBibG9jayxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gZGVidWckZShcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGlmICghY2hpbGQgfHwgIWNoaWxkUGF0aClcbiAgICByZXR1cm4gZGVidWckZShcIkNoaWxkIG5vdCBmb3VuZFwiKSwgITE7XG4gIGlmICghKGJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDQgJiYgcGF0Y2gucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiICYmIHBhdGNoLnBhdGhbM10gPT09IFwidGV4dFwiKSB8fCAhVGV4dC5pc1RleHQoY2hpbGQpKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgcGF0Y2hlcyA9IHBhcnNlKHBhdGNoLnZhbHVlKSwgW25ld1ZhbHVlXSA9IGFwcGx5KHBhdGNoZXMsIGNoaWxkLnRleHQsIHtcbiAgICBhbGxvd0V4Y2VlZGluZ0luZGljZXM6ICEwXG4gIH0pLCBkaWZmJDEgPSBjbGVhbnVwRWZmaWNpZW5jeShkaWZmKGNoaWxkLnRleHQsIG5ld1ZhbHVlKSwgNSk7XG4gIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgW29wLCB0ZXh0XSBvZiBkaWZmJDEpXG4gICAgb3AgPT09IERJRkZfSU5TRVJUID8gKGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiBcImluc2VydF90ZXh0XCIsXG4gICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXh0XG4gICAgfSksIG9mZnNldCArPSB0ZXh0Lmxlbmd0aCkgOiBvcCA9PT0gRElGRl9ERUxFVEUgPyBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJyZW1vdmVfdGV4dFwiLFxuICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGV4dFxuICAgIH0pIDogb3AgPT09IERJRkZfRVFVQUwgJiYgKG9mZnNldCArPSB0ZXh0Lmxlbmd0aCk7XG4gIHJldHVybiBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG59XG5mdW5jdGlvbiBpbnNlcnRQYXRjaChlZGl0b3IsIHBhdGNoLCBzY2hlbWEpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrOiB0YXJnZXRCbG9jayxcbiAgICBjaGlsZDogdGFyZ2V0Q2hpbGQsXG4gICAgYmxvY2tQYXRoOiB0YXJnZXRCbG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiB0YXJnZXRDaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCF0YXJnZXRCbG9jayB8fCAhdGFyZ2V0QmxvY2tQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyRlKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJGUoXCJJZ25vcmluZyBwYXRjaCB0YXJnZXRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1zOiBpdGVtczIsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24yXG4gICAgfSA9IHBhdGNoLCBibG9ja3NUb0luc2VydCA9IHRvU2xhdGVWYWx1ZShpdGVtczIsIHtcbiAgICAgIHNjaGVtYVR5cGVzOiBzY2hlbWFcbiAgICB9LCBLRVlfVE9fU0xBVEVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIHRhcmdldEJsb2NrSW5kZXggPSB0YXJnZXRCbG9ja1BhdGhbMF0sIG5vcm1hbGl6ZWRJZHgyID0gcG9zaXRpb24yID09PSBcImFmdGVyXCIgPyB0YXJnZXRCbG9ja0luZGV4ICsgMSA6IHRhcmdldEJsb2NrSW5kZXg7XG4gICAgZGVidWckZShgSW5zZXJ0aW5nIGJsb2NrcyBhdCBwYXRoIFske25vcm1hbGl6ZWRJZHgyfV1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpO1xuICAgIGNvbnN0IGVkaXRvcldhc0VtcHR5QmVmb3JlID0gaXNFcXVhbFRvRW1wdHlFZGl0b3IoZWRpdG9yLmNoaWxkcmVuLCBzY2hlbWEpO1xuICAgIHJldHVybiBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2tzVG9JbnNlcnQsIHtcbiAgICAgIGF0OiBbbm9ybWFsaXplZElkeDJdXG4gICAgfSksIGVkaXRvcldhc0VtcHR5QmVmb3JlICYmIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogW3Bvc2l0aW9uMiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0QmxvY2tJbmRleCArIDEgOiB0YXJnZXRCbG9ja0luZGV4XVxuICAgIH0pLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGl0ZW1zLFxuICAgIHBvc2l0aW9uXG4gIH0gPSBwYXRjaDtcbiAgaWYgKCF0YXJnZXRDaGlsZCB8fCAhdGFyZ2V0Q2hpbGRQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyRlKFwiQ2hpbGQgbm90IGZvdW5kXCIpLCAhMTtcbiAgY29uc3QgY2hpbGRyZW5Ub0luc2VydCA9IHRhcmdldEJsb2NrICYmIHRvU2xhdGVWYWx1ZShbe1xuICAgIC4uLnRhcmdldEJsb2NrLFxuICAgIGNoaWxkcmVuOiBpdGVtc1xuICB9XSwge1xuICAgIHNjaGVtYVR5cGVzOiBzY2hlbWFcbiAgfSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCB0YXJnZXRDaGlsZEluZGV4ID0gdGFyZ2V0Q2hpbGRQYXRoWzFdLCBub3JtYWxpemVkSWR4ID0gcG9zaXRpb24gPT09IFwiYWZ0ZXJcIiA/IHRhcmdldENoaWxkSW5kZXggKyAxIDogdGFyZ2V0Q2hpbGRJbmRleCwgY2hpbGRJbnNlcnRQYXRoID0gW3RhcmdldENoaWxkUGF0aFswXSwgbm9ybWFsaXplZElkeF07XG4gIHJldHVybiBkZWJ1ZyRlKGBJbnNlcnRpbmcgY2hpbGRyZW4gYXQgcGF0aCAke2NoaWxkSW5zZXJ0UGF0aH1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBjaGlsZHJlblRvSW5zZXJ0ICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGRyZW5Ub0luc2VydFswXSkgJiYgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkcmVuVG9JbnNlcnRbMF0uY2hpbGRyZW4sIHtcbiAgICBhdDogY2hpbGRJbnNlcnRQYXRoXG4gIH0pLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG59XG5mdW5jdGlvbiBzZXRQYXRjaChlZGl0b3IsIHBhdGNoKSB7XG4gIGxldCB2YWx1ZSA9IHBhdGNoLnZhbHVlO1xuICB0eXBlb2YgcGF0Y2gucGF0aFszXSA9PSBcInN0cmluZ1wiICYmICh2YWx1ZSA9IHt9LCB2YWx1ZVtwYXRjaC5wYXRoWzNdXSA9IHBhdGNoLnZhbHVlKTtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gZGVidWckZShcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGlzVGV4dEJsb2NrMiA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jayk7XG4gIGlmIChpc1RleHRCbG9jazIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm4gZGVidWckZShcIklnbm9yaW5nIHNldHRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGlzVGV4dEJsb2NrMiAmJiBjaGlsZCAmJiBjaGlsZFBhdGgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQodmFsdWUpICYmIFRleHQuaXNUZXh0KGNoaWxkKSkge1xuICAgICAgY29uc3QgbmV3VGV4dCA9IGNoaWxkLnRleHQ7XG4gICAgICB2YWx1ZS50ZXh0ICE9PSBuZXdUZXh0ICYmIChkZWJ1ZyRlKFwiU2V0dGluZyB0ZXh0IHByb3BlcnR5XCIpLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICB9KSwgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgdGV4dDogdmFsdWUudGV4dFxuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9IGVsc2VcbiAgICAgIGRlYnVnJGUoXCJTZXR0aW5nIG5vbi10ZXh0IHByb3BlcnR5XCIpLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcInNldF9ub2RlXCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IHZhbHVlXG4gICAgICB9KTtcbiAgICByZXR1cm4gITA7XG4gIH0gZWxzZSBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEgJiYgYmxvY2tQYXRoKSB7XG4gICAgZGVidWckZShcIlNldHRpbmcgYmxvY2sgcHJvcGVydHlcIik7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5uZXh0UmVzdFxuICAgIH0gPSB2YWx1ZSwge1xuICAgICAgY2hpbGRyZW46IHByZXZDaGlsZHJlbixcbiAgICAgIC4uLnByZXZSZXN0XG4gICAgfSA9IGJsb2NrIHx8IHtcbiAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICB9O1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiBcInNldF9ub2RlXCIsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC4uLnByZXZSZXN0XG4gICAgICB9LFxuICAgICAgbmV3UHJvcGVydGllczogbmV4dFJlc3RcbiAgICB9KSwgZGVidWckZShcIlNldHRpbmcgY2hpbGRyZW5cIiksIGJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGMyLCBjSW5kZXgpID0+IHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlX25vZGVcIixcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLmNvbmNhdChibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxIC0gY0luZGV4KSxcbiAgICAgICAgbm9kZTogYzJcbiAgICAgIH0pO1xuICAgIH0pLCBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5mb3JFYWNoKChjMiwgY0luZGV4KSA9PiB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcImluc2VydF9ub2RlXCIsXG4gICAgICAgIHBhdGg6IGJsb2NrUGF0aC5jb25jYXQoY0luZGV4KSxcbiAgICAgICAgbm9kZTogYzJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGJsb2NrICYmIFwidmFsdWVcIiBpbiBibG9jaylcbiAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIikge1xuICAgICAgY29uc3QgbmV3VmFsID0gYXBwbHlBbGwoYmxvY2sudmFsdWUsIFt7XG4gICAgICAgIC4uLnBhdGNoLFxuICAgICAgICBwYXRoOiBwYXRjaC5wYXRoLnNsaWNlKDEpXG4gICAgICB9XSk7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgdmFsdWU6IG5ld1ZhbFxuICAgICAgfSwge1xuICAgICAgICBhdDogYmxvY2tQYXRoXG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIHVuc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBkZWJ1ZyRlKFwiUmVtb3ZpbmcgZXZlcnl0aGluZ1wiKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpO1xuICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgW10sIHtcbiAgICAgIHJldmVyc2U6ICEwXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbXywgcGF0aF0gb2YgY2hpbGRyZW4pXG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aFxuICAgICAgfSk7XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgfSkpLCBwcmV2aW91c1NlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFibG9jayB8fCAhYmxvY2tQYXRoKVxuICAgICAgcmV0dXJuIGRlYnVnJGUoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICAgIGNvbnN0IGJsb2NrSW5kZXggPSBibG9ja1BhdGhbMF07XG4gICAgcmV0dXJuIGRlYnVnJGUoYFJlbW92aW5nIGJsb2NrIGF0IHBhdGggWyR7YmxvY2tJbmRleH1dYCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbYmxvY2tJbmRleF1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMyA/ICFjaGlsZCB8fCAhY2hpbGRQYXRoID8gKGRlYnVnJGUoXCJDaGlsZCBub3QgZm91bmRcIiksICExKSA6IChkZWJ1ZyRlKGBVbnNldHRpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgZGVidWdWZXJib3NlICYmIGRlYnVnJGUoYFJlbW92aW5nIGNoaWxkIGF0IHBhdGggJHtKU09OLnN0cmluZ2lmeShjaGlsZFBhdGgpfWApLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBjaGlsZFBhdGhcbiAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMCkgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzS2V5ZWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWdtZW50ID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnU3RhdGUoZWRpdG9yLCBzdGF0ZU5hbWUpIHtcbiAgZGVidWdWZXJib3NlICYmIChkZWJ1ZyRlKGBDaGlsZHJlbiAke3N0YXRlTmFtZX06YCwgSlNPTi5zdHJpbmdpZnkoZWRpdG9yLmNoaWxkcmVuLCBudWxsLCAyKSksIGRlYnVnJGUoYFNlbGVjdGlvbiAke3N0YXRlTmFtZX06IGAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5zZWxlY3Rpb24sIG51bGwsIDIpKSk7XG59XG5mdW5jdGlvbiBmaW5kQmxvY2tGcm9tUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgbGV0IGJsb2NrSW5kZXggPSAtMTtcbiAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW4uZmluZCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc01hdGNoID0gaXNLZXllZFNlZ21lbnQocGF0aFswXSkgPyBub2RlLl9rZXkgPT09IHBhdGhbMF0uX2tleSA6IGluZGV4ID09PSBwYXRoWzBdO1xuICAgIHJldHVybiBpc01hdGNoICYmIChibG9ja0luZGV4ID0gaW5kZXgpLCBpc01hdGNoO1xuICB9KTtcbiAgcmV0dXJuIGJsb2NrID8ge1xuICAgIGJsb2NrLFxuICAgIHBhdGg6IFtibG9ja0luZGV4XVxuICB9IDoge307XG59XG5mdW5jdGlvbiBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0aCkge1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgcGF0aDogYmxvY2tQYXRoXG4gIH0gPSBmaW5kQmxvY2tGcm9tUGF0aChlZGl0b3IsIHBhdGgpO1xuICBpZiAoIShFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBwYXRoWzFdID09PSBcImNoaWxkcmVuXCIpKVxuICAgIHJldHVybiB7XG4gICAgICBibG9jayxcbiAgICAgIGJsb2NrUGF0aCxcbiAgICAgIGNoaWxkOiB2b2lkIDAsXG4gICAgICBjaGlsZFBhdGg6IHZvaWQgMFxuICAgIH07XG4gIGxldCBjaGlsZEluZGV4ID0gLTE7XG4gIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW4uZmluZCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc01hdGNoID0gaXNLZXllZFNlZ21lbnQocGF0aFsyXSkgPyBub2RlLl9rZXkgPT09IHBhdGhbMl0uX2tleSA6IGluZGV4ID09PSBwYXRoWzJdO1xuICAgIHJldHVybiBpc01hdGNoICYmIChjaGlsZEluZGV4ID0gaW5kZXgpLCBpc01hdGNoO1xuICB9KTtcbiAgcmV0dXJuIGNoaWxkID8ge1xuICAgIGJsb2NrLFxuICAgIGNoaWxkLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZFBhdGg6IGJsb2NrUGF0aD8uY29uY2F0KGNoaWxkSW5kZXgpXG4gIH0gOiB7XG4gICAgYmxvY2ssXG4gICAgYmxvY2tQYXRoLFxuICAgIGNoaWxkOiB2b2lkIDAsXG4gICAgY2hpbGRQYXRoOiB2b2lkIDBcbiAgfTtcbn1cbmNvbnN0IFBBVENISU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRob3V0UGF0Y2hpbmcoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNQYXRjaGluZyhlZGl0b3IpO1xuICBQQVRDSElORy5zZXQoZWRpdG9yLCAhMSksIGZuKCksIFBBVENISU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNQYXRjaGluZyhlZGl0b3IpIHtcbiAgcmV0dXJuIFBBVENISU5HLmdldChlZGl0b3IpO1xufVxuY29uc3QgZGVidWckZCA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBhdGNoZXNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUGF0Y2hlcyh7XG4gIGVkaXRvckFjdG9yLFxuICBwYXRjaEZ1bmN0aW9ucyxcbiAgc3Vic2NyaXB0aW9uc1xufSkge1xuICBsZXQgcHJldmlvdXNDaGlsZHJlbjtcbiAgY29uc3QgYXBwbHlQYXRjaCA9IGNyZWF0ZUFwcGx5UGF0Y2goZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSk7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsICExKSwgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITApLCBwcmV2aW91c0NoaWxkcmVuID0gWy4uLmVkaXRvci5jaGlsZHJlbl07XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgbGV0IGJ1ZmZlcmVkUGF0Y2hlcyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZUJ1ZmZlcmVkUmVtb3RlUGF0Y2hlcyA9ICgpID0+IHtcbiAgICAgIGlmIChidWZmZXJlZFBhdGNoZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwYXRjaGVzID0gYnVmZmVyZWRQYXRjaGVzO1xuICAgICAgYnVmZmVyZWRQYXRjaGVzID0gW107XG4gICAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgICAgd2l0aFJlbW90ZUNoYW5nZXMoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgZGVidWckZC5lbmFibGVkICYmIGRlYnVnJGQoYEhhbmRsaW5nIHJlbW90ZSBwYXRjaCAke0pTT04uc3RyaW5naWZ5KHBhdGNoKX1gKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGFwcGx5UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFwcGx5aW5nIHBhdGNoICR7SlNPTi5zdHJpbmdpZnkocGF0Y2gpfSBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNoYW5nZWQgJiYgKGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfSk7XG4gICAgfSwgaGFuZGxlUGF0Y2hlcyA9ICh7XG4gICAgICBwYXRjaGVzXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IHBhdGNoZXMuZmlsdGVyKChwKSA9PiBwLm9yaWdpbiAhPT0gXCJsb2NhbFwiKTtcbiAgICAgIHJlbW90ZVBhdGNoZXMubGVuZ3RoICE9PSAwICYmIChidWZmZXJlZFBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXMuY29uY2F0KHJlbW90ZVBhdGNoZXMpLCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGQoXCJTdWJzY3JpYmluZyB0byByZW1vdGUgcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCBoYW5kbGVQYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGQoXCJVbnN1YnNjcmliaW5nIHRvIHJlbW90ZSBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGxldCBwYXRjaGVzID0gW107XG4gICAgICBwcmV2aW91c0NoaWxkcmVuID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZWRpdG9yV2FzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihwcmV2aW91c0NoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hKTtcbiAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgY29uc3QgZWRpdG9ySXNFbXB0eSA9IGlzRXF1YWxUb0VtcHR5RWRpdG9yKGVkaXRvci5jaGlsZHJlbiwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSk7XG4gICAgICBpZiAoIWlzUGF0Y2hpbmcoZWRpdG9yKSlcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIHN3aXRjaCAoZWRpdG9yV2FzRW1wdHkgJiYgIWVkaXRvcklzRW1wdHkgJiYgb3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIHBhdGNoZXMucHVzaChpbnNlcnQocHJldmlvdXNDaGlsZHJlbiwgXCJiZWZvcmVcIiwgWzBdKSksIG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuaW5zZXJ0VGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMucmVtb3ZlVGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMucmVtb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcGxpdF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5zcGxpdE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5zZXJ0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLmluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVyZ2Vfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMubWVyZ2VOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMubW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3JXYXNFbXB0eSAmJiBlZGl0b3JJc0VtcHR5ICYmIFtcIm1lcmdlX25vZGVcIiwgXCJzZXRfbm9kZVwiLCBcInJlbW92ZV90ZXh0XCIsIFwicmVtb3ZlX25vZGVcIl0uaW5jbHVkZXMob3BlcmF0aW9uLnR5cGUpICYmIChwYXRjaGVzID0gWy4uLnBhdGNoZXMsIHVuc2V0KFtdKV0sIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcIm5vdGlmeS51bnNldFwiLFxuICAgICAgICBwcmV2aW91c1ZhbHVlOiBmcm9tU2xhdGVWYWx1ZShwcmV2aW91c0NoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVxuICAgICAgfSkpLCBlZGl0b3JXYXNFbXB0eSAmJiBwYXRjaGVzLmxlbmd0aCA+IDAgJiYgKHBhdGNoZXMgPSBbc2V0SWZNaXNzaW5nKFtdLCBbXSksIC4uLnBhdGNoZXNdKSwgcGF0Y2hlcy5sZW5ndGggPiAwKVxuICAgICAgICBmb3IgKGNvbnN0IHBhdGNoIG9mIHBhdGNoZXMpXG4gICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImludGVybmFsLnBhdGNoXCIsXG4gICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICAuLi5wYXRjaCxcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcGVyYXRpb25JZDogZ2V0Q3VycmVudE9wZXJhdGlvbklkKGVkaXRvciksXG4gICAgICAgICAgICB2YWx1ZTogZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRjID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGxhY2Vob2xkZXJCbG9ja1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcC5ub2RlO1xuICAgICAgICBpZiAob3AucGF0aFswXSA9PT0gMCAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFBhdGgubmV4dChvcC5wYXRoKTtcbiAgICAgICAgICBlZGl0b3IuY2hpbGRyZW5bbmV4dFBhdGhbMF1dIHx8IChkZWJ1ZyRjKFwiQWRkaW5nIHBsYWNlaG9sZGVyIGJsb2NrXCIpLCBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGIgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUoZWRpdG9yQWN0b3IpIHtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0ubmFtZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBlZGl0b3Iub3BlcmF0aW9ucylcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRCbG9jayhvcC5wcm9wZXJ0aWVzKSAmJiBvcC5wcm9wZXJ0aWVzLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgJiYgb3AucGF0aFswXSA9PT0gcGF0aFswXSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgb3AucGF0aCkpIHtcbiAgICAgICAgICBjb25zdCBbY2hpbGRdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDEsIDBdKTtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoY2hpbGQpICYmIGNoaWxkLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJGIoYE5vcm1hbGl6aW5nIHNwbGl0IG5vZGUgdG8gJHtkZWZhdWx0U3R5bGV9IHN0eWxlYCwgb3ApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogW29wLnBhdGhbMF0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5kZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZWRpdG9yQWN0b3IpIHtcbiAgbGV0IHByZXZTZWxlY3Rpb24gPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgZW1pdFBvcnRhYmxlVGV4dFNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChwcmV2U2VsZWN0aW9uICE9PSBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBwdFJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UuZ2V0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGV4aXN0aW5nID8gcHRSYW5nZSA9IGV4aXN0aW5nIDogKHB0UmFuZ2UgPSBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgICAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcmFuZ2U6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgICB9KSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5zZXQoZWRpdG9yLnNlbGVjdGlvbiwgcHRSYW5nZSkpO1xuICAgICAgICB9XG4gICAgICAgIHB0UmFuZ2UgPyBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5zZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IHB0UmFuZ2VcbiAgICAgICAgfSkgOiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5zZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB9LCB7XG4gICAgICBvbkNoYW5nZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgIG9uQ2hhbmdlKCksIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIHNldHVwOiBcInNldHRpbmcgdXBcIlxuICAgICAgfSkgfHwgZW1pdFBvcnRhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGEgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhTY2hlbWFUeXBlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhTY2hlbWFUeXBlcyh7XG4gIGVkaXRvckFjdG9yXG59KSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuaXNUZXh0QmxvY2sgPSAodmFsdWUpID0+IGlzVGV4dEJsb2NrKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgdmFsdWUpLCBlZGl0b3IuaXNUZXh0U3BhbiA9ICh2YWx1ZSkgPT4gaXNTcGFuKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgdmFsdWUpLCBlZGl0b3IuaXNMaXN0QmxvY2sgPSAodmFsdWUpID0+IGlzTGlzdEJsb2NrKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dCwgdmFsdWUpLCBlZGl0b3IuaXNWb2lkID0gKGVsZW1lbnQpID0+IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSAhPT0gZWxlbWVudC5fdHlwZSAmJiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9ja09iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSB8fCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSksIGVkaXRvci5pc0lubGluZSA9IChlbGVtZW50KSA9PiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSAmJiBcIl9faW5saW5lXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50Ll9faW5saW5lID09PSAhMDtcbiAgICBjb25zdCB7XG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKG5vZGUuX3R5cGUgPT09IHZvaWQgMCAmJiBwYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBkZWJ1ZyRhKFwiU2V0dGluZyBzcGFuIHR5cGUgb24gdGV4dCBub2RlIHdpdGhvdXQgYSB0eXBlXCIpO1xuICAgICAgICBjb25zdCBzcGFuID0gbm9kZSwga2V5ID0gc3Bhbi5fa2V5IHx8IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLnNwYW4sXG4gICAgICAgICAgX3R5cGU6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgICAgIF9rZXk6IGtleVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5fa2V5ID09PSB2b2lkIDAgJiYgKHBhdGgubGVuZ3RoID09PSAxIHx8IHBhdGgubGVuZ3RoID09PSAyKSkge1xuICAgICAgICBkZWJ1ZyRhKFwiU2V0dGluZyBtaXNzaW5nIGtleSBvbiBjaGlsZCBub2RlIHdpdGhvdXQgYSBrZXlcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIF9rZXk6IGtleVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub3JtYWxpemVOb2RlKGVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoVXRpbHMoe1xuICBlZGl0b3JBY3RvclxufSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2sgPSAob3B0aW9ucykgPT4gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICBfdHlwZTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgc3R5bGU6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuc3R5bGVzWzBdLm5hbWUgfHwgXCJub3JtYWxcIixcbiAgICAgIC4uLm9wdGlvbnMubGlzdEl0ZW0gPyB7XG4gICAgICAgIGxpc3RJdGVtOiBvcHRpb25zLmxpc3RJdGVtXG4gICAgICB9IDoge30sXG4gICAgICAuLi5vcHRpb25zLmxldmVsID8ge1xuICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgfSA6IHt9LFxuICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogb3B0aW9ucy5kZWNvcmF0b3JzLmZpbHRlcigoZGVjb3JhdG9yKSA9PiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuZmluZCgoe1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSkgPT4gbmFtZSA9PT0gZGVjb3JhdG9yKSlcbiAgICAgIH1dXG4gICAgfV0sIHtcbiAgICAgIHNjaGVtYVR5cGVzOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgfSlbMF0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IHdpdGhQbHVnaW5zID0gKGVkaXRvciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlID0gZWRpdG9yLCB7XG4gICAgZWRpdG9yQWN0b3JcbiAgfSA9IG9wdGlvbnMsIG9wZXJhdGlvblRvUGF0Y2hlcyA9IGNyZWF0ZU9wZXJhdGlvblRvUGF0Y2hlcyhlZGl0b3JBY3RvciksIHdpdGhPYmplY3RLZXlzID0gY3JlYXRlV2l0aE9iamVjdEtleXMoZWRpdG9yQWN0b3IpLCB3aXRoU2NoZW1hVHlwZXMgPSBjcmVhdGVXaXRoU2NoZW1hVHlwZXMoe1xuICAgIGVkaXRvckFjdG9yXG4gIH0pLCB3aXRoUGF0Y2hlcyA9IGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBwYXRjaEZ1bmN0aW9uczogb3BlcmF0aW9uVG9QYXRjaGVzLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aE1heEJsb2NrcyA9IGNyZWF0ZVdpdGhNYXhCbG9ja3MoZWRpdG9yQWN0b3IpLCB3aXRoVW5kb1JlZG8gPSBjcmVhdGVXaXRoVW5kb1JlZG8oe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwoZWRpdG9yQWN0b3IpLCB3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKGVkaXRvckFjdG9yKSwgd2l0aFBsYWNlaG9sZGVyQmxvY2sgPSBjcmVhdGVXaXRoUGxhY2Vob2xkZXJCbG9jayhlZGl0b3JBY3RvciksIHdpdGhVdGlscyA9IGNyZWF0ZVdpdGhVdGlscyh7XG4gICAgZWRpdG9yQWN0b3JcbiAgfSksIHdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZWRpdG9yQWN0b3IpO1xuICByZXR1cm4gY3JlYXRlV2l0aEV2ZW50TGlzdGVuZXJzKGVkaXRvckFjdG9yKSh3aXRoU2NoZW1hVHlwZXMod2l0aE9iamVjdEtleXMod2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCh3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSh3aXRoUGxhY2Vob2xkZXJCbG9jayh3aXRoVXRpbHMod2l0aE1heEJsb2Nrcyh3aXRoVW5kb1JlZG8od2l0aFBhdGNoZXMod2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZSkpKSkpKSkpKSkpO1xufSwgZGVidWckOSA9IGRlYnVnV2l0aE5hbWUoXCJzZXR1cFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVNsYXRlRWRpdG9yKGNvbmZpZykge1xuICBkZWJ1ZyQ5KFwiQ3JlYXRpbmcgbmV3IFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiKTtcbiAgY29uc3QgaW5zdGFuY2UgPSB3aXRoUGx1Z2lucyh3aXRoUmVhY3QoY3JlYXRlRWRpdG9yKCkpLCB7XG4gICAgZWRpdG9yQWN0b3I6IGNvbmZpZy5lZGl0b3JBY3RvcixcbiAgICBzdWJzY3JpcHRpb25zOiBjb25maWcuc3Vic2NyaXB0aW9uc1xuICB9KTtcbiAgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuc2V0KGluc3RhbmNlLCB7fSksIEtFWV9UT19TTEFURV9FTEVNRU5ULnNldChpbnN0YW5jZSwge30pO1xuICBjb25zdCBpbml0aWFsVmFsdWUgPSBbaW5zdGFuY2UucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICBkZWNvcmF0b3JzOiBbXVxuICB9KV07XG4gIHJldHVybiB7XG4gICAgaW5zdGFuY2UsXG4gICAgaW5pdGlhbFZhbHVlXG4gIH07XG59XG5jb25zdCBhZGRBbm5vdGF0aW9uT25Db2xsYXBzZWRTZWxlY3Rpb24gPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImFubm90YXRpb24uYWRkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBpZiAoIWlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBjYXJldFdvcmRTZWxlY3Rpb24gPSBnZXRDYXJldFdvcmRTZWxlY3Rpb24oc25hcHNob3QpO1xuICAgIHJldHVybiAhY2FyZXRXb3JkU2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkV4cGFuZGVkKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBjYXJldFdvcmRTZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSA/ICExIDoge1xuICAgICAgY2FyZXRXb3JkU2VsZWN0aW9uXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIGNhcmV0V29yZFNlbGVjdGlvblxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IGNhcmV0V29yZFNlbGVjdGlvblxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gIH0pXV1cbn0pLCBjb3JlQW5ub3RhdGlvbkJlaGF2aW9ycyA9IHtcbiAgYWRkQW5ub3RhdGlvbk9uQ29sbGFwc2VkU2VsZWN0aW9uXG59LCBJU19NQUMgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSwgbW9kaWZpZXJzID0ge1xuICBhbHQ6IFwiYWx0S2V5XCIsXG4gIGNvbnRyb2w6IFwiY3RybEtleVwiLFxuICBtZXRhOiBcIm1ldGFLZXlcIixcbiAgc2hpZnQ6IFwic2hpZnRLZXlcIlxufSwgYWxpYXNlcyA9IHtcbiAgYWRkOiBcIitcIixcbiAgYnJlYWs6IFwicGF1c2VcIixcbiAgY21kOiBcIm1ldGFcIixcbiAgY29tbWFuZDogXCJtZXRhXCIsXG4gIGN0bDogXCJjb250cm9sXCIsXG4gIGN0cmw6IFwiY29udHJvbFwiLFxuICBkZWw6IFwiZGVsZXRlXCIsXG4gIGRvd246IFwiYXJyb3dkb3duXCIsXG4gIGVzYzogXCJlc2NhcGVcIixcbiAgaW5zOiBcImluc2VydFwiLFxuICBsZWZ0OiBcImFycm93bGVmdFwiLFxuICBtb2Q6IElTX01BQyA/IFwibWV0YVwiIDogXCJjb250cm9sXCIsXG4gIG9wdDogXCJhbHRcIixcbiAgb3B0aW9uOiBcImFsdFwiLFxuICByZXR1cm46IFwiZW50ZXJcIixcbiAgcmlnaHQ6IFwiYXJyb3dyaWdodFwiLFxuICBzcGFjZTogXCIgXCIsXG4gIHNwYWNlYmFyOiBcIiBcIixcbiAgdXA6IFwiYXJyb3d1cFwiLFxuICB3aW46IFwibWV0YVwiLFxuICB3aW5kb3dzOiBcIm1ldGFcIlxufSwga2V5Q29kZXMgPSB7XG4gIGJhY2tzcGFjZTogOCxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNoaWZ0OiAxNixcbiAgY29udHJvbDogMTcsXG4gIGFsdDogMTgsXG4gIHBhdXNlOiAxOSxcbiAgY2Fwc2xvY2s6IDIwLFxuICBlc2NhcGU6IDI3LFxuICBcIiBcIjogMzIsXG4gIHBhZ2V1cDogMzMsXG4gIHBhZ2Vkb3duOiAzNCxcbiAgZW5kOiAzNSxcbiAgaG9tZTogMzYsXG4gIGFycm93bGVmdDogMzcsXG4gIGFycm93dXA6IDM4LFxuICBhcnJvd3JpZ2h0OiAzOSxcbiAgYXJyb3dkb3duOiA0MCxcbiAgaW5zZXJ0OiA0NSxcbiAgZGVsZXRlOiA0NixcbiAgbWV0YTogOTEsXG4gIG51bWxvY2s6IDE0NCxcbiAgc2Nyb2xsbG9jazogMTQ1LFxuICBcIjtcIjogMTg2LFxuICBcIj1cIjogMTg3LFxuICBcIixcIjogMTg4LFxuICBcIi1cIjogMTg5LFxuICBcIi5cIjogMTkwLFxuICBcIi9cIjogMTkxLFxuICBcImBcIjogMTkyLFxuICBcIltcIjogMjE5LFxuICBcIlxcXFxcIjogMjIwLFxuICBcIl1cIjogMjIxLFxuICBcIidcIjogMjIyLFxuICBmMTogMTEyLFxuICBmMjogMTEzLFxuICBmMzogMTE0LFxuICBmNDogMTE1LFxuICBmNTogMTE2LFxuICBmNjogMTE3LFxuICBmNzogMTE4LFxuICBmODogMTE5LFxuICBmOTogMTIwLFxuICBmMTA6IDEyMSxcbiAgZjExOiAxMjIsXG4gIGYxMjogMTIzLFxuICBmMTM6IDEyNCxcbiAgZjE0OiAxMjUsXG4gIGYxNTogMTI2LFxuICBmMTY6IDEyNyxcbiAgZjE3OiAxMjgsXG4gIGYxODogMTI5LFxuICBmMTk6IDEzMCxcbiAgZjIwOiAxMzFcbn07XG5mdW5jdGlvbiBpc0hvdGtleShob3RrZXksIGV2ZW50KSB7XG4gIHJldHVybiBjb21wYXJlSG90a2V5KHBhcnNlSG90a2V5KGhvdGtleSksIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSG90a2V5KGhvdGtleSkge1xuICBjb25zdCBwYXJzZWRIb3RrZXkgPSB7XG4gICAgYWx0S2V5OiAhMSxcbiAgICBjdHJsS2V5OiAhMSxcbiAgICBtZXRhS2V5OiAhMSxcbiAgICBzaGlmdEtleTogITFcbiAgfSwgaG90a2V5U2VnbWVudHMgPSBob3RrZXkucmVwbGFjZShcIisrXCIsIFwiK2FkZFwiKS5zcGxpdChcIitcIik7XG4gIGZvciAoY29uc3QgcmF3SG90a2V5U2VnbWVudCBvZiBob3RrZXlTZWdtZW50cykge1xuICAgIGNvbnN0IG9wdGlvbmFsID0gcmF3SG90a2V5U2VnbWVudC5lbmRzV2l0aChcIj9cIikgJiYgcmF3SG90a2V5U2VnbWVudC5sZW5ndGggPiAxLCBob3RrZXlTZWdtZW50ID0gb3B0aW9uYWwgPyByYXdIb3RrZXlTZWdtZW50LnNsaWNlKDAsIC0xKSA6IHJhd0hvdGtleVNlZ21lbnQsIGtleU5hbWUgPSB0b0tleU5hbWUoaG90a2V5U2VnbWVudCksIG1vZGlmaWVyID0gbW9kaWZpZXJzW2tleU5hbWVdLCBhbGlhcyA9IGFsaWFzZXNbaG90a2V5U2VnbWVudF0sIGNvZGUgPSBrZXlDb2Rlc1trZXlOYW1lXTtcbiAgICBpZiAoaG90a2V5U2VnbWVudC5sZW5ndGggPiAxICYmIG1vZGlmaWVyID09PSB2b2lkIDAgJiYgYWxpYXMgPT09IHZvaWQgMCAmJiBjb2RlID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIG1vZGlmaWVyOiBcIiR7aG90a2V5U2VnbWVudH1cImApO1xuICAgIChob3RrZXlTZWdtZW50cy5sZW5ndGggPT09IDEgfHwgbW9kaWZpZXIgPT09IHZvaWQgMCkgJiYgKHBhcnNlZEhvdGtleS5rZXkgPSBrZXlOYW1lLCBwYXJzZWRIb3RrZXkua2V5Q29kZSA9IHRvS2V5Q29kZShob3RrZXlTZWdtZW50KSksIG1vZGlmaWVyICE9PSB2b2lkIDAgJiYgKHBhcnNlZEhvdGtleVttb2RpZmllcl0gPSBvcHRpb25hbCA/IG51bGwgOiAhMCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZEhvdGtleTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVIb3RrZXkocGFyc2VkSG90a2V5LCBldmVudCkge1xuICByZXR1cm4gKHBhcnNlZEhvdGtleS5hbHRLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuYWx0S2V5ID09PSBldmVudC5hbHRLZXkpICYmIChwYXJzZWRIb3RrZXkuY3RybEtleSA9PSBudWxsIHx8IHBhcnNlZEhvdGtleS5jdHJsS2V5ID09PSBldmVudC5jdHJsS2V5KSAmJiAocGFyc2VkSG90a2V5Lm1ldGFLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkubWV0YUtleSA9PT0gZXZlbnQubWV0YUtleSkgJiYgKHBhcnNlZEhvdGtleS5zaGlmdEtleSA9PSBudWxsIHx8IHBhcnNlZEhvdGtleS5zaGlmdEtleSA9PT0gZXZlbnQuc2hpZnRLZXkpID8gcGFyc2VkSG90a2V5LmtleUNvZGUgIT09IHZvaWQgMCAmJiBldmVudC5rZXlDb2RlICE9PSB2b2lkIDAgPyBwYXJzZWRIb3RrZXkua2V5Q29kZSA9PT0gOTEgJiYgZXZlbnQua2V5Q29kZSA9PT0gOTMgPyAhMCA6IHBhcnNlZEhvdGtleS5rZXlDb2RlID09PSBldmVudC5rZXlDb2RlIDogcGFyc2VkSG90a2V5LmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgfHwgcGFyc2VkSG90a2V5LmtleSA9PT0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHRvS2V5Q29kZShuYW1lKSB7XG4gIGNvbnN0IGtleU5hbWUgPSB0b0tleU5hbWUobmFtZSk7XG4gIHJldHVybiBrZXlDb2Rlc1trZXlOYW1lXSA/PyBrZXlOYW1lLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbn1cbmZ1bmN0aW9uIHRvS2V5TmFtZShuYW1lKSB7XG4gIGNvbnN0IGtleU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBhbGlhc2VzW2tleU5hbWVdID8/IGtleU5hbWU7XG59XG5jb25zdCBhcnJvd0Rvd25PbkxvbmVseUJsb2NrT2JqZWN0ID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIWlzSG90a2V5KFwiQXJyb3dEb3duXCIsIGV2ZW50Lm9yaWdpbkV2ZW50KSB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KSwgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gZm9jdXNCbG9ja09iamVjdCAmJiAhbmV4dEJsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9KV1dXG59KSwgYXJyb3dVcE9uTG9uZWx5QmxvY2tPYmplY3QgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmICghaXNIb3RrZXkoXCJBcnJvd1VwXCIsIGV2ZW50Lm9yaWdpbkV2ZW50KSB8fCAhaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHNuYXBzaG90KSwgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFwcmV2aW91c0Jsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCJcbiAgfSldXVxufSksIGJyZWFraW5nQmxvY2tPYmplY3QgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNCbG9ja09iamVjdCA9IGdldEZvY3VzQmxvY2tPYmplY3Qoc25hcHNob3QpO1xuICAgIHJldHVybiBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCkgJiYgZm9jdXNCbG9ja09iamVjdCAhPT0gdm9pZCAwO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9KV1dXG59KSwgY2xpY2tpbmdBYm92ZUxvbmVseUJsb2NrT2JqZWN0ID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJtb3VzZS5jbGlja1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKHNuYXBzaG90LmNvbnRleHQucmVhZE9ubHkgfHwgc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gJiYgIWlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmb2N1c0Jsb2NrT2JqZWN0ID0gZ2V0Rm9jdXNCbG9ja09iamVjdCh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjogZXZlbnQucG9zaXRpb24uc2VsZWN0aW9uXG4gICAgICB9XG4gICAgfSksIHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiBldmVudC5wb3NpdGlvbi5zZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucG9zaXRpb24uaXNFZGl0b3IgJiYgZXZlbnQucG9zaXRpb24uYmxvY2sgPT09IFwic3RhcnRcIiAmJiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFwcmV2aW91c0Jsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvblxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCIsXG4gICAgc2VsZWN0OiBcInN0YXJ0XCJcbiAgfSldXVxufSksIGNsaWNraW5nQmVsb3dMb25lbHlCbG9ja09iamVjdCA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwibW91c2UuY2xpY2tcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmIChzbmFwc2hvdC5jb250ZXh0LnJlYWRPbmx5IHx8IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uICYmICFpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZm9jdXNCbG9ja09iamVjdCA9IGdldEZvY3VzQmxvY2tPYmplY3Qoe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pLCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5wb3NpdGlvbi5pc0VkaXRvciAmJiBldmVudC5wb3NpdGlvbi5ibG9jayA9PT0gXCJlbmRcIiAmJiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFuZXh0QmxvY2s7XG4gIH0sXG4gIGFjdGlvbnM6IFsoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBhdDogZXZlbnQucG9zaXRpb24uc2VsZWN0aW9uXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazoge1xuICAgICAgX3R5cGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWVcbiAgICB9LFxuICAgIHBsYWNlbWVudDogXCJhZnRlclwiLFxuICAgIHNlbGVjdDogXCJzdGFydFwiXG4gIH0pXV1cbn0pLCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFwcmV2aW91c0Jsb2NrID8gITEgOiBpc0VtcHR5VGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGZvY3VzVGV4dEJsb2NrLm5vZGUpICYmICFpc1RleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBwcmV2aW91c0Jsb2NrLm5vZGUpID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBwcmV2aW91c0Jsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBwcmV2aW91c0Jsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBwcmV2aW91c0Jsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IHByZXZpb3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfVxuICB9KV1dXG59KSwgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0ID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWxldGUuZm9yd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIW5leHRCbG9jayA/ICExIDogaXNFbXB0eVRleHRCbG9jayhzbmFwc2hvdC5jb250ZXh0LCBmb2N1c1RleHRCbG9jay5ub2RlKSAmJiAhaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgbmV4dEJsb2NrLm5vZGUpID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBuZXh0QmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIG5leHRCbG9ja1xuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSksIHJhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIGF0OiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogbmV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IG5leHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH0pXV1cbn0pLCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMgPSB7XG4gIGFycm93RG93bk9uTG9uZWx5QmxvY2tPYmplY3QsXG4gIGFycm93VXBPbkxvbmVseUJsb2NrT2JqZWN0LFxuICBicmVha2luZ0Jsb2NrT2JqZWN0LFxuICBjbGlja2luZ0Fib3ZlTG9uZWx5QmxvY2tPYmplY3QsXG4gIGNsaWNraW5nQmVsb3dMb25lbHlCbG9ja09iamVjdCxcbiAgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0FmdGVyQmxvY2tPYmplY3QsXG4gIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tCZWZvcmVCbG9ja09iamVjdFxufSwgY29yZURlY29yYXRvckJlaGF2aW9ycyA9IHtcbiAgc3Ryb25nU2hvcnRjdXQ6IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gaXNIb3RrZXkoXCJtb2QrYlwiLCBldmVudC5vcmlnaW5FdmVudCkgJiYgc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lID09PSBcInN0cm9uZ1wiKSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgZGVjb3JhdG9yOiBcInN0cm9uZ1wiXG4gICAgfSldXVxuICB9KSxcbiAgZW1TaG9ydGN1dDogZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBpc0hvdGtleShcIm1vZCtpXCIsIGV2ZW50Lm9yaWdpbkV2ZW50KSAmJiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUgPT09IFwiZW1cIiksXG4gICAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgIGRlY29yYXRvcjogXCJlbVwiXG4gICAgfSldXVxuICB9KSxcbiAgdW5kZXJsaW5lU2hvcnRjdXQ6IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gaXNIb3RrZXkoXCJtb2QrdVwiLCBldmVudC5vcmlnaW5FdmVudCkgJiYgc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lID09PSBcInVuZGVybGluZVwiKSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgZGVjb3JhdG9yOiBcInVuZGVybGluZVwiXG4gICAgfSldXVxuICB9KSxcbiAgY29kZVNob3J0Y3V0OiBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IGlzSG90a2V5KFwibW9kKydcIiwgZXZlbnQub3JpZ2luRXZlbnQpICYmIHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSA9PT0gXCJjb2RlXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwiY29kZVwiXG4gICAgfSldXVxuICB9KVxufSwgY29yZURuZEJlaGF2aW9ycyA9IFtcbiAgLyoqXG4gICAqIFdoZW4gZHJhZ2dpbmcgb3ZlciB0aGUgZHJhZyBvcmlnaW4sIHdlIGRvbid0IHdhbnQgdG8gc2hvdyB0aGUgY2FyZXQgaW4gdGhlXG4gICAqIHRleHQuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZHJhZy5kcmFnb3ZlclwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRyYWdPcmlnaW4gPSBzbmFwc2hvdC5iZXRhLmludGVybmFsRHJhZz8ub3JpZ2luO1xuICAgICAgcmV0dXJuIGRyYWdPcmlnaW4gPyBpc092ZXJsYXBwaW5nU2VsZWN0aW9uKGV2ZW50LnBvc2l0aW9uLnNlbGVjdGlvbikoe1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogW11cbiAgfSlcbl0sIGJyZWFraW5nQXRUaGVFbmRPZlRleHRCbG9jayA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpO1xuICAgIGlmICghc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24gfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYXRUaGVFbmRPZkJsb2NrID0gaXNBdFRoZUVuZE9mQmxvY2soZm9jdXNUZXh0QmxvY2spKHNuYXBzaG90KSwgZm9jdXNMaXN0SXRlbSA9IGZvY3VzVGV4dEJsb2NrLm5vZGUubGlzdEl0ZW0sIGZvY3VzTGV2ZWwgPSBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsO1xuICAgIHJldHVybiBhdFRoZUVuZE9mQmxvY2sgPyB7XG4gICAgICBmb2N1c0xpc3RJdGVtLFxuICAgICAgZm9jdXNMZXZlbFxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSwge1xuICAgIGZvY3VzTGlzdEl0ZW0sXG4gICAgZm9jdXNMZXZlbFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUsXG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIG1hcmtzOiBbXVxuICAgICAgfV0sXG4gICAgICBtYXJrRGVmczogW10sXG4gICAgICBsaXN0SXRlbTogZm9jdXNMaXN0SXRlbSxcbiAgICAgIGxldmVsOiBmb2N1c0xldmVsLFxuICAgICAgc3R5bGU6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLnN0eWxlc1swXT8ubmFtZVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgfSldXVxufSksIGJyZWFraW5nQXRUaGVTdGFydE9mVGV4dEJsb2NrID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCk7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpLCBmb2N1c0RlY29yYXRvcnMgPSBmb2N1c1NwYW4/Lm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gc25hcHNob3QuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lID09PSBtYXJrKSA/PyBbXSksIGZvY3VzQW5ub3RhdGlvbnMgPSBmb2N1c1NwYW4/Lm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIXNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IubmFtZSA9PT0gbWFyaykpID8/IFtdLCBmb2N1c0xpc3RJdGVtID0gZm9jdXNUZXh0QmxvY2subm9kZS5saXN0SXRlbSwgZm9jdXNMZXZlbCA9IGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWw7XG4gICAgcmV0dXJuIGlzQXRUaGVTdGFydE9mQmxvY2soZm9jdXNUZXh0QmxvY2spKHNuYXBzaG90KSA/IHtcbiAgICAgIGZvY3VzQW5ub3RhdGlvbnMsXG4gICAgICBmb2N1c0RlY29yYXRvcnMsXG4gICAgICBmb2N1c0xpc3RJdGVtLFxuICAgICAgZm9jdXNMZXZlbFxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgc25hcHNob3RcbiAgfSwge1xuICAgIGZvY3VzQW5ub3RhdGlvbnMsXG4gICAgZm9jdXNEZWNvcmF0b3JzLFxuICAgIGZvY3VzTGlzdEl0ZW0sXG4gICAgZm9jdXNMZXZlbFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2s6IHtcbiAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIF90eXBlOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5zcGFuLm5hbWUsXG4gICAgICAgIG1hcmtzOiBmb2N1c0Fubm90YXRpb25zLmxlbmd0aCA9PT0gMCA/IGZvY3VzRGVjb3JhdG9ycyA6IFtdLFxuICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICB9XSxcbiAgICAgIGxpc3RJdGVtOiBmb2N1c0xpc3RJdGVtLFxuICAgICAgbGV2ZWw6IGZvY3VzTGV2ZWwsXG4gICAgICBzdHlsZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3R5bGVzWzBdPy5uYW1lXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCIsXG4gICAgc2VsZWN0OiBcIm5vbmVcIlxuICB9KV1dXG59KSwgYnJlYWtpbmdFbnRpcmVEb2N1bWVudCA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkV4cGFuZGVkKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBmaXJzdEJsb2NrID0gZ2V0Rmlyc3RCbG9jayQxKHNuYXBzaG90KSwgbGFzdEJsb2NrID0gZ2V0TGFzdEJsb2NrJDEoc25hcHNob3QpO1xuICAgIGlmICghZmlyc3RCbG9jayB8fCAhbGFzdEJsb2NrKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZpcnN0QmxvY2tTdGFydFBvaW50ID0gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogZmlyc3RCbG9ja1xuICAgIH0pLCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiksIGxhc3RCbG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IGxhc3RCbG9ja1xuICAgIH0pLCBzZWxlY3Rpb25FbmRQb2ludCA9IGdldFNlbGVjdGlvbkVuZFBvaW50KHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uKTtcbiAgICByZXR1cm4gaXNFcXVhbFNlbGVjdGlvblBvaW50cyhmaXJzdEJsb2NrU3RhcnRQb2ludCwgc2VsZWN0aW9uU3RhcnRQb2ludCkgJiYgaXNFcXVhbFNlbGVjdGlvblBvaW50cyhsYXN0QmxvY2tFbmRQb2ludCwgc2VsZWN0aW9uRW5kUG9pbnQpID8ge1xuICAgICAgc2VsZWN0aW9uOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvblxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0aW9uXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGVcIixcbiAgICBhdDogc2VsZWN0aW9uXG4gIH0pXV1cbn0pLCBicmVha2luZ0VudGlyZUJsb2NrcyA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+IHtcbiAgICBpZiAoIXNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uIHx8ICFpc1NlbGVjdGlvbkV4cGFuZGVkKHNuYXBzaG90KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRCbG9jayA9IGdldFNlbGVjdGlvblN0YXJ0QmxvY2skMShzbmFwc2hvdCksIHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2skMShzbmFwc2hvdCk7XG4gICAgaWYgKCFzZWxlY3Rpb25TdGFydEJsb2NrIHx8ICFzZWxlY3Rpb25FbmRCbG9jaylcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzdGFydEJsb2NrU3RhcnRQb2ludCA9IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IHNlbGVjdGlvblN0YXJ0QmxvY2tcbiAgICB9KSwgc2VsZWN0aW9uU3RhcnRQb2ludCA9IGdldFNlbGVjdGlvblN0YXJ0UG9pbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLCBlbmRCbG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgYmxvY2s6IHNlbGVjdGlvbkVuZEJsb2NrXG4gICAgfSksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pO1xuICAgIHJldHVybiBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHNlbGVjdGlvblN0YXJ0UG9pbnQsIHN0YXJ0QmxvY2tTdGFydFBvaW50KSAmJiBpc0VxdWFsU2VsZWN0aW9uUG9pbnRzKHNlbGVjdGlvbkVuZFBvaW50LCBlbmRCbG9ja0VuZFBvaW50KSA/IHtcbiAgICAgIHNlbGVjdGVkQmxvY2tzXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdFxuICB9LCB7XG4gICAgc2VsZWN0ZWRCbG9ja3NcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrOiB7XG4gICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuc3Bhbi5uYW1lLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1dXG4gICAgfSxcbiAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCIsXG4gICAgc2VsZWN0OiBcInN0YXJ0XCJcbiAgfSksIC4uLnNlbGVjdGVkQmxvY2tzLm1hcCgoYmxvY2spID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGF0OiBibG9jay5wYXRoXG4gIH0pKV1dXG59KSwgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzID0ge1xuICBicmVha2luZ0F0VGhlRW5kT2ZUZXh0QmxvY2ssXG4gIGJyZWFraW5nQXRUaGVTdGFydE9mVGV4dEJsb2NrLFxuICBicmVha2luZ0VudGlyZURvY3VtZW50LFxuICBicmVha2luZ0VudGlyZUJsb2Nrc1xufSwgTUFYX0xJU1RfTEVWRUwgPSAxMCwgY2xlYXJMaXN0T25CYWNrc3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbiA/ICExIDogZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCA9PT0gMSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9ja1xuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICBwcm9wczogW1wibGlzdEl0ZW1cIiwgXCJsZXZlbFwiXSxcbiAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICB9KV1dXG59KSwgdW5pbmRlbnRMaXN0T25CYWNrc3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbiA/ICExIDogZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCAhPT0gdm9pZCAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgPiAxID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBsZXZlbDogZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCAtIDFcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgIGxldmVsXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWxcbiAgICB9LFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCBjbGVhckxpc3RPbkVudGVyID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNMaXN0QmxvY2sgPSBnZXRGb2N1c0xpc3RCbG9jayhzbmFwc2hvdCk7XG4gICAgcmV0dXJuICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzTGlzdEJsb2NrIHx8ICFpc0VtcHR5VGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGZvY3VzTGlzdEJsb2NrLm5vZGUpID8gITEgOiB7XG4gICAgICBmb2N1c0xpc3RCbG9ja1xuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzTGlzdEJsb2NrXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay51bnNldFwiLFxuICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgIGF0OiBmb2N1c0xpc3RCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCBpbmRlbnRMaXN0T25UYWIgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmICghaXNIb3RrZXkoXCJUYWJcIiwgZXZlbnQub3JpZ2luRXZlbnQpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moc25hcHNob3QpLCBzZWxlY3RlZExpc3RCbG9ja3MgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gaXNMaXN0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2subm9kZSkgPyBbe1xuICAgICAgbm9kZTogYmxvY2subm9kZSxcbiAgICAgIHBhdGg6IGJsb2NrLnBhdGhcbiAgICB9XSA6IFtdKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRMaXN0QmxvY2tzLmxlbmd0aCA9PT0gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID8ge1xuICAgICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3RlZExpc3RCbG9ja3NcbiAgfSkgPT4gc2VsZWN0ZWRMaXN0QmxvY2tzLm1hcCgoc2VsZWN0ZWRMaXN0QmxvY2spID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImJsb2NrLnNldFwiLFxuICAgIHByb3BzOiB7XG4gICAgICBsZXZlbDogTWF0aC5taW4oTUFYX0xJU1RfTEVWRUwsIE1hdGgubWF4KDEsIHNlbGVjdGVkTGlzdEJsb2NrLm5vZGUubGV2ZWwgKyAxKSlcbiAgICB9LFxuICAgIGF0OiBzZWxlY3RlZExpc3RCbG9jay5wYXRoXG4gIH0pKV1cbn0pLCB1bmluZGVudExpc3RPblNoaWZ0VGFiID0gZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJrZXlib2FyZC5rZXlkb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIWlzSG90a2V5KFwiU2hpZnQrVGFiXCIsIGV2ZW50Lm9yaWdpbkV2ZW50KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHNuYXBzaG90KSwgc2VsZWN0ZWRMaXN0QmxvY2tzID0gc2VsZWN0ZWRCbG9ja3MuZmxhdE1hcCgoYmxvY2spID0+IGlzTGlzdEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIGJsb2NrLm5vZGUpID8gW3tcbiAgICAgIG5vZGU6IGJsb2NrLm5vZGUsXG4gICAgICBwYXRoOiBibG9jay5wYXRoXG4gICAgfV0gOiBbXSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdEJsb2Nrcy5sZW5ndGggPT09IHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA/IHtcbiAgICAgIHNlbGVjdGVkTGlzdEJsb2Nrc1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkTGlzdEJsb2Nrcy5tYXAoKHNlbGVjdGVkTGlzdEJsb2NrKSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWw6IE1hdGgubWluKE1BWF9MSVNUX0xFVkVMLCBNYXRoLm1heCgxLCBzZWxlY3RlZExpc3RCbG9jay5ub2RlLmxldmVsIC0gMSkpXG4gICAgfSxcbiAgICBhdDogc2VsZWN0ZWRMaXN0QmxvY2sucGF0aFxuICB9KSldXG59KSwgY29yZUxpc3RCZWhhdmlvcnMgPSB7XG4gIGNsZWFyTGlzdE9uQmFja3NwYWNlLFxuICB1bmluZGVudExpc3RPbkJhY2tzcGFjZSxcbiAgY2xlYXJMaXN0T25FbnRlcixcbiAgaW5kZW50TGlzdE9uVGFiLFxuICB1bmluZGVudExpc3RPblNoaWZ0VGFiXG59LCBjb3JlQmVoYXZpb3JzQ29uZmlnID0gW2NvcmVBbm5vdGF0aW9uQmVoYXZpb3JzLmFkZEFubm90YXRpb25PbkNvbGxhcHNlZFNlbGVjdGlvbiwgY29yZURlY29yYXRvckJlaGF2aW9ycy5zdHJvbmdTaG9ydGN1dCwgY29yZURlY29yYXRvckJlaGF2aW9ycy5lbVNob3J0Y3V0LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLnVuZGVybGluZVNob3J0Y3V0LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLmNvZGVTaG9ydGN1dCwgLi4uY29yZURuZEJlaGF2aW9ycywgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmNsaWNraW5nQWJvdmVMb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmNsaWNraW5nQmVsb3dMb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmFycm93RG93bk9uTG9uZWx5QmxvY2tPYmplY3QsIGNvcmVCbG9ja09iamVjdEJlaGF2aW9ycy5hcnJvd1VwT25Mb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmJyZWFraW5nQmxvY2tPYmplY3QsIGNvcmVCbG9ja09iamVjdEJlaGF2aW9ycy5kZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmRlbGV0aW5nRW1wdHlUZXh0QmxvY2tCZWZvcmVCbG9ja09iamVjdCwgY29yZUxpc3RCZWhhdmlvcnMuY2xlYXJMaXN0T25CYWNrc3BhY2UsIGNvcmVMaXN0QmVoYXZpb3JzLnVuaW5kZW50TGlzdE9uQmFja3NwYWNlLCBjb3JlTGlzdEJlaGF2aW9ycy5jbGVhckxpc3RPbkVudGVyLCBjb3JlTGlzdEJlaGF2aW9ycy5pbmRlbnRMaXN0T25UYWIsIGNvcmVMaXN0QmVoYXZpb3JzLnVuaW5kZW50TGlzdE9uU2hpZnRUYWIsIGNvcmVJbnNlcnRCcmVha0JlaGF2aW9ycy5icmVha2luZ0F0VGhlRW5kT2ZUZXh0QmxvY2ssIGNvcmVJbnNlcnRCcmVha0JlaGF2aW9ycy5icmVha2luZ0F0VGhlU3RhcnRPZlRleHRCbG9jaywgY29yZUluc2VydEJyZWFrQmVoYXZpb3JzLmJyZWFraW5nRW50aXJlRG9jdW1lbnQsIGNvcmVJbnNlcnRCcmVha0JlaGF2aW9ycy5icmVha2luZ0VudGlyZUJsb2Nrc10ubWFwKChiZWhhdmlvcikgPT4gKHtcbiAgYmVoYXZpb3IsXG4gIHByaW9yaXR5OiBjb3JlUHJpb3JpdHlcbn0pKSwgYWJzdHJhY3RBbm5vdGF0aW9uQmVoYXZpb3JzID0gW2RlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiYW5ub3RhdGlvbi50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gaXNBY3RpdmVBbm5vdGF0aW9uKGV2ZW50LmFubm90YXRpb24ubmFtZSkoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5yZW1vdmVcIixcbiAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImFubm90YXRpb24udG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+ICFpc0FjdGl2ZUFubm90YXRpb24oZXZlbnQuYW5ub3RhdGlvbi5uYW1lKShzbmFwc2hvdCksXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICAgIGFubm90YXRpb246IGV2ZW50LmFubm90YXRpb25cbiAgfSldXVxufSldLCBhYnN0cmFjdERlY29yYXRvckJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4gaXNBY3RpdmVEZWNvcmF0b3IoZXZlbnQuZGVjb3JhdG9yKShzbmFwc2hvdCksXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWNvcmF0b3IucmVtb3ZlXCIsXG4gICAgZGVjb3JhdG9yOiBldmVudC5kZWNvcmF0b3JcbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgbWFudWFsU2VsZWN0aW9uID0gZXZlbnQuYXQgPyBibG9ja09mZnNldHNUb1NlbGVjdGlvbih7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgb2Zmc2V0czogZXZlbnQuYXRcbiAgICB9KSA6IG51bGw7XG4gICAgcmV0dXJuIG1hbnVhbFNlbGVjdGlvbiA/ICFpc0FjdGl2ZURlY29yYXRvcihldmVudC5kZWNvcmF0b3IpKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IG1hbnVhbFNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pIDogIWlzQWN0aXZlRGVjb3JhdG9yKGV2ZW50LmRlY29yYXRvcikoc25hcHNob3QpO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIC4uLmV2ZW50LFxuICAgIHR5cGU6IFwiZGVjb3JhdG9yLmFkZFwiXG4gIH0pXV1cbn0pXSwgYWJzdHJhY3REZWxldGVCZWhhdmlvcnMgPSBbZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJkZWxldGUudGV4dFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gYmxvY2tPZmZzZXRzVG9TZWxlY3Rpb24oe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIG9mZnNldHM6IGV2ZW50LmF0XG4gICAgfSk7XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgdHJpbW1lZFNlbGVjdGlvbiA9IGdldFRyaW1tZWRTZWxlY3Rpb24oe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBjb252ZXJ0ZXJzOiBbXSxcbiAgICAgICAgc2NoZW1hOiBzbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAga2V5R2VuZXJhdG9yOiBzbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgYWN0aXZlRGVjb3JhdG9yczogW10sXG4gICAgICAgIHJlYWRPbmx5OiAhMSxcbiAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cmltbWVkU2VsZWN0aW9uID8ge1xuICAgICAgc2VsZWN0aW9uOiB0cmltbWVkU2VsZWN0aW9uXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3Rpb25cbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSldXVxufSldLCBhYnN0cmFjdEluc2VydEJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgZ3VhcmQ6ICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQucGxhY2VtZW50ID09PSBcImJlZm9yZVwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBldmVudC5ibG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrLFxuICAgIHBsYWNlbWVudDogaW5kZXggPT09IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLFxuICAgIHNlbGVjdDogXCJlbmRcIlxuICB9KSldXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuYmxvY2tzXCIsXG4gIGd1YXJkOiAoe1xuICAgIGV2ZW50XG4gIH0pID0+IGV2ZW50LnBsYWNlbWVudCA9PT0gXCJhZnRlclwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBldmVudC5ibG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2ssXG4gICAgcGxhY2VtZW50OiBcImFmdGVyXCIsXG4gICAgc2VsZWN0OiBcImVuZFwiXG4gIH0pKV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGlmIChldmVudC5wbGFjZW1lbnQgIT09IFwiYXV0b1wiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpO1xuICAgIHJldHVybiBmb2N1c1RleHRCbG9jayA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9LCB7XG4gICAgZm9jdXNUZXh0QmxvY2tcbiAgfSkgPT4gZXZlbnQuYmxvY2tzLmxlbmd0aCA9PT0gMSA/IFtyYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazogZXZlbnQuYmxvY2tzWzBdLFxuICAgIHBsYWNlbWVudDogXCJhdXRvXCIsXG4gICAgc2VsZWN0OiBcImVuZFwiXG4gIH0pXSA6IGlzRW1wdHlUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNUZXh0QmxvY2subm9kZSkgPyBldmVudC5ibG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrLFxuICAgIHBsYWNlbWVudDogaW5kZXggPT09IDAgPyBcImF1dG9cIiA6IFwiYWZ0ZXJcIixcbiAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgfSkpIDogZXZlbnQuYmxvY2tzLmZsYXRNYXAoKGJsb2NrLCBpbmRleCkgPT4gaW5kZXggPT09IDAgPyBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic3BsaXRcIlxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0LnByZXZpb3VzIGJsb2NrXCIsXG4gICAgc2VsZWN0OiBcImVuZFwiXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgIHNlbGVjdDogXCJlbmRcIlxuICB9KV0gOiBpbmRleCA9PT0gZXZlbnQuYmxvY2tzLmxlbmd0aCAtIDEgPyBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0Lm5leHQgYmxvY2tcIixcbiAgICBzZWxlY3Q6IFwic3RhcnRcIlxuICB9KSwgcmFpc2Uoe1xuICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgYmxvY2ssXG4gICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgfSldIDogW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrLFxuICAgIHBsYWNlbWVudDogXCJhZnRlclwiLFxuICAgIHNlbGVjdDogXCJlbmRcIlxuICB9KV0pXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJsb2Nrc1wiLFxuICBndWFyZDogKHtcbiAgICBldmVudFxuICB9KSA9PiBldmVudC5wbGFjZW1lbnQgPT09IFwiYXV0b1wiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBldmVudC5ibG9ja3MubWFwKChibG9jaywgaW5kZXgpID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGJsb2NrLFxuICAgIHBsYWNlbWVudDogaW5kZXggPT09IDAgPyBcImF1dG9cIiA6IFwiYWZ0ZXJcIixcbiAgICBzZWxlY3Q6IFwiZW5kXCJcbiAgfSkpXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic3BsaXRcIlxuICB9KV1dXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJpbnNlcnQuc29mdCBicmVha1wiLFxuICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgdGV4dDogYFxuYFxuICB9KV1dXG59KV0sIGtleUlzID0ge1xuICBsaW5lQnJlYWs6IChldmVudCkgPT4gZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgZXZlbnQuc2hpZnRLZXlcbn0sIGFic3RyYWN0S2V5Ym9hcmRCZWhhdmlvcnMgPSBbXG4gIC8qKlxuICAgKiBPbiBXZWJLaXQsIFNoaWZ0K0VudGVyIHJlc3VsdHMgaW4gYW4gYGluc2VydFBhcmFncmFwaGAgaW5wdXQgZXZlbnQgcmF0aGVyXG4gICAqIHRoYW4gYW4gYGluc2VydExpbmVCcmVha2AgaW5wdXQgZXZlbnQuIFRoaXMgQmVoYXZpb3IgbWFrZXMgc3VyZSB3ZSBjYXRjaFxuICAgKiB0aGF0IGBrZXlib2FyZC5rZXlkb3duYCBldmVudCBiZWZvcmVoYW5kIGFuZCByYWlzZSBhbiBgaW5zZXJ0LnNvZnQgYnJlYWtgIG1hbnVhbGx5LlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleWJvYXJkLmtleWRvd25cIixcbiAgICBndWFyZDogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ga2V5SXMubGluZUJyZWFrKGV2ZW50Lm9yaWdpbkV2ZW50KSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnNvZnQgYnJlYWtcIlxuICAgIH0pXV1cbiAgfSlcbl0sIGFic3RyYWN0TGlzdEl0ZW1CZWhhdmlvcnMgPSBbZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJsaXN0IGl0ZW0uYWRkXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+ICh7XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzOiBnZXRTZWxlY3RlZFRleHRCbG9ja3Moc25hcHNob3QpXG4gIH0pLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkVGV4dEJsb2Nrcy5tYXAoKGJsb2NrKSA9PiByYWlzZSh7XG4gICAgdHlwZTogXCJibG9jay5zZXRcIixcbiAgICBhdDogYmxvY2sucGF0aCxcbiAgICBwcm9wczoge1xuICAgICAgbGV2ZWw6IDEsXG4gICAgICBsaXN0SXRlbTogZXZlbnQubGlzdEl0ZW1cbiAgICB9XG4gIH0pKV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImxpc3QgaXRlbS5yZW1vdmVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3RcbiAgfSkgPT4gKHtcbiAgICBzZWxlY3RlZFRleHRCbG9ja3M6IGdldFNlbGVjdGVkVGV4dEJsb2NrcyhzbmFwc2hvdClcbiAgfSksXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHNlbGVjdGVkVGV4dEJsb2Nrc1xuICB9KSA9PiBzZWxlY3RlZFRleHRCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2sudW5zZXRcIixcbiAgICBhdDogYmxvY2sucGF0aCxcbiAgICBwcm9wczogW1wibGV2ZWxcIiwgXCJsaXN0SXRlbVwiXVxuICB9KSldXG59KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJsaXN0IGl0ZW0udG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IGlzQWN0aXZlTGlzdEl0ZW0oZXZlbnQubGlzdEl0ZW0pKHNuYXBzaG90KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcImxpc3QgaXRlbS5yZW1vdmVcIixcbiAgICBsaXN0SXRlbTogZXZlbnQubGlzdEl0ZW1cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwibGlzdCBpdGVtLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiAhaXNBY3RpdmVMaXN0SXRlbShldmVudC5saXN0SXRlbSkoc25hcHNob3QpLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwibGlzdCBpdGVtLmFkZFwiLFxuICAgIGxpc3RJdGVtOiBldmVudC5saXN0SXRlbVxuICB9KV1dXG59KV0sIGFic3RyYWN0TW92ZUJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcIm1vdmUuYmxvY2sgdXBcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IGV2ZW50LmF0LFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzQmxvY2sgPyB7XG4gICAgICBwcmV2aW91c0Jsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9LCB7XG4gICAgcHJldmlvdXNCbG9ja1xuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwibW92ZS5ibG9ja1wiLFxuICAgIGF0OiBldmVudC5hdCxcbiAgICB0bzogcHJldmlvdXNCbG9jay5wYXRoXG4gIH0pXV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcIm1vdmUuYmxvY2sgZG93blwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICBwYXRoOiBldmVudC5hdCxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IGV2ZW50LmF0LFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHRCbG9jayA/IHtcbiAgICAgIG5leHRCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIG5leHRCbG9ja1xuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwibW92ZS5ibG9ja1wiLFxuICAgIGF0OiBldmVudC5hdCxcbiAgICB0bzogbmV4dEJsb2NrLnBhdGhcbiAgfSldXVxufSldLCBhYnN0cmFjdFNlbGVjdEJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcInNlbGVjdC5wcmV2aW91cyBibG9ja1wiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soc25hcHNob3QpO1xuICAgIGlmICghcHJldmlvdXNCbG9jaylcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBwb2ludCA9IGV2ZW50LnNlbGVjdCA9PT0gXCJlbmRcIiA/IGdldEJsb2NrRW5kUG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBwcmV2aW91c0Jsb2NrXG4gICAgfSkgOiBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBwcmV2aW91c0Jsb2NrXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHBvaW50LFxuICAgICAgICBmb2N1czogcG9pbnRcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3Rpb25cbiAgfSkgPT4gW3JhaXNlKHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIGF0OiBzZWxlY3Rpb25cbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic2VsZWN0Lm5leHQgYmxvY2tcIixcbiAgZ3VhcmQ6ICh7XG4gICAgc25hcHNob3QsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IG5leHRCbG9jayA9IGdldE5leHRCbG9jayhzbmFwc2hvdCk7XG4gICAgaWYgKCFuZXh0QmxvY2spXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcG9pbnQgPSBldmVudC5zZWxlY3QgPT09IFwiZW5kXCIgPyBnZXRCbG9ja0VuZFBvaW50KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBibG9jazogbmV4dEJsb2NrXG4gICAgfSkgOiBnZXRCbG9ja1N0YXJ0UG9pbnQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGJsb2NrOiBuZXh0QmxvY2tcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjogcG9pbnQsXG4gICAgICAgIGZvY3VzOiBwb2ludFxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIHNlbGVjdGlvblxuICB9KSA9PiBbcmFpc2Uoe1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgYXQ6IHNlbGVjdGlvblxuICB9KV1dXG59KV0sIGFic3RyYWN0U3BsaXRCZWhhdmlvcnMgPSBbZGVmaW5lQmVoYXZpb3Ioe1xuICBvbjogXCJzcGxpdFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiB7XG4gICAgaWYgKCFzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydFBvaW50ID0gZ2V0U2VsZWN0aW9uU3RhcnRQb2ludChzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiksIHNlbGVjdGlvbkVuZFBvaW50ID0gZ2V0U2VsZWN0aW9uRW5kUG9pbnQoc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24pLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25TdGFydFBvaW50LFxuICAgICAgICAgIGZvY3VzOiBzZWxlY3Rpb25FbmRQb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZvY3VzVGV4dEJsb2NrKSB7XG4gICAgICBjb25zdCBibG9ja0VuZFBvaW50ID0gZ2V0QmxvY2tFbmRQb2ludCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIGJsb2NrOiBmb2N1c1RleHRCbG9ja1xuICAgICAgfSksIG5ld1RleHRCbG9ja1NlbGVjdGlvbiA9IHtcbiAgICAgICAgYW5jaG9yOiBzZWxlY3Rpb25FbmRQb2ludCxcbiAgICAgICAgZm9jdXM6IGJsb2NrRW5kUG9pbnRcbiAgICAgIH0sIG5ld1RleHRCbG9jayA9IHBhcnNlQmxvY2soe1xuICAgICAgICBibG9jazogc2xpY2VCbG9ja3Moe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IG5ld1RleHRCbG9ja1NlbGVjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmxvY2tzOiBbZm9jdXNUZXh0QmxvY2subm9kZV1cbiAgICAgICAgfSkuYXQoMCksXG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByZWZyZXNoS2V5czogITAsXG4gICAgICAgICAgdmFsaWRhdGVGaWVsZHM6ICEwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICFuZXdUZXh0QmxvY2sgfHwgIWlzVGV4dEJsb2NrKHNuYXBzaG90LmNvbnRleHQsIG5ld1RleHRCbG9jaykgPyAhMSA6IHtcbiAgICAgICAgbmV3VGV4dEJsb2NrLFxuICAgICAgICBuZXdUZXh0QmxvY2tTZWxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgICAgICAgICBmb2N1czogYmxvY2tFbmRQb2ludFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZ2V0Rm9jdXNCbG9ja09iamVjdCh7XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uU3RhcnRQb2ludCxcbiAgICAgICAgICBmb2N1czogc2VsZWN0aW9uRW5kUG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKSB7XG4gICAgICBjb25zdCBuZXdUZXh0QmxvY2sgPSBwYXJzZUJsb2NrKHtcbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHJlZnJlc2hLZXlzOiAhMCxcbiAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3VGV4dEJsb2NrID8ge1xuICAgICAgICBuZXdUZXh0QmxvY2ssXG4gICAgICAgIG5ld1RleHRCbG9ja1NlbGVjdGlvbjoge1xuICAgICAgICAgIGFuY2hvcjogc2VsZWN0aW9uRW5kUG9pbnQsXG4gICAgICAgICAgZm9jdXM6IHNlbGVjdGlvbkVuZFBvaW50XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICAgIH0gOiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBuZXdUZXh0QmxvY2ssXG4gICAgc2VsZWN0aW9uXG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJkZWxldGVcIixcbiAgICBhdDogc2VsZWN0aW9uXG4gIH0pLCByYWlzZSh7XG4gICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBibG9jazogbmV3VGV4dEJsb2NrLFxuICAgIHBsYWNlbWVudDogXCJhZnRlclwiLFxuICAgIHNlbGVjdDogXCJzdGFydFwiXG4gIH0pXV1cbn0pXSwgYWJzdHJhY3RTdHlsZUJlaGF2aW9ycyA9IFtkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcInN0eWxlLmFkZFwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdFxuICB9KSA9PiAoe1xuICAgIHNlbGVjdGVkVGV4dEJsb2NrczogZ2V0U2VsZWN0ZWRUZXh0QmxvY2tzKHNuYXBzaG90KVxuICB9KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwge1xuICAgIHNlbGVjdGVkVGV4dEJsb2Nrc1xuICB9KSA9PiBzZWxlY3RlZFRleHRCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgYXQ6IGJsb2NrLnBhdGgsXG4gICAgcHJvcHM6IHtcbiAgICAgIHN0eWxlOiBldmVudC5zdHlsZVxuICAgIH1cbiAgfSkpXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic3R5bGUucmVtb3ZlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90XG4gIH0pID0+ICh7XG4gICAgc2VsZWN0ZWRUZXh0QmxvY2tzOiBnZXRTZWxlY3RlZFRleHRCbG9ja3Moc25hcHNob3QpXG4gIH0pLFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3RlZFRleHRCbG9ja3NcbiAgfSkgPT4gc2VsZWN0ZWRUZXh0QmxvY2tzLm1hcCgoYmxvY2spID0+IHJhaXNlKHtcbiAgICB0eXBlOiBcImJsb2NrLnVuc2V0XCIsXG4gICAgYXQ6IGJsb2NrLnBhdGgsXG4gICAgcHJvcHM6IFtcInN0eWxlXCJdXG4gIH0pKV1cbn0pLCBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcInN0eWxlLnRvZ2dsZVwiLFxuICBndWFyZDogKHtcbiAgICBzbmFwc2hvdCxcbiAgICBldmVudFxuICB9KSA9PiBpc0FjdGl2ZVN0eWxlKGV2ZW50LnN0eWxlKShzbmFwc2hvdCksXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzdHlsZS5yZW1vdmVcIixcbiAgICBzdHlsZTogZXZlbnQuc3R5bGVcbiAgfSldXVxufSksIGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic3R5bGUudG9nZ2xlXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+ICFpc0FjdGl2ZVN0eWxlKGV2ZW50LnN0eWxlKShzbmFwc2hvdCksXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtyYWlzZSh7XG4gICAgdHlwZTogXCJzdHlsZS5hZGRcIixcbiAgICBzdHlsZTogZXZlbnQuc3R5bGVcbiAgfSldXVxufSldLCByYWlzZURlc2VyaWFsaXphdGlvblN1Y2Nlc3NPckZhaWx1cmUgPSBkZWZpbmVCZWhhdmlvcih7XG4gIG9uOiBcImRlc2VyaWFsaXplXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBsZXQgc3VjY2VzcztcbiAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29udmVydGVyIG9mIHNuYXBzaG90LmNvbnRleHQuY29udmVydGVycykge1xuICAgICAgY29uc3QgZGF0YSA9IGV2ZW50Lm9yaWdpbkV2ZW50Lm9yaWdpbkV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKGNvbnZlcnRlci5taW1lVHlwZSk7XG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGVzZXJpYWxpemVFdmVudCA9IGNvbnZlcnRlci5kZXNlcmlhbGl6ZSh7XG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICBldmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRlc2VyaWFsaXplRXZlbnQudHlwZSA9PT0gXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiKSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBkZXNlcmlhbGl6ZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZVxuICAgICAgICBmYWlsdXJlcy5wdXNoKGRlc2VyaWFsaXplRXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcyB8fCB7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgICBtaW1lVHlwZTogXCIqLypcIixcbiAgICAgIHJlYXNvbjogZmFpbHVyZXMubWFwKChmYWlsdXJlKSA9PiBmYWlsdXJlLnJlYXNvbikuam9pbihcIiwgXCIpXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwgZGVzZXJpYWxpemVFdmVudCkgPT4gW3JhaXNlKHtcbiAgICAuLi5kZXNlcmlhbGl6ZUV2ZW50LFxuICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICB9KV1dXG59KSwgcmFpc2VTZXJpYWxpemF0aW9uU3VjY2Vzc09yRmFpbHVyZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgb246IFwic2VyaWFsaXplXCIsXG4gIGd1YXJkOiAoe1xuICAgIHNuYXBzaG90LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoc25hcHNob3QuY29udGV4dC5jb252ZXJ0ZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZXJpYWxpemVFdmVudHMgPSBzbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnMubWFwKChjb252ZXJ0ZXIpID0+IGNvbnZlcnRlci5zZXJpYWxpemUoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudDoge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50LnR5cGVcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZUV2ZW50cy5sZW5ndGggPT09IDAgPyAhMSA6IHNlcmlhbGl6ZUV2ZW50cztcbiAgfSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSwgc2VyaWFsaXplRXZlbnRzKSA9PiBzZXJpYWxpemVFdmVudHMubWFwKChzZXJpYWxpemVFdmVudCkgPT4gcmFpc2Uoe1xuICAgIC4uLnNlcmlhbGl6ZUV2ZW50LFxuICAgIG9yaWdpbkV2ZW50OiBldmVudC5vcmlnaW5FdmVudFxuICB9KSldXG59KSwgYWJzdHJhY3RCZWhhdmlvcnMgPSBbXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJjbGlwYm9hcmQuY29weVwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCk7XG4gICAgICByZXR1cm4gZm9jdXNTcGFuICYmIHNlbGVjdGlvbkNvbGxhcHNlZDtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiY2xpcGJvYXJkLmNvcHlcIixcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwic2VyaWFsaXplXCIsXG4gICAgICBvcmlnaW5FdmVudDogZXZlbnRcbiAgICB9KV1dXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiY2xpcGJvYXJkLmN1dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oc25hcHNob3QpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCk7XG4gICAgICByZXR1cm4gZm9jdXNTcGFuICYmIHNlbGVjdGlvbkNvbGxhcHNlZDtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFtdXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiY2xpcGJvYXJkLmN1dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiA/IHtcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9IDogITEsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0sIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcInNlcmlhbGl6ZVwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50XG4gICAgfSksIHJhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICBhdDogc2VsZWN0aW9uXG4gICAgfSldXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRyYWcuZHJhZ3N0YXJ0XCIsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcInNlcmlhbGl6ZVwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50XG4gICAgfSldXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcInNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICBldmVudC5vcmlnaW5FdmVudC5vcmlnaW5FdmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShldmVudC5taW1lVHlwZSwgZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgfV1dXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwic2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFt7XG4gICAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU2VyaWFsaXphdGlvbiBvZiAke2V2ZW50Lm1pbWVUeXBlfSBmYWlsZWQgd2l0aCByZWFzb24gXCIke2V2ZW50LnJlYXNvbn1cImApO1xuICAgICAgfVxuICAgIH1dXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRyYWcuZHJvcFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRyYWdPcmlnaW4gPSBzbmFwc2hvdC5iZXRhLmludGVybmFsRHJhZz8ub3JpZ2luLCBkcm9wUG9zaXRpb24gPSBldmVudC5wb3NpdGlvbi5zZWxlY3Rpb247XG4gICAgICByZXR1cm4gZHJhZ09yaWdpbiA/IGlzT3ZlcmxhcHBpbmdTZWxlY3Rpb24oZHJvcFBvc2l0aW9uKSh7XG4gICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgLi4uc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgICBzZWxlY3Rpb246IGRyYWdPcmlnaW4uc2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pIDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRyYWcuZHJvcFwiLFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgIGF0OiBldmVudC5wb3NpdGlvbi5zZWxlY3Rpb25cbiAgICB9KSwgcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZXNlcmlhbGl6ZVwiLFxuICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50XG4gICAgfSldXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lm9yaWdpbkV2ZW50LnR5cGUgIT09IFwiZHJhZy5kcm9wXCIgfHwgc25hcHNob3QuYmV0YS5pbnRlcm5hbERyYWcgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZHJhZ09yaWdpbiA9IHNuYXBzaG90LmJldGEuaW50ZXJuYWxEcmFnLm9yaWdpbiwgZHJvcFBvc2l0aW9uID0gZXZlbnQub3JpZ2luRXZlbnQucG9zaXRpb24uc2VsZWN0aW9uLCBkcm9wcGluZ09uRHJhZ09yaWdpbiA9IGRyYWdPcmlnaW4gPyBpc092ZXJsYXBwaW5nU2VsZWN0aW9uKGRyb3BQb3NpdGlvbikoe1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KSA6ICExLCBkcmFnZ2luZ0VudGlyZUJsb2NrcyA9IGlzU2VsZWN0aW5nRW50aXJlQmxvY2tzKHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KSwgZHJhZ2dlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnT3JpZ2luLnNlbGVjdGlvblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkcm9wcGluZ09uRHJhZ09yaWdpbiA/ICExIDoge1xuICAgICAgICBkcmFnZ2luZ0VudGlyZUJsb2NrcyxcbiAgICAgICAgZHJhZ2dlZEJsb2NrcyxcbiAgICAgICAgZHJhZ09yaWdpbixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IGV2ZW50Lm9yaWdpbkV2ZW50XG4gICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0sIHtcbiAgICAgIGRyYWdnaW5nRW50aXJlQmxvY2tzLFxuICAgICAgZHJhZ2dlZEJsb2NrcyxcbiAgICAgIGRyYWdPcmlnaW4sXG4gICAgICBvcmlnaW5FdmVudFxuICAgIH0pID0+IFsuLi5kcmFnZ2luZ0VudGlyZUJsb2NrcyA/IGRyYWdnZWRCbG9ja3MubWFwKChibG9jaykgPT4gcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICAgIGF0OiBibG9jay5wYXRoXG4gICAgfSkpIDogW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICBhdDogZHJhZ09yaWdpbi5zZWxlY3Rpb25cbiAgICB9KV0sIHJhaXNlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2Nrc1wiLFxuICAgICAgYmxvY2tzOiBldmVudC5kYXRhLFxuICAgICAgcGxhY2VtZW50OiBkcmFnZ2luZ0VudGlyZUJsb2NrcyA/IG9yaWdpbkV2ZW50LnBvc2l0aW9uLmJsb2NrID09PSBcInN0YXJ0XCIgPyBcImJlZm9yZVwiIDogb3JpZ2luRXZlbnQucG9zaXRpb24uYmxvY2sgPT09IFwiZW5kXCIgPyBcImFmdGVyXCIgOiBcImF1dG9cIiA6IFwiYXV0b1wiXG4gICAgfSldXVxuICB9KSxcbiAgLyoqXG4gICAqIElmIHdlIGFyZSBwYXN0aW5nIHRleHQvcGxhaW4gaW50byBhIHRleHQgYmxvY2sgdGhlbiB3ZSBjYW4gcHJvYmFibHlcbiAgICogYXNzdW1lIHRoYXQgdGhlIGludGVuZGVkIGJlaGF2aW9yIGlzIHRoYXQgdGhlIHBhc3RlZCB0ZXh0IGluaGVyaXRzXG4gICAqIGZvcm1hdHRpbmcgZnJvbSB0aGUgdGV4dCBpdCdzIHBhc3RlZCBpbnRvLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSAmJiBldmVudC5taW1lVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIgJiYgZXZlbnQub3JpZ2luRXZlbnQudHlwZSA9PT0gXCJjbGlwYm9hcmQucGFzdGVcIikge1xuICAgICAgICBjb25zdCBhY3RpdmVEZWNvcmF0b3JzID0gc25hcHNob3QuY29udGV4dC5hY3RpdmVEZWNvcmF0b3JzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGl2ZUFubm90YXRpb25zOiBnZXRBY3RpdmVBbm5vdGF0aW9ucyhzbmFwc2hvdCksXG4gICAgICAgICAgYWN0aXZlRGVjb3JhdG9ycyxcbiAgICAgICAgICB0ZXh0UnVuczogZXZlbnQuZGF0YS5mbGF0TWFwKChibG9jaykgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgYmxvY2spID8gW2dldFRleHRCbG9ja1RleHQoYmxvY2spXSA6IFtdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBhY3RpdmVBbm5vdGF0aW9ucyxcbiAgICAgIGFjdGl2ZURlY29yYXRvcnMsXG4gICAgICB0ZXh0UnVuc1xuICAgIH0pID0+IHRleHRSdW5zLmZsYXRNYXAoKHRleHRSdW4sIGluZGV4KSA9PiBpbmRleCAhPT0gdGV4dFJ1bnMubGVuZ3RoIC0gMSA/IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5zcGFuXCIsXG4gICAgICB0ZXh0OiB0ZXh0UnVuLFxuICAgICAgZGVjb3JhdG9yczogYWN0aXZlRGVjb3JhdG9ycyxcbiAgICAgIGFubm90YXRpb25zOiBhY3RpdmVBbm5vdGF0aW9ucy5tYXAoKHtcbiAgICAgICAgX2tleSxcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9KSA9PiAoe1xuICAgICAgICBuYW1lOiBfdHlwZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pKVxuICAgIH0pLCByYWlzZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5icmVha1wiXG4gICAgfSldIDogW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnNwYW5cIixcbiAgICAgIHRleHQ6IHRleHRSdW4sXG4gICAgICBkZWNvcmF0b3JzOiBhY3RpdmVEZWNvcmF0b3JzLFxuICAgICAgYW5ub3RhdGlvbnM6IGFjdGl2ZUFubm90YXRpb25zLm1hcCgoe1xuICAgICAgICBfa2V5LFxuICAgICAgICBfdHlwZSxcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIG5hbWU6IF90eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkpXG4gICAgfSldKV1cbiAgfSksXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJkZXNlcmlhbGl6YXRpb24uc3VjY2Vzc1wiLFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tzXCIsXG4gICAgICBibG9ja3M6IGV2ZW50LmRhdGEsXG4gICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiXG4gICAgfSldXVxuICB9KSxcbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlc2VyaWFsaXphdGlvbi5mYWlsdXJlXCIsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFt7XG4gICAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRGVzZXJpYWxpemF0aW9uIG9mICR7ZXZlbnQubWltZVR5cGV9IGZhaWxlZCB3aXRoIHJlYXNvbiBcIiR7ZXZlbnQucmVhc29ufVwiYCk7XG4gICAgICB9XG4gICAgfV1dXG4gIH0pLFxuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiY2xpcGJvYXJkLnBhc3RlXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0pID0+IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uICYmIGlzU2VsZWN0aW9uRXhwYW5kZWQoc25hcHNob3QpID8ge1xuICAgICAgc2VsZWN0aW9uOiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvblxuICAgIH0gOiAhMSxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSwge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICBhdDogc2VsZWN0aW9uXG4gICAgfSksIHJhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudFxuICAgIH0pXV1cbiAgfSksXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJjbGlwYm9hcmQucGFzdGVcIixcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVzZXJpYWxpemVcIixcbiAgICAgIG9yaWdpbkV2ZW50OiBldmVudFxuICAgIH0pXV1cbiAgfSksXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnB1dC4qXCIsXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlc2VyaWFsaXplXCIsXG4gICAgICBvcmlnaW5FdmVudDogZXZlbnRcbiAgICB9KV1dXG4gIH0pLFxuICAuLi5hYnN0cmFjdEFubm90YXRpb25CZWhhdmlvcnMsXG4gIC4uLmFic3RyYWN0RGVjb3JhdG9yQmVoYXZpb3JzLFxuICAuLi5hYnN0cmFjdERlbGV0ZUJlaGF2aW9ycyxcbiAgLi4uYWJzdHJhY3RJbnNlcnRCZWhhdmlvcnMsXG4gIC4uLmFic3RyYWN0S2V5Ym9hcmRCZWhhdmlvcnMsXG4gIC4uLmFic3RyYWN0TGlzdEl0ZW1CZWhhdmlvcnMsXG4gIC4uLmFic3RyYWN0TW92ZUJlaGF2aW9ycyxcbiAgLi4uYWJzdHJhY3RTdHlsZUJlaGF2aW9ycyxcbiAgLi4uYWJzdHJhY3RTZWxlY3RCZWhhdmlvcnMsXG4gIC4uLmFic3RyYWN0U3BsaXRCZWhhdmlvcnMsXG4gIHJhaXNlRGVzZXJpYWxpemF0aW9uU3VjY2Vzc09yRmFpbHVyZSxcbiAgcmFpc2VTZXJpYWxpemF0aW9uU3VjY2Vzc09yRmFpbHVyZVxuXTtcbmZ1bmN0aW9uIGlzU3ludGhldGljQmVoYXZpb3JFdmVudChldmVudCkge1xuICByZXR1cm4gIWlzQ3VzdG9tQmVoYXZpb3JFdmVudChldmVudCkgJiYgIWlzTmF0aXZlQmVoYXZpb3JFdmVudChldmVudCkgJiYgIWlzQWJzdHJhY3RCZWhhdmlvckV2ZW50KGV2ZW50KTtcbn1cbmNvbnN0IGFic3RyYWN0QmVoYXZpb3JFdmVudFR5cGVzID0gW1wiYW5ub3RhdGlvbi50b2dnbGVcIiwgXCJkZWNvcmF0b3IudG9nZ2xlXCIsIFwiZGVsZXRlLnRleHRcIiwgXCJkZXNlcmlhbGl6ZVwiLCBcImRlc2VyaWFsaXphdGlvbi5zdWNjZXNzXCIsIFwiZGVzZXJpYWxpemF0aW9uLmZhaWx1cmVcIiwgXCJpbnNlcnQuYmxvY2tzXCIsIFwiaW5zZXJ0LmJyZWFrXCIsIFwiaW5zZXJ0LnNvZnQgYnJlYWtcIiwgXCJsaXN0IGl0ZW0uYWRkXCIsIFwibGlzdCBpdGVtLnJlbW92ZVwiLCBcImxpc3QgaXRlbS50b2dnbGVcIiwgXCJtb3ZlLmJsb2NrIGRvd25cIiwgXCJtb3ZlLmJsb2NrIHVwXCIsIFwic2VsZWN0LnByZXZpb3VzIGJsb2NrXCIsIFwic2VsZWN0Lm5leHQgYmxvY2tcIiwgXCJzZXJpYWxpemVcIiwgXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIiwgXCJzZXJpYWxpemF0aW9uLmZhaWx1cmVcIiwgXCJzcGxpdFwiLCBcInN0eWxlLmFkZFwiLCBcInN0eWxlLnJlbW92ZVwiLCBcInN0eWxlLnRvZ2dsZVwiXTtcbmZ1bmN0aW9uIGlzQWJzdHJhY3RCZWhhdmlvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBhYnN0cmFjdEJlaGF2aW9yRXZlbnRUeXBlcy5pbmNsdWRlcyhldmVudC50eXBlKTtcbn1cbmNvbnN0IG5hdGl2ZUJlaGF2aW9yRXZlbnRUeXBlcyA9IFtcImNsaXBib2FyZC5jb3B5XCIsIFwiY2xpcGJvYXJkLmN1dFwiLCBcImNsaXBib2FyZC5wYXN0ZVwiLCBcImRyYWcuZHJhZ3N0YXJ0XCIsIFwiZHJhZy5kcmFnXCIsIFwiZHJhZy5kcmFnZW5kXCIsIFwiZHJhZy5kcmFnZW50ZXJcIiwgXCJkcmFnLmRyYWdvdmVyXCIsIFwiZHJhZy5kcmFnbGVhdmVcIiwgXCJkcmFnLmRyb3BcIiwgXCJpbnB1dC4qXCIsIFwia2V5Ym9hcmQua2V5ZG93blwiLCBcImtleWJvYXJkLmtleXVwXCIsIFwibW91c2UuY2xpY2tcIl07XG5mdW5jdGlvbiBpc05hdGl2ZUJlaGF2aW9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIG5hdGl2ZUJlaGF2aW9yRXZlbnRUeXBlcy5pbmNsdWRlcyhldmVudC50eXBlKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tQmVoYXZpb3JFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKFwiY3VzdG9tLlwiKTtcbn1cbmNvbnN0IGRlYnVnJDggPSBkZWJ1Z1dpdGhOYW1lKFwiYmVoYXZpb3JzOmV2ZW50XCIpO1xuZnVuY3Rpb24gZXZlbnRDYXRlZ29yeShldmVudCkge1xuICByZXR1cm4gaXNOYXRpdmVCZWhhdmlvckV2ZW50KGV2ZW50KSA/IFwibmF0aXZlXCIgOiBpc0Fic3RyYWN0QmVoYXZpb3JFdmVudChldmVudCkgPyBcInN5bnRoZXRpY1wiIDogaXNDdXN0b21CZWhhdmlvckV2ZW50KGV2ZW50KSA/IFwiY3VzdG9tXCIgOiBcInN5bnRoZXRpY1wiO1xufVxuZnVuY3Rpb24gcGVyZm9ybUV2ZW50KHtcbiAgbW9kZSxcbiAgYmVoYXZpb3JzLFxuICByZW1haW5pbmdFdmVudEJlaGF2aW9ycyxcbiAgZXZlbnQsXG4gIGVkaXRvcixcbiAga2V5R2VuZXJhdG9yLFxuICBzY2hlbWEsXG4gIGdldFNuYXBzaG90LFxuICBuYXRpdmVFdmVudFxufSkge1xuICBkZWJ1ZyQ4KGAoJHttb2RlfToke2V2ZW50Q2F0ZWdvcnkoZXZlbnQpfSlgLCBKU09OLnN0cmluZ2lmeShldmVudCwgbnVsbCwgMikpO1xuICBjb25zdCBldmVudEJlaGF2aW9ycyA9IFsuLi5yZW1haW5pbmdFdmVudEJlaGF2aW9ycywgLi4uYWJzdHJhY3RCZWhhdmlvcnNdLmZpbHRlcigoYmVoYXZpb3IpID0+IHtcbiAgICBpZiAoYmVoYXZpb3Iub24gPT09IFwiKlwiKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IFtsaXN0ZW5lZE5hbWVzcGFjZV0gPSBiZWhhdmlvci5vbi5pbmNsdWRlcyhcIipcIikgJiYgYmVoYXZpb3Iub24uaW5jbHVkZXMoXCIuXCIpID8gYmVoYXZpb3Iub24uc3BsaXQoXCIuXCIpIDogW3ZvaWQgMF0sIFtldmVudE5hbWVzcGFjZV0gPSBldmVudC50eXBlLmluY2x1ZGVzKFwiLlwiKSA/IGV2ZW50LnR5cGUuc3BsaXQoXCIuXCIpIDogW3ZvaWQgMF07XG4gICAgcmV0dXJuIGxpc3RlbmVkTmFtZXNwYWNlICE9PSB2b2lkIDAgJiYgZXZlbnROYW1lc3BhY2UgIT09IHZvaWQgMCAmJiBsaXN0ZW5lZE5hbWVzcGFjZSA9PT0gZXZlbnROYW1lc3BhY2UgfHwgbGlzdGVuZWROYW1lc3BhY2UgIT09IHZvaWQgMCAmJiBldmVudE5hbWVzcGFjZSA9PT0gdm9pZCAwICYmIGxpc3RlbmVkTmFtZXNwYWNlID09PSBldmVudC50eXBlID8gITAgOiBiZWhhdmlvci5vbiA9PT0gZXZlbnQudHlwZTtcbiAgfSk7XG4gIGlmIChldmVudEJlaGF2aW9ycy5sZW5ndGggPT09IDAgJiYgaXNTeW50aGV0aWNCZWhhdmlvckV2ZW50KGV2ZW50KSkge1xuICAgIG5hdGl2ZUV2ZW50Py5wcmV2ZW50RGVmYXVsdCgpLCB3aXRoQXBwbHlpbmdCZWhhdmlvck9wZXJhdGlvbnMoZWRpdG9yLCAoKSA9PiB7XG4gICAgICBkZWJ1ZyQ4KGAoZXhlY3V0ZToke2V2ZW50Q2F0ZWdvcnkoZXZlbnQpfSlgLCBKU09OLnN0cmluZ2lmeShldmVudCwgbnVsbCwgMikpLCBwZXJmb3JtT3BlcmF0aW9uKHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfSxcbiAgICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgZWRpdG9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZ3VhcmRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gIGxldCBuYXRpdmVFdmVudFByZXZlbnRlZCA9ICExLCBkZWZhdWx0QmVoYXZpb3JPdmVyd3JpdHRlbiA9ICExLCBldmVudEJlaGF2aW9ySW5kZXggPSAtMTtcbiAgZm9yIChjb25zdCBldmVudEJlaGF2aW9yIG9mIGV2ZW50QmVoYXZpb3JzKSB7XG4gICAgZXZlbnRCZWhhdmlvckluZGV4Kys7XG4gICAgbGV0IHNob3VsZFJ1biA9ICExO1xuICAgIHRyeSB7XG4gICAgICBzaG91bGRSdW4gPSBldmVudEJlaGF2aW9yLmd1YXJkID09PSB2b2lkIDAgfHwgZXZlbnRCZWhhdmlvci5ndWFyZCh7XG4gICAgICAgIHNuYXBzaG90OiBndWFyZFNuYXBzaG90LFxuICAgICAgICBldmVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBFdmFsdWF0aW5nIGd1YXJkIGZvciBcIiR7ZXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUnVuKSB7XG4gICAgICBkZWZhdWx0QmVoYXZpb3JPdmVyd3JpdHRlbiA9ICEwO1xuICAgICAgZm9yIChjb25zdCBhY3Rpb25TZXQgb2YgZXZlbnRCZWhhdmlvci5hY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnNTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIGxldCBhY3Rpb25zID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWN0aW9ucyA9IGFjdGlvblNldCh7XG4gICAgICAgICAgICBzbmFwc2hvdDogYWN0aW9uc1NuYXBzaG90LFxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9LCBzaG91bGRSdW4pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBFdmFsdWF0aW5nIGFjdGlvbnMgZm9yIFwiJHtldmVudC50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGFjdGlvbnMuc29tZSgoYWN0aW9uKSA9PiBhY3Rpb24udHlwZSA9PT0gXCJleGVjdXRlXCIpKSB7XG4gICAgICAgICAgICB3aXRoVW5kb1N0ZXAoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwiZWZmZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50UHJldmVudGVkID0gITA7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZWZmZWN0KCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgRXhlY3V0aW5nIGVmZmVjdCBhcyBhIHJlc3VsdCBvZiBcIiR7ZXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzMiA9IGV2ZW50QmVoYXZpb3JzLnNsaWNlKGV2ZW50QmVoYXZpb3JJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJmb3J3YXJkXCIsXG4gICAgICAgICAgICAgICAgICAgIGJlaGF2aW9ycyxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRXZlbnRCZWhhdmlvcnM6IHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzMixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGFjdGlvbi5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBrZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwicmFpc2VcIikge1xuICAgICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRQcmV2ZW50ZWQgPSAhMCwgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJyYWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzOiBiZWhhdmlvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhY3Rpb24uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRQcmV2ZW50ZWQgPSAhMCwgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IFwiZXhlY3V0ZVwiLFxuICAgICAgICAgICAgICAgICAgYmVoYXZpb3JzLFxuICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRXZlbnRCZWhhdmlvcnM6IGlzQWJzdHJhY3RCZWhhdmlvckV2ZW50KGFjdGlvbi5ldmVudCkgPyBiZWhhdmlvcnMgOiBbXSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBhY3Rpb24uZXZlbnQsXG4gICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICBrZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcImVmZmVjdFwiKSB7XG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50UHJldmVudGVkID0gITA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmVmZmVjdCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBFeGVjdXRpbmcgZWZmZWN0IGFzIGEgcmVzdWx0IG9mIFwiJHtldmVudC50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzMiA9IGV2ZW50QmVoYXZpb3JzLnNsaWNlKGV2ZW50QmVoYXZpb3JJbmRleCArIDEpO1xuICAgICAgICAgICAgICBwZXJmb3JtRXZlbnQoe1xuICAgICAgICAgICAgICAgIG1vZGU6IFwiZm9yd2FyZFwiLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9ycyxcbiAgICAgICAgICAgICAgICByZW1haW5pbmdFdmVudEJlaGF2aW9yczogcmVtYWluaW5nRXZlbnRCZWhhdmlvcnMyLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBhY3Rpb24uZXZlbnQsXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInJhaXNlXCIpIHtcbiAgICAgICAgICAgICAgbmF0aXZlRXZlbnRQcmV2ZW50ZWQgPSAhMCwgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICAgICAgICBtb2RlOiBcInJhaXNlXCIsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3JzLFxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzOiBiZWhhdmlvcnMsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGFjdGlvbi5ldmVudCxcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gXCJleGVjdXRlXCIgJiYgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgYWN0aW9uIHR5cGU6IGBleGVjdXRlYFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAhZGVmYXVsdEJlaGF2aW9yT3ZlcndyaXR0ZW4gJiYgaXNTeW50aGV0aWNCZWhhdmlvckV2ZW50KGV2ZW50KSA/IChuYXRpdmVFdmVudD8ucHJldmVudERlZmF1bHQoKSwgd2l0aEFwcGx5aW5nQmVoYXZpb3JPcGVyYXRpb25zKGVkaXRvciwgKCkgPT4ge1xuICAgIGRlYnVnJDgoYChleGVjdXRlOiR7ZXZlbnRDYXRlZ29yeShldmVudCl9KWAsIEpTT04uc3RyaW5naWZ5KGV2ZW50LCBudWxsLCAyKSksIHBlcmZvcm1PcGVyYXRpb24oe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBrZXlHZW5lcmF0b3IsXG4gICAgICAgIHNjaGVtYVxuICAgICAgfSxcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSkgOiBuYXRpdmVFdmVudFByZXZlbnRlZCAmJiBuYXRpdmVFdmVudD8ucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVByaW9yaXR5KGl0ZW1zKSB7XG4gIGlmIChpdGVtcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBpdGVtc1dpdGhQcmlvcml0eSA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5wcmlvcml0eSAhPT0gdm9pZCAwKSwgaXRlbXNXaXRob3V0UHJpb3JpdHkgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ucHJpb3JpdHkgPT09IHZvaWQgMCk7XG4gIGlmIChpdGVtc1dpdGhQcmlvcml0eS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGl0ZW1zO1xuICBjb25zdCBpdGVtc0J5UHJpb3JpdHlJZCA9IG5ldyBNYXAoaXRlbXNXaXRoUHJpb3JpdHkubWFwKChpdGVtKSA9PiBbaXRlbS5wcmlvcml0eS5pZCwgaXRlbV0pKSwgZ3JhcGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBpbkRlZ3JlZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGVuc3VyZU5vZGUoaWQpIHtcbiAgICBncmFwaC5oYXMoaWQpIHx8IChncmFwaC5zZXQoaWQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLCBpbkRlZ3JlZS5zZXQoaWQsIDApKTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXNXaXRoUHJpb3JpdHkpIHtcbiAgICBjb25zdCBpZCA9IGl0ZW0ucHJpb3JpdHkuaWQ7XG4gICAgZW5zdXJlTm9kZShpZCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRWRnZShmcm9tSWQsIHRvSWQpIHtcbiAgICAhZ3JhcGguaGFzKGZyb21JZCkgfHwgIWdyYXBoLmhhcyh0b0lkKSB8fCAoZ3JhcGguZ2V0KGZyb21JZCk/LmFkZCh0b0lkKSwgaW5EZWdyZWUuc2V0KHRvSWQsIChpbkRlZ3JlZS5nZXQodG9JZCkgPz8gMCkgKyAxKSk7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zV2l0aFByaW9yaXR5KSB7XG4gICAgY29uc3QgaWQgPSBpdGVtLnByaW9yaXR5LmlkLCB2aXNpdGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgcmVmID0gaXRlbS5wcmlvcml0eS5yZWZlcmVuY2U7XG4gICAgZm9yICg7IHJlZjsgKSB7XG4gICAgICBjb25zdCByZWZJZCA9IHJlZi5wcmlvcml0eS5pZDtcbiAgICAgIGlmIChlbnN1cmVOb2RlKHJlZklkKSwgdmlzaXRlZC5oYXMocmVmSWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciBkZXBlbmRlbmN5IGRldGVjdGVkIGluIHByaW9yaXRpZXNcIik7XG4gICAgICB2aXNpdGVkLmFkZChyZWZJZCksIHJlZi5pbXBvcnRhbmNlID09PSBcImhpZ2hlclwiID8gYWRkRWRnZShpZCwgcmVmSWQpIDogYWRkRWRnZShyZWZJZCwgaWQpLCByZWYgPSByZWYucHJpb3JpdHkucmVmZXJlbmNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBxdWV1ZSA9IFtdO1xuICBmb3IgKGNvbnN0IFtpZCwgZGVncmVlXSBvZiBpbkRlZ3JlZSlcbiAgICBkZWdyZWUgPT09IDAgJiYgcXVldWUucHVzaChpZCk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKDsgcXVldWUubGVuZ3RoID4gMDsgKSB7XG4gICAgY29uc3QgY3VycmVudElkID0gcXVldWUuc2hpZnQoKSwgY3VycmVudEl0ZW0gPSBpdGVtc0J5UHJpb3JpdHlJZC5nZXQoY3VycmVudElkKTtcbiAgICBjdXJyZW50SXRlbSAmJiByZXN1bHQucHVzaChjdXJyZW50SXRlbSk7XG4gICAgZm9yIChjb25zdCBuZWlnaGJvcklkIG9mIGdyYXBoLmdldChjdXJyZW50SWQpID8/IFtdKSB7XG4gICAgICBjb25zdCBuZXdEZWdyZWUgPSAoaW5EZWdyZWUuZ2V0KG5laWdoYm9ySWQpID8/IDApIC0gMTtcbiAgICAgIGluRGVncmVlLnNldChuZWlnaGJvcklkLCBuZXdEZWdyZWUpLCBuZXdEZWdyZWUgPT09IDAgJiYgcXVldWUucHVzaChuZWlnaGJvcklkKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zV2l0aFByaW9yaXR5KVxuICAgIHJlc3VsdC5pbmNsdWRlcyhpdGVtKSB8fCByZXN1bHQucHVzaChpdGVtKTtcbiAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLml0ZW1zV2l0aG91dFByaW9yaXR5XTtcbn1cbmZ1bmN0aW9uIHNsYXRlQ2hpbGRyZW5Ub0Jsb2NrcyhzY2hlbWEsIHZhbHVlKSB7XG4gIGNvbnN0IGJsb2NrcyA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICBmb3IgKGxldCBibG9ja0luZGV4ID0gMDsgYmxvY2tJbmRleCA8IHZhbHVlLmxlbmd0aDsgYmxvY2tJbmRleCsrKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudCA9IHZhbHVlW2Jsb2NrSW5kZXhdO1xuICAgIGlmIChkZXNjZW5kYW50Ll90eXBlICE9PSBzY2hlbWEuYmxvY2submFtZSkge1xuICAgICAgYmxvY2tzW2Jsb2NrSW5kZXhdID0ge1xuICAgICAgICBfa2V5OiBkZXNjZW5kYW50Ll9rZXksXG4gICAgICAgIF90eXBlOiBkZXNjZW5kYW50Ll90eXBlLFxuICAgICAgICAuLi5cInZhbHVlXCIgaW4gZGVzY2VuZGFudCAmJiB0eXBlb2YgZGVzY2VuZGFudC52YWx1ZSA9PSBcIm9iamVjdFwiID8gZGVzY2VuZGFudC52YWx1ZSA6IHt9XG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gXCJjaGlsZHJlblwiIGluIGRlc2NlbmRhbnQgPyBkZXNjZW5kYW50LmNoaWxkcmVuIDogW10sIHByb2Nlc3NlZENoaWxkcmVuID0gbmV3IEFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCBjaGlsZHJlbi5sZW5ndGg7IGNoaWxkSW5kZXgrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltjaGlsZEluZGV4XTtcbiAgICAgIHByb2Nlc3NlZENoaWxkcmVuW2NoaWxkSW5kZXhdID0gY2hpbGQuX3R5cGUgPT09IHNjaGVtYS5zcGFuLm5hbWUgPyBjaGlsZCA6IHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleSxcbiAgICAgICAgX3R5cGU6IGNoaWxkLl90eXBlLFxuICAgICAgICAuLi5cInZhbHVlXCIgaW4gY2hpbGQgJiYgdHlwZW9mIGNoaWxkLnZhbHVlID09IFwib2JqZWN0XCIgPyBjaGlsZC52YWx1ZSA6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBibG9ja3NbYmxvY2tJbmRleF0gPSB7XG4gICAgICAuLi5kZXNjZW5kYW50LFxuICAgICAgY2hpbGRyZW46IHByb2Nlc3NlZENoaWxkcmVuXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRGVjb3JhdG9ycyh7XG4gIHNjaGVtYSxcbiAgc2xhdGVFZGl0b3JJbnN0YW5jZVxufSkge1xuICBjb25zdCBkZWNvcmF0b3JzID0gc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5uYW1lKTtcbiAgcmV0dXJuICh7XG4gICAgLi4uRWRpdG9yLm1hcmtzKHNsYXRlRWRpdG9ySW5zdGFuY2UpID8/IHt9XG4gIH0ubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3JTbmFwc2hvdCh7XG4gIGNvbnZlcnRlcnMsXG4gIGVkaXRvcixcbiAga2V5R2VuZXJhdG9yLFxuICByZWFkT25seSxcbiAgc2NoZW1hLFxuICBoYXNUYWcsXG4gIGludGVybmFsRHJhZ1xufSkge1xuICBjb25zdCB2YWx1ZSA9IHNsYXRlQ2hpbGRyZW5Ub0Jsb2NrcyhzY2hlbWEsIGVkaXRvci5jaGlsZHJlbiksIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgIHNjaGVtYSxcbiAgICBlZGl0b3IsXG4gICAgcmFuZ2U6IGVkaXRvci5zZWxlY3Rpb25cbiAgfSkgOiBudWxsO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIGFjdGl2ZURlY29yYXRvcnM6IGdldEFjdGl2ZURlY29yYXRvcnMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2U6IGVkaXRvclxuICAgICAgfSksXG4gICAgICBjb252ZXJ0ZXJzLFxuICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgcmVhZE9ubHksXG4gICAgICBzY2hlbWEsXG4gICAgICBzZWxlY3Rpb24sXG4gICAgICB2YWx1ZVxuICAgIH0sXG4gICAgYmV0YToge1xuICAgICAgaGFzVGFnLFxuICAgICAgaW50ZXJuYWxEcmFnXG4gICAgfVxuICB9O1xufVxuY29uc3QgZGVidWckNyA9IGRlYnVnV2l0aE5hbWUoXCJlZGl0b3IgbWFjaGluZVwiKSwgZWRpdG9yTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICB0YWdzOiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJhZGQgYmVoYXZpb3IgdG8gY29udGV4dFwiOiBhc3NpZ24oe1xuICAgICAgYmVoYXZpb3JzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcImFkZCBiZWhhdmlvclwiKSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmNvbnRleHQuYmVoYXZpb3JzLCBldmVudC5iZWhhdmlvckNvbmZpZ10pKVxuICAgIH0pLFxuICAgIFwicmVtb3ZlIGJlaGF2aW9yIGZyb20gY29udGV4dFwiOiBhc3NpZ24oe1xuICAgICAgYmVoYXZpb3JzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInJlbW92ZSBiZWhhdmlvclwiKSwgY29udGV4dC5iZWhhdmlvcnMuZGVsZXRlKGV2ZW50LmJlaGF2aW9yQ29uZmlnKSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmNvbnRleHQuYmVoYXZpb3JzXSkpXG4gICAgfSksXG4gICAgXCJhc3NpZ24gc2NoZW1hXCI6IGFzc2lnbih7XG4gICAgICBzY2hlbWE6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHNjaGVtYVwiKSwgZXZlbnQuc2NoZW1hKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwYXRjaCBldmVudFwiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgZXZlbnQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFwiaW50ZXJuYWwucGF0Y2hcIiksIGVucXVldWUuZW1pdChldmVudCksIGVucXVldWUuZW1pdCh7XG4gICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgcGF0Y2g6IGV2ZW50LnBhdGNoXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBcImVtaXQgbXV0YXRpb24gZXZlbnRcIjogZW1pdCgoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibXV0YXRpb25cIiksIGV2ZW50KSksXG4gICAgXCJlbWl0IHJlYWQgb25seVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwicmVhZCBvbmx5XCJcbiAgICB9KSxcbiAgICBcImVtaXQgZWRpdGFibGVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImVkaXRhYmxlXCJcbiAgICB9KSxcbiAgICBcImRlZmVyIGV2ZW50XCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nRXZlbnRzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBbXCJpbnRlcm5hbC5wYXRjaFwiLCBcIm11dGF0aW9uXCJdKSwgWy4uLmNvbnRleHQucGVuZGluZ0V2ZW50cywgZXZlbnRdKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwZW5kaW5nIGV2ZW50c1wiOiBlbnF1ZXVlQWN0aW9ucygoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQucGVuZGluZ0V2ZW50cylcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gXCJpbnRlcm5hbC5wYXRjaFwiID8gKGVucXVldWUuZW1pdChldmVudCksIGVucXVldWUuZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgICAgIHBhdGNoOiBldmVudC5wYXRjaFxuICAgICAgICB9KSkgOiBlbnF1ZXVlLmVtaXQoZXZlbnQpO1xuICAgIH0pLFxuICAgIFwiZW1pdCByZWFkeVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwicmVhZHlcIlxuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdFdmVudHM6IFtdXG4gICAgfSksXG4gICAgXCJkZWZlciBpbmNvbWluZyBwYXRjaGVzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nSW5jb21pbmdQYXRjaGVzRXZlbnRzOiAoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQudHlwZSA9PT0gXCJwYXRjaGVzXCIgPyBbLi4uY29udGV4dC5wZW5kaW5nSW5jb21pbmdQYXRjaGVzRXZlbnRzLCBldmVudF0gOiBjb250ZXh0LnBlbmRpbmdJbmNvbWluZ1BhdGNoZXNFdmVudHNcbiAgICB9KSxcbiAgICBcImVtaXQgcGVuZGluZyBpbmNvbWluZyBwYXRjaGVzXCI6IGVucXVldWVBY3Rpb25zKCh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZW5xdWV1ZVxuICAgIH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5wZW5kaW5nSW5jb21pbmdQYXRjaGVzRXZlbnRzKVxuICAgICAgICBlbnF1ZXVlLmVtaXQoZXZlbnQpO1xuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBpbmNvbWluZyBwYXRjaGVzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nSW5jb21pbmdQYXRjaGVzRXZlbnRzOiBbXVxuICAgIH0pLFxuICAgIFwiaGFuZGxlIGJsdXJcIjogKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFwiYmx1clwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIFJlYWN0RWRpdG9yLmJsdXIoZXZlbnQuZWRpdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gYmx1ciBlZGl0b3I6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImhhbmRsZSBmb2N1c1wiOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IHtcbiAgICAgIGlmICghY29udGV4dC5zbGF0ZUVkaXRvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gU2xhdGUgZWRpdG9yIGZvdW5kIHRvIGZvY3VzXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gY29udGV4dC5zbGF0ZUVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGNvbnRleHQuc2xhdGVFZGl0b3IpLCBjdXJyZW50U2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuc2VsZWN0KGNvbnRleHQuc2xhdGVFZGl0b3IsIGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBmb2N1cyBlZGl0b3I6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImhhbmRsZSBiZWhhdmlvciBldmVudFwiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50LFxuICAgICAgc2VsZlxuICAgIH0pID0+IHtcbiAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBbXCJiZWhhdmlvciBldmVudFwiXSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBiZWhhdmlvcnMgPSBzb3J0QnlQcmlvcml0eShbLi4uY29udGV4dC5iZWhhdmlvcnMudmFsdWVzKCksIC4uLmNvcmVCZWhhdmlvcnNDb25maWddKS5tYXAoKGNvbmZpZykgPT4gY29uZmlnLmJlaGF2aW9yKTtcbiAgICAgICAgcGVyZm9ybUV2ZW50KHtcbiAgICAgICAgICBtb2RlOiBcInJhaXNlXCIsXG4gICAgICAgICAgYmVoYXZpb3JzLFxuICAgICAgICAgIHJlbWFpbmluZ0V2ZW50QmVoYXZpb3JzOiBiZWhhdmlvcnMsXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LmJlaGF2aW9yRXZlbnQsXG4gICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3IsXG4gICAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgIGdldFNuYXBzaG90OiAoKSA9PiBjcmVhdGVFZGl0b3JTbmFwc2hvdCh7XG4gICAgICAgICAgICBjb252ZXJ0ZXJzOiBbLi4uY29udGV4dC5jb252ZXJ0ZXJzXSxcbiAgICAgICAgICAgIGVkaXRvcjogZXZlbnQuZWRpdG9yLFxuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHJlYWRPbmx5OiBzZWxmLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICAgIGhhc1RhZzogKHRhZykgPT4gc2VsZi5nZXRTbmFwc2hvdCgpLmhhc1RhZyh0YWcpLFxuICAgICAgICAgICAgaW50ZXJuYWxEcmFnOiBjb250ZXh0LmludGVybmFsRHJhZ1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudC5uYXRpdmVFdmVudFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBSYWlzaW5nIFwiJHtldmVudC5iZWhhdmlvckV2ZW50LnR5cGV9XCIgZmFpbGVkIGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwic2xhdGUgaXMgYnVzeVwiOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IGNvbnRleHQuc2xhdGVFZGl0b3IgPyBjb250ZXh0LnNsYXRlRWRpdG9yLm9wZXJhdGlvbnMubGVuZ3RoID4gMCA6ICExXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJlZGl0b3JcIixcbiAgY29udGV4dDogKHtcbiAgICBpbnB1dFxuICB9KSA9PiAoe1xuICAgIGJlaGF2aW9yczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pLFxuICAgIGNvbnZlcnRlcnM6IG5ldyBTZXQoaW5wdXQuY29udmVydGVycyA/PyBbXSksXG4gICAgZ2V0TGVnYWN5U2NoZW1hOiBpbnB1dC5nZXRMZWdhY3lTY2hlbWEsXG4gICAga2V5R2VuZXJhdG9yOiBpbnB1dC5rZXlHZW5lcmF0b3IsXG4gICAgcGVuZGluZ0V2ZW50czogW10sXG4gICAgcGVuZGluZ0luY29taW5nUGF0Y2hlc0V2ZW50czogW10sXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIGluaXRpYWxSZWFkT25seTogaW5wdXQucmVhZE9ubHkgPz8gITEsXG4gICAgbWF4QmxvY2tzOiBpbnB1dC5tYXhCbG9ja3MsXG4gICAgaW5pdGlhbFZhbHVlOiBpbnB1dC5pbml0aWFsVmFsdWVcbiAgfSksXG4gIG9uOiB7XG4gICAgXCJub3RpZnkuYmx1cnJlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoe1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJibHVycmVkXCJcbiAgICAgIH0pKVxuICAgIH0sXG4gICAgXCJub3RpZnkuZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcImRvbmUgbG9hZGluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJub3RpZnkuZXJyb3JcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5pbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5mb2N1c2VkXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICB0eXBlOiBcImZvY3VzZWRcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5zZWxlY3Rpb25cIjoge1xuICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgIHNlbGVjdGlvbjogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5zZWxlY3Rpb25cbiAgICAgIH0pLCBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoe1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIlxuICAgICAgfSkpXVxuICAgIH0sXG4gICAgXCJub3RpZnkudW5zZXRcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwidW5zZXRcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBcIm5vdGlmeS5sb2FkaW5nXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgfSlcbiAgICB9LFxuICAgIFwibm90aWZ5LnZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIHR5cGU6IFwidmFsdWUgY2hhbmdlZFwiXG4gICAgICB9KSlcbiAgICB9LFxuICAgIFwiYWRkIGJlaGF2aW9yXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYWRkIGJlaGF2aW9yIHRvIGNvbnRleHRcIlxuICAgIH0sXG4gICAgXCJyZW1vdmUgYmVoYXZpb3JcIjoge1xuICAgICAgYWN0aW9uczogXCJyZW1vdmUgYmVoYXZpb3IgZnJvbSBjb250ZXh0XCJcbiAgICB9LFxuICAgIFwidXBkYXRlIGtleSBnZW5lcmF0b3JcIjoge1xuICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAgICAgICAga2V5R2VuZXJhdG9yOiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50LmtleUdlbmVyYXRvclxuICAgICAgfSlcbiAgICB9LFxuICAgIFwidXBkYXRlIHNjaGVtYVwiOiB7XG4gICAgICBhY3Rpb25zOiBcImFzc2lnbiBzY2hlbWFcIlxuICAgIH0sXG4gICAgXCJ1cGRhdGUgbWF4QmxvY2tzXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIG1heEJsb2NrczogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5tYXhCbG9ja3NcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB0eXBlOiBcInBhcmFsbGVsXCIsXG4gIHN0YXRlczoge1xuICAgIFwiZWRpdCBtb2RlXCI6IHtcbiAgICAgIGluaXRpYWw6IFwicmVhZCBvbmx5XCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJyZWFkIG9ubHlcIjoge1xuICAgICAgICAgIGluaXRpYWw6IFwiZGV0ZXJtaW5lIGluaXRpYWwgZWRpdCBtb2RlXCIsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwiYmVoYXZpb3IgZXZlbnRcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImhhbmRsZSBiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwiY2xpcGJvYXJkLmNvcHlcIiB8fCBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwibW91c2UuY2xpY2tcIiB8fCBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwic2VyaWFsaXplXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcInNlcmlhbGl6YXRpb24uZmFpbHVyZVwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJzZXJpYWxpemF0aW9uLnN1Y2Nlc3NcIiB8fCBldmVudC5iZWhhdmlvckV2ZW50LnR5cGUgPT09IFwic2VsZWN0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgXCJkZXRlcm1pbmUgaW5pdGlhbCBlZGl0IG1vZGVcIjoge1xuICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ3KFwiZW50cnk6IGVkaXQgbW9kZS0+cmVhZCBvbmx5LT5kZXRlcm1pbmUgaW5pdGlhbCBlZGl0IG1vZGVcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBlZGl0IG1vZGUtPnJlYWQgb25seS0+ZGV0ZXJtaW5lIGluaXRpYWwgZWRpdCBtb2RlXCIpO1xuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcImRvbmUgc3luY2luZyB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgICAgIGd1YXJkOiAoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxSZWFkT25seVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVhZCBvbmx5XCI6IHtcbiAgICAgICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWckNyhcImVudHJ5OiBlZGl0IG1vZGUtPnJlYWQgb25seS0+cmVhZCBvbmx5XCIpO1xuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ3KFwiZXhpdDogZWRpdCBtb2RlLT5yZWFkIG9ubHktPnJlYWQgb25seVwiKTtcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgXCJ1cGRhdGUgcmVhZE9ubHlcIjoge1xuICAgICAgICAgICAgICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgICB9KSA9PiAhZXZlbnQucmVhZE9ubHksXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5lZGl0IG1vZGUuZWRpdGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcImVtaXQgZWRpdGFibGVcIl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRhYmxlOiB7XG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwidXBkYXRlIHJlYWRPbmx5XCI6IHtcbiAgICAgICAgICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQucmVhZE9ubHksXG4gICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5yZWFkIG9ubHkucmVhZCBvbmx5XCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImVtaXQgcmVhZCBvbmx5XCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiZWhhdmlvciBldmVudFwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiaGFuZGxlIGJlaGF2aW9yIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiaGFuZGxlIGJsdXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCIuZm9jdXNpbmdcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgc2xhdGVFZGl0b3I6ICh7XG4gICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgIH0pID0+IGV2ZW50LmVkaXRvclxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgaWRsZToge1xuICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQ3KFwiZW50cnk6IGVkaXQgbW9kZS0+ZWRpdGFibGUtPmlkbGVcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBlZGl0IG1vZGUtPmVkaXRhYmxlLWlkbGVcIik7XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGRyYWdzdGFydDoge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsRHJhZzogKHtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgIGdob3N0OiBldmVudC5naG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGV2ZW50Lm9yaWdpblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSldLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImRyYWdnaW5nIGludGVybmFsbHlcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzaW5nOiB7XG4gICAgICAgICAgICAgIGluaXRpYWw6IFwiY2hlY2tpbmcgaWYgYnVzeVwiLFxuICAgICAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgICAgICBcImNoZWNraW5nIGlmIGJ1c3lcIjoge1xuICAgICAgICAgICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJlbnRyeTogZWRpdCBtb2RlLT5lZGl0YWJsZS0+Zm9jdXNpbmctPmNoZWNraW5nIGlmIGJ1c3lcIik7XG4gICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBlZGl0IG1vZGUtPmVkaXRhYmxlLT5mb2N1c2luZy0+Y2hlY2tpbmcgaWYgYnVzeVwiKTtcbiAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgYWx3YXlzOiBbe1xuICAgICAgICAgICAgICAgICAgICBndWFyZDogXCJzbGF0ZSBpcyBidXN5XCIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJidXN5XCJcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLmVkaXRhYmxlLmlkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wiaGFuZGxlIGZvY3VzXCJdXG4gICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYnVzeToge1xuICAgICAgICAgICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJlbnRyeTogZWRpdCBtb2RlLT5lZGl0YWJsZS0+Zm9jdXNpbmctYnVzeVwiKTtcbiAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckNyhcImV4aXQ6IGVkaXQgbW9kZS0+ZWRpdGFibGUtPmZvY3VzaW5nLT5idXN5XCIpO1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBhZnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAxMDoge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJjaGVja2luZyBpZiBidXN5XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZHJhZ2dpbmcgaW50ZXJuYWxseVwiOiB7XG4gICAgICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJlbnRyeTogZWRpdCBtb2RlLT5lZGl0YWJsZS0+ZHJhZ2dpbmcgaW50ZXJuYWxseVwiKTtcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWckNyhcImV4aXQ6IGVkaXQgbW9kZS0+ZWRpdGFibGUtPmRyYWdnaW5nIGludGVybmFsbHlcIik7XG4gICAgICAgICAgICAgIH0sICh7XG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW50ZXJuYWxEcmFnPy5naG9zdClcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW50ZXJuYWxEcmFnLmdob3N0LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKGNvbnRleHQuaW50ZXJuYWxEcmFnLmdob3N0KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBSZW1vdmluZyB0aGUgaW50ZXJuYWwgZHJhZyBnaG9zdCBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBhc3NpZ24oe1xuICAgICAgICAgICAgICAgIGludGVybmFsRHJhZzogdm9pZCAwXG4gICAgICAgICAgICAgIH0pXSxcbiAgICAgICAgICAgICAgdGFnczogW1wiZHJhZ2dpbmcgaW50ZXJuYWxseVwiXSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBkcmFnZW5kOiB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkcm9wOiB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXR1cDoge1xuICAgICAgaW5pdGlhbDogXCJzZXR0aW5nIHVwXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJzZXR0aW5nIHVwXCI6IHtcbiAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDcoXCJlbnRyeTogc2V0dXAtPnNldHRpbmcgdXBcIik7XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBzZXR1cC0+c2V0dGluZyB1cFwiKTtcbiAgICAgICAgICB9LCBcImVtaXQgcmVhZHlcIiwgXCJlbWl0IHBlbmRpbmcgaW5jb21pbmcgcGF0Y2hlc1wiLCBcImNsZWFyIHBlbmRpbmcgaW5jb21pbmcgcGF0Y2hlc1wiXSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJpbnRlcm5hbC5wYXRjaFwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZG9uZSBzeW5jaW5nIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInNldCB1cFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0Y2hlczoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBpbmNvbWluZyBwYXRjaGVzXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNldCB1cFwiOiB7XG4gICAgICAgICAgdHlwZTogXCJwYXJhbGxlbFwiLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgXCJ2YWx1ZSBzeW5jXCI6IHtcbiAgICAgICAgICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgICAgIGlkbGU6IHtcbiAgICAgICAgICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ3KFwiZW50cnk6IHNldHVwLT5zZXQgdXAtPnZhbHVlIHN5bmMtPmlkbGVcIik7XG4gICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBzZXR1cC0+c2V0IHVwLT52YWx1ZSBzeW5jLT5pZGxlXCIpO1xuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW2VtaXQoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInN5bmNpbmcgdmFsdWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJzeW5jaW5nIHZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzeW5jaW5nIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyQ3KFwiZW50cnk6IHNldHVwLT5zZXQgdXAtPnZhbHVlIHN5bmMtPnN5bmNpbmcgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBzZXR1cC0+c2V0IHVwLT52YWx1ZSBzeW5jLT5zeW5jaW5nIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgfSwgXCJlbWl0IHBlbmRpbmcgaW5jb21pbmcgcGF0Y2hlc1wiLCBcImNsZWFyIHBlbmRpbmcgaW5jb21pbmcgcGF0Y2hlc1wiXSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBpbmNvbWluZyBwYXRjaGVzXCJdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiZG9uZSBzeW5jaW5nIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0aW5nOiB7XG4gICAgICAgICAgICAgIGluaXRpYWw6IFwicHJpc3RpbmVcIixcbiAgICAgICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICAgICAgcHJpc3RpbmU6IHtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJlbnRyeTogc2V0dXAtPnNldCB1cC0+d3JpdGluZy0+cHJpc3RpbmUtPmlkbGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBzZXR1cC0+c2V0IHVwLT53cml0aW5nLT5wcmlzdGluZS0+aWRsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsLnBhdGNoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5zZXR1cC5zZXQgdXAud3JpdGluZy5kaXJ0eVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5zZXR1cC5zZXQgdXAud3JpdGluZy5kaXJ0eVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemluZzoge1xuICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWckNyhcImVudHJ5OiBzZXR1cC0+c2V0IHVwLT53cml0aW5nLT5wcmlzdGluZS0+bm9ybWFsaXppbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBzZXR1cC0+c2V0IHVwLT53cml0aW5nLT5wcmlzdGluZS0+bm9ybWFsaXppbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZG9uZSBub3JtYWxpemluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsLnBhdGNoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXJ0eToge1xuICAgICAgICAgICAgICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJlbnRyeTogc2V0dXAtPnNldCB1cC0+d3JpdGluZy0+ZGlydHlcIik7XG4gICAgICAgICAgICAgICAgICB9LCBcImVtaXQgcGVuZGluZyBldmVudHNcIiwgXCJjbGVhciBwZW5kaW5nIGV2ZW50c1wiXSxcbiAgICAgICAgICAgICAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDcoXCJleGl0OiBzZXR1cC0+c2V0IHVwLT53cml0aW5nLT5kaXJ0eVwiKTtcbiAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbC5wYXRjaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJlbWl0IHBhdGNoIGV2ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBcImVtaXQgbXV0YXRpb24gZXZlbnRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVNjaGVtYShwb3J0YWJsZVRleHRUeXBlKSB7XG4gIGlmICghcG9ydGFibGVUZXh0VHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgJ3BvcnRhYmxldGV4dFR5cGUnIG1pc3NpbmcgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgYmxvY2tUeXBlID0gcG9ydGFibGVUZXh0VHlwZS5vZj8uZmluZChmaW5kQmxvY2tUeXBlKTtcbiAgaWYgKCFibG9ja1R5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgdHlwZSBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBjaGlsZHJlbkZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcz8uZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IFwiY2hpbGRyZW5cIik7XG4gIGlmICghY2hpbGRyZW5GaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZHJlbiBmaWVsZCBmb3IgYmxvY2sgdHlwZSBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3Qgb2ZUeXBlID0gY2hpbGRyZW5GaWVsZC50eXBlLm9mO1xuICBpZiAoIW9mVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZCB0eXBlcyBmb3IgYmxvY2sgY2hpbGRyZW4gbm90IGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBzcGFuVHlwZSA9IG9mVHlwZS5maW5kKChtZW1iZXJUeXBlKSA9PiBtZW1iZXJUeXBlLm5hbWUgPT09IFwic3BhblwiKTtcbiAgaWYgKCFzcGFuVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGFuIHR5cGUgbm90IGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBpbmxpbmVPYmplY3RUeXBlcyA9IG9mVHlwZS5maWx0ZXIoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSAhPT0gXCJzcGFuXCIpIHx8IFtdLCBibG9ja09iamVjdFR5cGVzID0gcG9ydGFibGVUZXh0VHlwZS5vZj8uZmlsdGVyKChmaWVsZCkgPT4gZmllbGQubmFtZSAhPT0gYmxvY2tUeXBlLm5hbWUpIHx8IFtdO1xuICByZXR1cm4ge1xuICAgIHN0eWxlczogcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSxcbiAgICBkZWNvcmF0b3JzOiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpLFxuICAgIGxpc3RzOiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpLFxuICAgIGJsb2NrOiBibG9ja1R5cGUsXG4gICAgc3Bhbjogc3BhblR5cGUsXG4gICAgcG9ydGFibGVUZXh0OiBwb3J0YWJsZVRleHRUeXBlLFxuICAgIGlubGluZU9iamVjdHM6IGlubGluZU9iamVjdFR5cGVzLFxuICAgIGJsb2NrT2JqZWN0czogYmxvY2tPYmplY3RUeXBlcyxcbiAgICBhbm5vdGF0aW9uczogc3BhblR5cGUuYW5ub3RhdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSkge1xuICBjb25zdCBzdHlsZUZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcz8uZmluZCgoYnRGaWVsZCkgPT4gYnRGaWVsZC5uYW1lID09PSBcInN0eWxlXCIpO1xuICBpZiAoIXN0eWxlRmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmaWVsZCB3aXRoIG5hbWUgJ3N0eWxlJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3QgdGV4dFN0eWxlcyA9IHN0eWxlRmllbGQudHlwZS5vcHRpb25zPy5saXN0ICYmIHN0eWxlRmllbGQudHlwZS5vcHRpb25zLmxpc3Q/LmZpbHRlcigoc3R5bGUpID0+IHN0eWxlLnZhbHVlKTtcbiAgaWYgKCF0ZXh0U3R5bGVzIHx8IHRleHRTdHlsZXMubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZSBmaWVsZHMgbmVlZCBhdCBsZWFzdCBvbmUgc3R5bGUgZGVmaW5lZC4gSS5lOiB7dGl0bGU6ICdOb3JtYWwnLCB2YWx1ZTogJ25vcm1hbCd9LlwiKTtcbiAgcmV0dXJuIHRleHRTdHlsZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpIHtcbiAgcmV0dXJuIHNwYW5UeXBlLmRlY29yYXRvcnM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpIHtcbiAgY29uc3QgbGlzdEZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcz8uZmluZCgoYnRGaWVsZCkgPT4gYnRGaWVsZC5uYW1lID09PSBcImxpc3RJdGVtXCIpO1xuICBpZiAoIWxpc3RGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGZpZWxkIHdpdGggbmFtZSAnbGlzdEl0ZW0nIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBibG9jayB0eXBlIChyZXF1aXJlZCkuXCIpO1xuICBjb25zdCBsaXN0SXRlbXMgPSBsaXN0RmllbGQudHlwZS5vcHRpb25zPy5saXN0ICYmIGxpc3RGaWVsZC50eXBlLm9wdGlvbnMubGlzdC5maWx0ZXIoKGxpc3QpID0+IGxpc3QudmFsdWUpO1xuICBpZiAoIWxpc3RJdGVtcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGlzdCBmaWVsZCBuZWVkIGF0IGxlYXN0IHRvIGJlIGFuIGVtcHR5IGFycmF5XCIpO1xuICByZXR1cm4gbGlzdEl0ZW1zO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPyBmaW5kQmxvY2tUeXBlKHR5cGUudHlwZSkgOiB0eXBlLm5hbWUgPT09IFwiYmxvY2tcIiA/IHR5cGUgOiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGRlZmluaXRpb247XG59XG5jb25zdCB0ZW1wb3JhcnlJbWFnZU5hbWUgPSBgdG1wLSR7ZGVmYXVsdEtleUdlbmVyYXRvcigpfS1pbWFnZWAsIHRlbXBvcmFyeVVybE5hbWUgPSBgdG1wLSR7ZGVmYXVsdEtleUdlbmVyYXRvcigpfS11cmxgLCB0ZW1wb3JhcnlPYmplY3ROYW1lcyA9IHtcbiAgaW1hZ2U6IHRlbXBvcmFyeUltYWdlTmFtZSxcbiAgdXJsOiB0ZW1wb3JhcnlVcmxOYW1lXG59LCBvYmplY3ROYW1lcyA9IHtcbiAgW3RlbXBvcmFyeUltYWdlTmFtZV06IFwiaW1hZ2VcIixcbiAgW3RlbXBvcmFyeVVybE5hbWVdOiBcInVybFwiXG59LCBkZWZhdWx0T2JqZWN0VGl0bGVzID0ge1xuICBpbWFnZTogXCJJbWFnZVwiLFxuICB1cmw6IFwiVVJMXCJcbn07XG5mdW5jdGlvbiBsZWdhY3lTY2hlbWFUb0VkaXRvclNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uczogc2NoZW1hLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICAgIG5hbWU6IGFubm90YXRpb24ubmFtZSxcbiAgICAgIGZpZWxkczogYW5ub3RhdGlvbi5maWVsZHMubWFwKChmaWVsZCkgPT4gKHtcbiAgICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgdHlwZTogZmllbGQudHlwZS5qc29uVHlwZVxuICAgICAgfSkpLFxuICAgICAgdGl0bGU6IGFubm90YXRpb24udGl0bGVcbiAgICB9KSksXG4gICAgYmxvY2s6IHtcbiAgICAgIG5hbWU6IHNjaGVtYS5ibG9jay5uYW1lXG4gICAgfSxcbiAgICBibG9ja09iamVjdHM6IHNjaGVtYS5ibG9ja09iamVjdHMubWFwKChibG9ja09iamVjdCkgPT4gKHtcbiAgICAgIG5hbWU6IGJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgICBmaWVsZHM6IGJsb2NrT2JqZWN0LmZpZWxkcy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICB0eXBlOiBmaWVsZC50eXBlLmpzb25UeXBlXG4gICAgICB9KSksXG4gICAgICB0aXRsZTogYmxvY2tPYmplY3QudGl0bGVcbiAgICB9KSksXG4gICAgZGVjb3JhdG9yczogc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+ICh7XG4gICAgICBuYW1lOiBkZWNvcmF0b3IudmFsdWUsXG4gICAgICB0aXRsZTogZGVjb3JhdG9yLnRpdGxlLFxuICAgICAgdmFsdWU6IGRlY29yYXRvci52YWx1ZVxuICAgIH0pKSxcbiAgICBpbmxpbmVPYmplY3RzOiBzY2hlbWEuaW5saW5lT2JqZWN0cy5tYXAoKGlubGluZU9iamVjdCkgPT4gKHtcbiAgICAgIG5hbWU6IGlubGluZU9iamVjdC5uYW1lLFxuICAgICAgZmllbGRzOiBpbmxpbmVPYmplY3QuZmllbGRzLm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIHR5cGU6IGZpZWxkLnR5cGUuanNvblR5cGVcbiAgICAgIH0pKSxcbiAgICAgIHRpdGxlOiBpbmxpbmVPYmplY3QudGl0bGVcbiAgICB9KSksXG4gICAgc3Bhbjoge1xuICAgICAgbmFtZTogc2NoZW1hLnNwYW4ubmFtZVxuICAgIH0sXG4gICAgc3R5bGVzOiBzY2hlbWEuc3R5bGVzLm1hcCgoc3R5bGUpID0+ICh7XG4gICAgICBuYW1lOiBzdHlsZS52YWx1ZSxcbiAgICAgIHRpdGxlOiBzdHlsZS50aXRsZSxcbiAgICAgIHZhbHVlOiBzdHlsZS52YWx1ZVxuICAgIH0pKSxcbiAgICBsaXN0czogc2NoZW1hLmxpc3RzLm1hcCgobGlzdCkgPT4gKHtcbiAgICAgIG5hbWU6IGxpc3QudmFsdWUsXG4gICAgICB0aXRsZTogbGlzdC50aXRsZSxcbiAgICAgIHZhbHVlOiBsaXN0LnZhbHVlXG4gICAgfSkpXG4gIH07XG59XG5mdW5jdGlvbiBjb21waWxlU2NoZW1hRGVmaW5pdGlvblRvTGVnYWN5U2NoZW1hKGRlZmluaXRpb24pIHtcbiAgY29uc3QgYmxvY2tPYmplY3RzID0gZGVmaW5pdGlvbj8uYmxvY2tPYmplY3RzPy5tYXAoKGJsb2NrT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIC8vIFZlcnkgbmFpdmUgd2F5IHRvIHdvcmsgYXJvdW5kIGBTYW5pdHlTY2hlbWEuY29tcGlsZWAgYWRkaW5nIGRlZmF1bHRcbiAgICAvLyBmaWVsZHMgdG8gb2JqZWN0cyB3aXRoIGNlcnRhaW4gbmFtZXMuXG4gICAgbmFtZTogdGVtcG9yYXJ5T2JqZWN0TmFtZXNbYmxvY2tPYmplY3QubmFtZV0gPz8gYmxvY2tPYmplY3QubmFtZSxcbiAgICB0aXRsZTogYmxvY2tPYmplY3QudGl0bGUgPT09IHZvaWQgMCA/IChcbiAgICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBkZWZhdWx0IHRpdGxlIHdoaWNoIGlzIGEgdGl0bGUgY2FzZSBvZiB0aGUgb2JqZWN0IG5hbWVcbiAgICAgIGRlZmF1bHRPYmplY3RUaXRsZXNbYmxvY2tPYmplY3QubmFtZV1cbiAgICApIDogYmxvY2tPYmplY3QudGl0bGUsXG4gICAgZmllbGRzOiBibG9ja09iamVjdC5maWVsZHM/Lm1hcCgoZmllbGQpID0+ICh7XG4gICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgdHlwZTogZmllbGQudHlwZVxuICAgIH0pKSA/PyBbXVxuICB9KSkgPz8gW10sIGlubGluZU9iamVjdHMgPSBkZWZpbml0aW9uPy5pbmxpbmVPYmplY3RzPy5tYXAoKGlubGluZU9iamVjdCkgPT4gZGVmaW5lVHlwZSh7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAvLyBWZXJ5IG5haXZlIHdheSB0byB3b3JrIGFyb3VuZCBgU2FuaXR5U2NoZW1hLmNvbXBpbGVgIGFkZGluZyBkZWZhdWx0XG4gICAgLy8gZmllbGRzIHRvIG9iamVjdHMgd2l0aCBjZXJ0YWluIG5hbWVzLlxuICAgIG5hbWU6IHRlbXBvcmFyeU9iamVjdE5hbWVzW2lubGluZU9iamVjdC5uYW1lXSA/PyBpbmxpbmVPYmplY3QubmFtZSxcbiAgICB0aXRsZTogaW5saW5lT2JqZWN0LnRpdGxlID09PSB2b2lkIDAgPyAoXG4gICAgICAvLyBUaGlzIGF2b2lkcyB0aGUgZGVmYXVsdCB0aXRsZSB3aGljaCBpcyBhIHRpdGxlIGNhc2Ugb2YgdGhlIG9iamVjdCBuYW1lXG4gICAgICBkZWZhdWx0T2JqZWN0VGl0bGVzW2lubGluZU9iamVjdC5uYW1lXVxuICAgICkgOiBpbmxpbmVPYmplY3QudGl0bGUsXG4gICAgZmllbGRzOiBpbmxpbmVPYmplY3QuZmllbGRzPy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgIHR5cGU6IGZpZWxkLnR5cGVcbiAgICB9KSkgPz8gW11cbiAgfSkpID8/IFtdLCBwb3J0YWJsZVRleHRTY2hlbWEgPSBkZWZpbmVGaWVsZCh7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG5hbWU6IFwicG9ydGFibGUtdGV4dFwiLFxuICAgIG9mOiBbLi4uYmxvY2tPYmplY3RzLm1hcCgoYmxvY2tPYmplY3QpID0+ICh7XG4gICAgICB0eXBlOiBibG9ja09iamVjdC5uYW1lXG4gICAgfSkpLCB7XG4gICAgICB0eXBlOiBcImJsb2NrXCIsXG4gICAgICBuYW1lOiBcImJsb2NrXCIsXG4gICAgICBvZjogaW5saW5lT2JqZWN0cy5tYXAoKGlubGluZU9iamVjdCkgPT4gKHtcbiAgICAgICAgdHlwZTogaW5saW5lT2JqZWN0Lm5hbWVcbiAgICAgIH0pKSxcbiAgICAgIG1hcmtzOiB7XG4gICAgICAgIGRlY29yYXRvcnM6IGRlZmluaXRpb24/LmRlY29yYXRvcnM/Lm1hcCgoZGVjb3JhdG9yKSA9PiAoe1xuICAgICAgICAgIHRpdGxlOiBkZWNvcmF0b3IudGl0bGUgPz8gc3RhcnRDYXNlKGRlY29yYXRvci5uYW1lKSxcbiAgICAgICAgICB2YWx1ZTogZGVjb3JhdG9yLm5hbWVcbiAgICAgICAgfSkpID8/IFtdLFxuICAgICAgICBhbm5vdGF0aW9uczogZGVmaW5pdGlvbj8uYW5ub3RhdGlvbnM/Lm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICAgICAgICBuYW1lOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICB0aXRsZTogYW5ub3RhdGlvbi50aXRsZSxcbiAgICAgICAgICBmaWVsZHM6IGFubm90YXRpb24uZmllbGRzPy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IGZpZWxkLnR5cGVcbiAgICAgICAgICB9KSkgPz8gW11cbiAgICAgICAgfSkpID8/IFtdXG4gICAgICB9LFxuICAgICAgbGlzdHM6IGRlZmluaXRpb24/Lmxpc3RzPy5tYXAoKGxpc3QpID0+ICh7XG4gICAgICAgIHZhbHVlOiBsaXN0Lm5hbWUsXG4gICAgICAgIHRpdGxlOiBsaXN0LnRpdGxlID8/IHN0YXJ0Q2FzZShsaXN0Lm5hbWUpXG4gICAgICB9KSkgPz8gW10sXG4gICAgICBzdHlsZXM6IGRlZmluaXRpb24/LnN0eWxlcz8ubWFwKChzdHlsZSkgPT4gKHtcbiAgICAgICAgdmFsdWU6IHN0eWxlLm5hbWUsXG4gICAgICAgIHRpdGxlOiBzdHlsZS50aXRsZSA/PyBzdGFydENhc2Uoc3R5bGUubmFtZSlcbiAgICAgIH0pKSA/PyBbXVxuICAgIH1dXG4gIH0pLCBzY2hlbWEgPSBTY2hlbWEuY29tcGlsZSh7XG4gICAgdHlwZXM6IFtwb3J0YWJsZVRleHRTY2hlbWEsIC4uLmJsb2NrT2JqZWN0cywgLi4uaW5saW5lT2JqZWN0c11cbiAgfSkuZ2V0KFwicG9ydGFibGUtdGV4dFwiKSwgcHRlU2NoZW1hID0gY3JlYXRlTGVnYWN5U2NoZW1hKHNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgLi4ucHRlU2NoZW1hLFxuICAgIGJsb2NrT2JqZWN0czogcHRlU2NoZW1hLmJsb2NrT2JqZWN0cy5tYXAoKGJsb2NrT2JqZWN0KSA9PiBvYmplY3ROYW1lc1tibG9ja09iamVjdC5uYW1lXSAhPT0gdm9pZCAwID8ge1xuICAgICAgLi4uYmxvY2tPYmplY3QsXG4gICAgICBuYW1lOiBvYmplY3ROYW1lc1tibG9ja09iamVjdC5uYW1lXSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgLi4uYmxvY2tPYmplY3QudHlwZSxcbiAgICAgICAgbmFtZTogb2JqZWN0TmFtZXNbYmxvY2tPYmplY3QubmFtZV1cbiAgICAgIH1cbiAgICB9IDogYmxvY2tPYmplY3QpLFxuICAgIGlubGluZU9iamVjdHM6IHB0ZVNjaGVtYS5pbmxpbmVPYmplY3RzLm1hcCgoaW5saW5lT2JqZWN0KSA9PiBvYmplY3ROYW1lc1tpbmxpbmVPYmplY3QubmFtZV0gIT09IHZvaWQgMCA/IHtcbiAgICAgIC4uLmlubGluZU9iamVjdCxcbiAgICAgIG5hbWU6IG9iamVjdE5hbWVzW2lubGluZU9iamVjdC5uYW1lXVxuICAgIH0gOiBpbmxpbmVPYmplY3QpXG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvciwgdDApIHtcbiAgY29uc3QgJCA9IGMoMyksIGNvbXBhcmUgPSB0MCA9PT0gdm9pZCAwID8gZGVmYXVsdENvbXBhcmUgOiB0MDtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IHNlbGVjdG9yID8gKHQxID0gKGVkaXRvckFjdG9yU25hcHNob3QpID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGdldEVkaXRvclNuYXBzaG90KHtcbiAgICAgIGVkaXRvckFjdG9yU25hcHNob3QsXG4gICAgICBzbGF0ZUVkaXRvckluc3RhbmNlOiBlZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHNuYXBzaG90KTtcbiAgfSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHNlbGVjdG9yLCAkWzJdID0gdDEpIDogdDEgPSAkWzJdLCB1c2VTZWxlY3RvcihlZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCB0MSwgY29tcGFyZSk7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gIGVkaXRvckFjdG9yU25hcHNob3QsXG4gIHNsYXRlRWRpdG9ySW5zdGFuY2Vcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBjb252ZXJ0ZXJzOiBbLi4uZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LmNvbnZlcnRlcnNdLFxuICAgICAgYWN0aXZlRGVjb3JhdG9yczogZ2V0QWN0aXZlRGVjb3JhdG9ycyh7XG4gICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZVxuICAgICAgfSksXG4gICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICByZWFkT25seTogZWRpdG9yQWN0b3JTbmFwc2hvdC5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSksXG4gICAgICBzY2hlbWE6IGVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5zY2hlbWEsXG4gICAgICBzZWxlY3Rpb246IGVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24sXG4gICAgICB2YWx1ZTogc2xhdGVDaGlsZHJlblRvQmxvY2tzKGVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5zY2hlbWEsIHNsYXRlRWRpdG9ySW5zdGFuY2UuY2hpbGRyZW4pXG4gICAgfSxcbiAgICBiZXRhOiB7XG4gICAgICBoYXNUYWc6ICh0YWcpID0+IGVkaXRvckFjdG9yU25hcHNob3QuaGFzVGFnKHRhZyksXG4gICAgICBpbnRlcm5hbERyYWc6IGVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5pbnRlcm5hbERyYWdcbiAgICB9XG4gIH07XG59XG5jb25zdCBtdXRhdGlvbk1hY2hpbmUgPSBzZXR1cCh7XG4gIHR5cGVzOiB7XG4gICAgY29udGV4dDoge30sXG4gICAgZXZlbnRzOiB7fSxcbiAgICBpbnB1dDoge30sXG4gICAgZW1pdHRlZDoge31cbiAgfSxcbiAgYWN0aW9uczoge1xuICAgIFwiZW1pdCBoYXMgcGVuZGluZyBwYXRjaGVzXCI6IGVtaXQoe1xuICAgICAgdHlwZTogXCJoYXMgcGVuZGluZyBwYXRjaGVzXCJcbiAgICB9KSxcbiAgICBcImVtaXQgbXV0YXRpb25zXCI6IGVucXVldWVBY3Rpb25zKCh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZW5xdWV1ZVxuICAgIH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgYnVsayBvZiBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMpXG4gICAgICAgIGVucXVldWUuZW1pdCh7XG4gICAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgICAgIHBhdGNoZXM6IGJ1bGsucGF0Y2hlcyxcbiAgICAgICAgICBzbmFwc2hvdDogYnVsay52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgbXV0YXRpb25zXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nTXV0YXRpb25zOiBbXVxuICAgIH0pLFxuICAgIFwiZGVmZXIgcGF0Y2hcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdNdXRhdGlvbnM6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChhc3NlcnRFdmVudChldmVudCwgXCJwYXRjaFwiKSwgY29udGV4dC5wZW5kaW5nTXV0YXRpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBldmVudC5vcGVyYXRpb25JZCxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgICAgIHBhdGNoZXM6IFtldmVudC5wYXRjaF1cbiAgICAgICAgICB9XTtcbiAgICAgICAgY29uc3QgbGFzdEJ1bGsgPSBjb250ZXh0LnBlbmRpbmdNdXRhdGlvbnMuYXQoLTEpO1xuICAgICAgICByZXR1cm4gbGFzdEJ1bGsgJiYgbGFzdEJ1bGsub3BlcmF0aW9uSWQgPT09IGV2ZW50Lm9wZXJhdGlvbklkID8gY29udGV4dC5wZW5kaW5nTXV0YXRpb25zLnNsaWNlKDAsIC0xKS5jb25jYXQoe1xuICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgICBvcGVyYXRpb25JZDogbGFzdEJ1bGsub3BlcmF0aW9uSWQsXG4gICAgICAgICAgcGF0Y2hlczogWy4uLmxhc3RCdWxrLnBhdGNoZXMsIGV2ZW50LnBhdGNoXVxuICAgICAgICB9KSA6IGNvbnRleHQucGVuZGluZ011dGF0aW9ucy5jb25jYXQoe1xuICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZSxcbiAgICAgICAgICBvcGVyYXRpb25JZDogZXZlbnQub3BlcmF0aW9uSWQsXG4gICAgICAgICAgcGF0Y2hlczogW2V2ZW50LnBhdGNoXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBhY3RvcnM6IHtcbiAgICBcInR5cGUgbGlzdGVuZXJcIjogZnJvbUNhbGxiYWNrKCh7XG4gICAgICBpbnB1dCxcbiAgICAgIHNlbmRCYWNrXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5O1xuICAgICAgcmV0dXJuIGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICAgIG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiB8fCBvcC50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgPyBzZW5kQmFjayh7XG4gICAgICAgICAgdHlwZTogXCJ0eXBpbmdcIlxuICAgICAgICB9KSA6IHNlbmRCYWNrKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdCB0eXBpbmdcIlxuICAgICAgICB9KSwgb3JpZ2luYWxBcHBseShvcCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5ID0gb3JpZ2luYWxBcHBseTtcbiAgICAgIH07XG4gICAgfSlcbiAgfSxcbiAgZ3VhcmRzOiB7XG4gICAgXCJpcyB0eXBpbmdcIjogc3RhdGVJbih7XG4gICAgICB0eXBpbmc6IFwidHlwaW5nXCJcbiAgICB9KSxcbiAgICBcIm5vIHBlbmRpbmcgbXV0YXRpb25zXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gY29udGV4dC5wZW5kaW5nTXV0YXRpb25zLmxlbmd0aCA9PT0gMCxcbiAgICBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gRWRpdG9yLmlzTm9ybWFsaXppbmcoY29udGV4dC5zbGF0ZUVkaXRvcilcbiAgfSxcbiAgZGVsYXlzOiB7XG4gICAgXCJtdXRhdGlvbiBkZWJvdW5jZVwiOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyAyNTAgOiAwLFxuICAgIFwidHlwZSBkZWJvdW5jZVwiOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyAwIDogMjUwXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJtdXRhdGlvblwiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgcGVuZGluZ011dGF0aW9uczogW10sXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgc2xhdGVFZGl0b3I6IGlucHV0LnNsYXRlRWRpdG9yXG4gIH0pLFxuICB0eXBlOiBcInBhcmFsbGVsXCIsXG4gIHN0YXRlczoge1xuICAgIHR5cGluZzoge1xuICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICBpbnZva2U6IHtcbiAgICAgICAgc3JjOiBcInR5cGUgbGlzdGVuZXJcIixcbiAgICAgICAgaW5wdXQ6ICh7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgIHNsYXRlRWRpdG9yOiBjb250ZXh0LnNsYXRlRWRpdG9yXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIGlkbGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgdHlwaW5nOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJ0eXBpbmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwaW5nOiB7XG4gICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgIFwidHlwZSBkZWJvdW5jZVwiOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcIm5vdCB0eXBpbmdcIjoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwaW5nOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJ0eXBpbmdcIixcbiAgICAgICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG11dGF0aW9uczoge1xuICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaWRsZToge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBwYXRjaFwiLCBcImVtaXQgaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImVtaXR0aW5nIG11dGF0aW9uc1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImVtaXR0aW5nIG11dGF0aW9uc1wiOiB7XG4gICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgIFwibXV0YXRpb24gZGVib3VuY2VcIjogW3tcbiAgICAgICAgICAgICAgZ3VhcmQ6IGFuZChbbm90KFwiaXMgdHlwaW5nXCIpLCBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCJdKSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCBtdXRhdGlvbnNcIiwgXCJjbGVhciBwZW5kaW5nIG11dGF0aW9uc1wiXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiZW1pdHRpbmcgbXV0YXRpb25zXCIsXG4gICAgICAgICAgICAgIHJlZW50ZXI6ICEwXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJlbWl0dGluZyBtdXRhdGlvbnNcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZGVmZXIgcGF0Y2hcIl0sXG4gICAgICAgICAgICAgIHJlZW50ZXI6ICEwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgZGVidWckNiA9IGRlYnVnV2l0aE5hbWUoXCJBUEk6ZWRpdGFibGVcIik7XG5mdW5jdGlvbiBjcmVhdGVFZGl0YWJsZUFQSShlZGl0b3IsIGVkaXRvckFjdG9yKSB7XG4gIGNvbnN0IHR5cGVzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1czogKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZm9jdXNcIixcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJsdXI6ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJsdXJcIixcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZU1hcms6IChtYXJrKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b2dnbGVMaXN0OiAobGlzdEl0ZW0pID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImxpc3QgaXRlbS50b2dnbGVcIixcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlQmxvY2tTdHlsZTogKHN0eWxlKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJzdHlsZS50b2dnbGVcIixcbiAgICAgICAgICBzdHlsZVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNNYXJrQWN0aXZlOiAobWFyaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzRGVjb3JhdG9yQWN0aXZlKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKSwgITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXJrczogKCkgPT4gKHtcbiAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgfSkubWFya3MgfHwgW10sXG4gICAgdW5kbzogKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaGlzdG9yeS51bmRvXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlZG86ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImhpc3RvcnkucmVkb1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IChzZWxlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IHNsYXRlU2VsZWN0aW9uID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgIHNsYXRlU2VsZWN0aW9uID8gVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzbGF0ZVNlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH0sXG4gICAgZm9jdXNCbG9jazogKCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvY3VzQ2hpbGQ6ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXS5jaGlsZHJlbltlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMV1dO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0Q2hpbGQ6ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGUubmFtZSAhPT0gdHlwZXMuc3Bhbi5uYW1lKVxuICAgICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LmlubGluZSBvYmplY3RcIixcbiAgICAgICAgICAgIGlubGluZU9iamVjdDoge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0b3JcbiAgICAgICAgfSksIGVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgcmFuZ2U6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgfSk/LmZvY3VzLnBhdGggPz8gW10gOiBbXTtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVkaXRvciBoYXMgbm8gc2VsZWN0aW9uXCIpO1xuICAgICAgY29uc3QgW2ZvY3VzQmxvY2tdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksXG4gICAgICAgIG1hdGNoOiAobikgPT4gbi5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgfSkpWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgaWYgKCFmb2N1c0Jsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmb2N1c2VkIHRleHQgYmxvY2tcIik7XG4gICAgICBpZiAodHlwZS5uYW1lICE9PSB0eXBlcy5zcGFuLm5hbWUgJiYgIXR5cGVzLmlubGluZU9iamVjdHMuc29tZSgodCkgPT4gdC5uYW1lID09PSB0eXBlLm5hbWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHR5cGUgY2Fubm90IGJlIGluc2VydGVkIGFzIGEgY2hpbGQgdG8gYSB0ZXh0IGJsb2NrXCIpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0b1NsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgfV1cbiAgICAgIH1dLCB7XG4gICAgICAgIHNjaGVtYVR5cGVzOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICB9KVswXS5jaGlsZHJlblswXSwgZm9jdXNDaGlsZFBhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMiksIGlzU3Bhbk5vZGUgPSBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lLCBmb2N1c05vZGUgPSBOb2RlLmdldChlZGl0b3IsIGZvY3VzQ2hpbGRQYXRoKTtcbiAgICAgIHJldHVybiBpc1NwYW5Ob2RlICYmIGZvY3VzTm9kZS5fdHlwZSAhPT0gdHlwZXMuc3Bhbi5uYW1lICYmIChkZWJ1ZyQ2KFwiSW5zZXJ0aW5nIHNwYW4gY2hpbGQgbmV4dCB0byBpbmxpbmUgb2JqZWN0IGNoaWxkLCBtb3Zpbmcgc2VsZWN0aW9uICsgMVwiKSwgZWRpdG9yLm1vdmUoe1xuICAgICAgICBkaXN0YW5jZTogMSxcbiAgICAgICAgdW5pdDogXCJjaGFyYWN0ZXJcIlxuICAgICAgfSkpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgc2VsZWN0OiAhMCxcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgZWRpdG9yLnNlbGVjdGlvbiA/IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICByYW5nZTogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSk/LmZvY3VzLnBhdGggPz8gW10gOiBbXTtcbiAgICB9LFxuICAgIGluc2VydEJsb2NrOiAodHlwZSwgdmFsdWUpID0+IChlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICBfdHlwZTogdHlwZS5uYW1lLFxuICAgICAgICAgIC4uLnZhbHVlIHx8IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlbWVudDogXCJhdXRvXCJcbiAgICAgIH0sXG4gICAgICBlZGl0b3JcbiAgICB9KSwgZWRpdG9yLnNlbGVjdGlvbiA/IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICBlZGl0b3IsXG4gICAgICByYW5nZTogZWRpdG9yLnNlbGVjdGlvblxuICAgIH0pPy5mb2N1cy5wYXRoID8/IFtdIDogW10pLFxuICAgIGhhc0Jsb2NrU3R5bGU6IChzdHlsZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzU3R5bGVBY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBzdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNMaXN0U3R5bGU6IChsaXN0SXRlbSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdEl0ZW1BY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1ZvaWQ6IChlbGVtZW50KSA9PiAhW3R5cGVzLmJsb2NrLm5hbWUsIHR5cGVzLnNwYW4ubmFtZV0uaW5jbHVkZXMoZWxlbWVudC5fdHlwZSksXG4gICAgZmluZEJ5UGF0aDogKHBhdGgpID0+IHtcbiAgICAgIGNvbnN0IHNsYXRlUGF0aCA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSwgZWRpdG9yKTtcbiAgICAgIGlmIChzbGF0ZVBhdGgpIHtcbiAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzbGF0ZVBhdGguZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChibG9jayAmJiBibG9ja1BhdGggJiYgdHlwZW9mIGJsb2NrLl9rZXkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiBzbGF0ZVBhdGguZm9jdXMucGF0aC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW2Zyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUpWzBdLCBbe1xuICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICB9XV07XG4gICAgICAgICAgY29uc3QgcHRCbG9jayA9IGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKHB0QmxvY2spKSB7XG4gICAgICAgICAgICBjb25zdCBwdENoaWxkID0gcHRCbG9jay5jaGlsZHJlbltzbGF0ZVBhdGguZm9jdXMucGF0aFsxXV07XG4gICAgICAgICAgICBpZiAocHRDaGlsZClcbiAgICAgICAgICAgICAgcmV0dXJuIFtwdENoaWxkLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogcHRDaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbdm9pZCAwLCB2b2lkIDBdO1xuICAgIH0sXG4gICAgZmluZERPTU5vZGU6IChlbGVtZW50KSA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtpdGVtXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBbXSxcbiAgICAgICAgICBtYXRjaDogKG4pID0+IG4uX2tleSA9PT0gZWxlbWVudC5fa2V5XG4gICAgICAgIH0pIHx8IFtdKVswXSB8fCBbdm9pZCAwXTtcbiAgICAgICAgbm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGl0ZW0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGFjdGl2ZUFubm90YXRpb25zOiAoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUFubm90YXRpb25zID0gW10sIHNwYW5zID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gVGV4dC5pc1RleHQobm9kZSkgJiYgbm9kZS5tYXJrcyAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5sZW5ndGggPiAwXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBzcGFucykge1xuICAgICAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5tYXJrRGVmcz8uZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgICAgICAgICBUZXh0LmlzVGV4dChzcGFuKSAmJiBzcGFuLm1hcmtzICYmIEFycmF5LmlzQXJyYXkoc3Bhbi5tYXJrcykgJiYgc3Bhbi5tYXJrcy5pbmNsdWRlcyhkZWYuX2tleSkgJiYgYWN0aXZlQW5ub3RhdGlvbnMucHVzaChkZWYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmVBbm5vdGF0aW9ucztcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0Fubm90YXRpb25BY3RpdmU6IChhbm5vdGF0aW9uVHlwZSkgPT4gaXNBbm5vdGF0aW9uQWN0aXZlKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgbmFtZTogYW5ub3RhdGlvblR5cGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRBbm5vdGF0aW9uOiAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgIGxldCBwYXRocztcbiAgICAgIHJldHVybiBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBwYXRocyA9IGFkZEFubm90YXRpb25PcGVyYXRpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc2NoZW1hOiB0eXBlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlID8/IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgcGF0aHM7XG4gICAgfSxcbiAgICBkZWxldGU6IChzZWxlY3Rpb24sIG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgICBpZiAoIShyYW5nZSAmJiByYW5nZS5hbmNob3IucGF0aC5sZW5ndGggPiAwICYmIHJhbmdlLmZvY3VzLnBhdGgubGVuZ3RoID4gMCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByYW5nZVwiKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zPy5tb2RlIHx8IG9wdGlvbnM/Lm1vZGUgPT09IFwic2VsZWN0ZWRcIikge1xuICAgICAgICAgICAgZGVidWckNihcIkRlbGV0aW5nIGNvbnRlbnQgaW4gc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBoYW5naW5nOiAhMCxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnM/Lm1vZGUgPT09IFwiYmxvY2tzXCIgJiYgKGRlYnVnJDYoXCJEZWxldGluZyBibG9ja3MgdG91Y2hlZCBieSBzZWxlY3Rpb25cIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICB2b2lkczogITAsXG4gICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKSB8fCAhZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSlcbiAgICAgICAgICB9KSksIG9wdGlvbnM/Lm1vZGUgPT09IFwiY2hpbGRyZW5cIiAmJiAoZGVidWckNihcIkRlbGV0aW5nIGNoaWxkcmVuIHRvdWNoZWQgYnkgc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6ICEwLFxuICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBub2RlLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUgfHwgLy8gVGV4dCBjaGlsZHJlblxuICAgICAgICAgICAgIWVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgfSkpLCBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIChlZGl0b3IuY2hpbGRyZW4gPSBbZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgICBkZWNvcmF0b3JzOiBbXVxuICAgICAgICAgIH0pXSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVBbm5vdGF0aW9uOiAodHlwZSkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5yZW1vdmVcIixcbiAgICAgICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb246ICgpID0+IHtcbiAgICAgIGxldCBwdFJhbmdlID0gbnVsbDtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5nZXQoZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgIGlmIChleGlzdGluZylcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIHB0UmFuZ2UgPSBzbGF0ZVJhbmdlVG9TZWxlY3Rpb24oe1xuICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgcmFuZ2U6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgfSksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0Uuc2V0KGVkaXRvci5zZWxlY3Rpb24sIHB0UmFuZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB0UmFuZ2U7XG4gICAgfSxcbiAgICBnZXRWYWx1ZTogKCkgPT4gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksXG4gICAgaXNDb2xsYXBzZWRTZWxlY3Rpb246ICgpID0+ICEhZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSxcbiAgICBpc0V4cGFuZGVkU2VsZWN0aW9uOiAoKSA9PiAhIWVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSxcbiAgICBpbnNlcnRCcmVhazogKCkgPT4ge1xuICAgICAgZWRpdG9yLmluc2VydEJyZWFrKCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6ICgpID0+IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5nZXRGcmFnbWVudCgpLCB0eXBlcy5ibG9jay5uYW1lKSxcbiAgICBpc1NlbGVjdGlvbnNPdmVybGFwcGluZzogKHNlbGVjdGlvbkEsIHNlbGVjdGlvbkIpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlQSA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb25BLCBlZGl0b3IpLCByYW5nZUIgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uQiwgZWRpdG9yKTtcbiAgICAgIHJldHVybiBSYW5nZS5pc1JhbmdlKHJhbmdlQSkgJiYgUmFuZ2UuaXNSYW5nZShyYW5nZUIpICYmIFJhbmdlLmluY2x1ZGVzKHJhbmdlQSwgcmFuZ2VCKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc0Fubm90YXRpb25BY3RpdmUoe1xuICBlZGl0b3IsXG4gIGFubm90YXRpb25cbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5sZW5ndGggPCAyKVxuICAgIHJldHVybiAhMTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzcGFucyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoOiAobm9kZSkgPT4gVGV4dC5pc1RleHQobm9kZSlcbiAgICB9KV07XG4gICAgaWYgKHNwYW5zLmxlbmd0aCA9PT0gMCB8fCBzcGFucy5zb21lKChbc3Bhbl0pID0+ICFpc1BvcnRhYmxlVGV4dFNwYW4kMShzcGFuKSB8fCAhc3Bhbi5tYXJrcyB8fCBzcGFuLm1hcmtzPy5sZW5ndGggPT09IDApKSByZXR1cm4gITE7XG4gICAgY29uc3Qgc2VsZWN0aW9uTWFya0RlZnMgPSBzcGFucy5yZWR1Y2UoKGFjY01hcmtEZWZzLCBbLCBwYXRoXSkgPT4ge1xuICAgICAgY29uc3QgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwge1xuICAgICAgICBkZXB0aDogMVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5tYXJrRGVmcyA/IFsuLi5hY2NNYXJrRGVmcywgLi4uYmxvY2subWFya0RlZnNdIDogYWNjTWFya0RlZnM7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzcGFucy5ldmVyeSgoW3NwYW5dKSA9PiBpc1BvcnRhYmxlVGV4dFNwYW4kMShzcGFuKSA/IHNwYW4ubWFya3M/Lm1hcCgobWFya0tleSkgPT4gc2VsZWN0aW9uTWFya0RlZnMuZmluZCgoZGVmKSA9PiBkZWY/Ll9rZXkgPT09IG1hcmtLZXkpPy5fdHlwZSk/LmluY2x1ZGVzKGFubm90YXRpb24ubmFtZSkgOiAhMSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdHlwZXMsIGtleUdlbmVyYXRvcikge1xuICBsZXQgcmVzb2x1dGlvbiA9IG51bGwsIHZhbGlkID0gITA7XG4gIGNvbnN0IHZhbGlkQ2hpbGRUeXBlcyA9IFt0eXBlcy5zcGFuLm5hbWUsIC4uLnR5cGVzLmlubGluZU9iamVjdHMubWFwKCh0KSA9PiB0Lm5hbWUpXSwgdmFsaWRCbG9ja1R5cGVzID0gW3R5cGVzLmJsb2NrLm5hbWUsIC4uLnR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICB2YWxpZDogITAsXG4gICAgcmVzb2x1dGlvbjogbnVsbCxcbiAgICB2YWx1ZVxuICB9IDogIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCA/IHtcbiAgICB2YWxpZDogITEsXG4gICAgcmVzb2x1dGlvbjoge1xuICAgICAgcGF0Y2hlczogW3Vuc2V0KFtdKV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJFZGl0b3IgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBQb3J0YWJsZSBUZXh0IGJsb2Nrcywgb3IgdW5kZWZpbmVkLlwiLFxuICAgICAgYWN0aW9uOiBcIlVuc2V0IHRoZSB2YWx1ZVwiLFxuICAgICAgaXRlbTogdmFsdWUsXG4gICAgICBpMThuOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1hcnJheS5hY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVcbiAgfSA6ICh2YWx1ZS5zb21lKChibGssIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGJsaykpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICR7U3RyaW5nKGJsayl9YCxcbiAgICAgICAgYWN0aW9uOiBcIlVuc2V0IGludmFsaWQgaXRlbVwiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tb2JqZWN0LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl9rZXkgfHwgdHlwZW9mIGJsay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgIH0sIFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBhdCBpbmRleCAke2luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkuYCxcbiAgICAgICAgYWN0aW9uOiBcIlNldCB0aGUgYmxvY2sgd2l0aCBhIHJhbmRvbSBfa2V5IHZhbHVlXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1rZXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMDtcbiAgICBpZiAoIWJsay5fdHlwZSB8fCAhdmFsaWRCbG9ja1R5cGVzLmluY2x1ZGVzKGJsay5fdHlwZSkpIHtcbiAgICAgIGlmIChibGsuX3R5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tUeXBlTmFtZSA9IHR5cGVzLmJsb2NrLm5hbWU7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgICAgX3R5cGU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIHR5cGUgbmFtZSAnJHtibGsuX3R5cGV9Jy4gQWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIHRoZSBibG9jayB0eXBlIG5hbWUgaXMgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgYWN0aW9uOiBgVXNlIHR5cGUgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW5jb3JyZWN0LWJsb2NrLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmluY29ycmVjdC1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhYmxrLl90eXBlICYmIGlzVGV4dEJsb2NrKHtcbiAgICAgICAgc2NoZW1hOiB0eXBlc1xuICAgICAgfSwge1xuICAgICAgICAuLi5ibGssXG4gICAgICAgIF90eXBlOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICB9KSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgfSwgW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYSB0eXBlIG5hbWUuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKSA6IGJsay5fdHlwZSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIF90eXBlICcke2Jsay5fdHlwZX0nYCxcbiAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgYmxvY2tcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgdHlwZU5hbWU6IGJsay5fdHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgIH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyBhbiBfdHlwZSBwcm9wZXJ0eWAsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApO1xuICAgIH1cbiAgICBpZiAoYmxrLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibGs7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuICYmICFBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikpXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IHRleHRCbG9jay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFRleHQgYmxvY2sgd2l0aCBfa2V5ICcke3RleHRCbG9jay5fa2V5fScgaGFzIGEgaW52YWxpZCByZXF1aXJlZCBwcm9wZXJ0eSAnY2hpbGRyZW4nLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlc2V0IHRoZSBjaGlsZHJlbiBwcm9wZXJ0eVwiLFxuICAgICAgICAgIGl0ZW06IHRleHRCbG9jayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1vci1pbnZhbGlkLWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogdGV4dEJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgaWYgKHRleHRCbG9jay5jaGlsZHJlbiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkodGV4dEJsb2NrLmNoaWxkcmVuKSAmJiB0ZXh0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1NwYW4gPSB7XG4gICAgICAgICAgX3R5cGU6IHR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgcGF0Y2hlczogW3NldElmTWlzc2luZyhbXSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiXSksIGluc2VydChbbmV3U3Bhbl0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCAwXSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGRyZW4gZm9yIHRleHQgYmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgZW1wdHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiSW5zZXJ0IGFuIGVtcHR5IHRleHRcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5lbXB0eS1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZW1wdHktY2hpbGRyZW4uYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxVc2VkTWFya3MgPSB1bmlxKGZsYXR0ZW4odGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcigoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSkubWFwKChjbGQpID0+IGNsZC5tYXJrcyB8fCBbXSkpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsay5tYXJrRGVmcykgJiYgYmxrLm1hcmtEZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW51c2VkTWFya0RlZnMgPSB1bmlxKGJsay5tYXJrRGVmcy5tYXAoKGRlZikgPT4gZGVmLl9rZXkpLmZpbHRlcigoa2V5KSA9PiAhYWxsVXNlZE1hcmtzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgaWYgKHVudXNlZE1hcmtEZWZzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiB1bnVzZWRNYXJrRGVmcy5tYXAoKG1hcmtEZWZLZXkpID0+IHVuc2V0KFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtEZWZzXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogbWFya0RlZktleVxuICAgICAgICAgICAgfV0pKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgY29udGFpbnMgb3JwaGFuZWQgZGF0YSAodW51c2VkIG1hcmsgZGVmaW5pdGlvbnMpOiAke3VudXNlZE1hcmtEZWZzLmpvaW4oXCIsIFwiKX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdW51c2VkIG1hcmsgZGVmaW5pdGlvbiBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFyay1kZWZzLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICB1bnVzZWRNYXJrRGVmczogdW51c2VkTWFya0RlZnMubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ycGhhbmVkTWFya3MgPSBhbGxVc2VkTWFya3MuZmlsdGVyKChtYXJrKSA9PiAhdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLm5hbWUpLmluY2x1ZGVzKG1hcmspKS5maWx0ZXIoKG1hcmspID0+IHRleHRCbG9jay5tYXJrRGVmcyA9PT0gdm9pZCAwIHx8ICF0ZXh0QmxvY2subWFya0RlZnMuZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgaWYgKG9ycGhhbmVkTWFya3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzcGFuQ2hpbGRyZW4gPSB0ZXh0QmxvY2suY2hpbGRyZW4uZmlsdGVyKChjbGQpID0+IGNsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIEFycmF5LmlzQXJyYXkoY2xkLm1hcmtzKSAmJiBjbGQubWFya3Muc29tZSgobWFyaykgPT4gb3JwaGFuZWRNYXJrcy5pbmNsdWRlcyhtYXJrKSkpO1xuICAgICAgICBpZiAoc3BhbkNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3Qgb3JwaGFuZWQgPSBvcnBoYW5lZE1hcmtzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IHNwYW5DaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBzZXQoKGNoaWxkLm1hcmtzIHx8IFtdKS5maWx0ZXIoKGNNcmspID0+ICFvcnBoYW5lZE1hcmtzLmluY2x1ZGVzKGNNcmspKSwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtzXCJdKSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGNvbnRhaW5zIG1hcmtzICgke29ycGhhbmVkfSkgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBjb250ZW50IG1vZGVsLmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIGludmFsaWQgbWFya3NcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBvcnBoYW5lZE1hcmtzOiBvcnBoYW5lZE1hcmtzLm1hcCgobSkgPT4gbS50b1N0cmluZygpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRleHRCbG9jay5jaGlsZHJlbi5zb21lKChjaGlsZCwgY0luZGV4KSA9PiB7XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdChjaGlsZCkpXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgY0luZGV4XSldLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCBhdCBpbmRleCAnJHtjSW5kZXh9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGlzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGl0ZW1cIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub24tb2JqZWN0LWNoaWxkLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vbi1vYmplY3QtY2hpbGQuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIGlmICghY2hpbGQuX2tleSB8fCB0eXBlb2YgY2hpbGQuX2tleSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICAgIHBhdGNoZXM6IFtzZXQobmV3Q2hpbGQsIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIGNJbmRleF0pXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgYXQgaW5kZXggJHtjSW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleSBpbiBibG9jayB3aXRoIF9rZXkgJHtibGsuX2tleX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJTZXQgYSBuZXcgcmFuZG9tIF9rZXkgb24gdGhlIG9iamVjdFwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQta2V5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQta2V5LmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIGluZGV4OiBjSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZC5fdHlwZSA/IHZhbGlkQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC5fdHlwZSkgPyBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIHR5cGVvZiBjaGlsZC50ZXh0ICE9IFwic3RyaW5nXCIgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaGFzIG1pc3Npbmcgb3IgaW52YWxpZCB0ZXh0IHByb3BlcnR5IWAsXG4gICAgICAgICAgYWN0aW9uOiBcIldyaXRlIGFuIGVtcHR5IHRleHQgcHJvcGVydHkgdG8gdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmludmFsaWQtc3Bhbi10ZXh0LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbnZhbGlkLXNwYW4tdGV4dC5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogITEgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCAnX3R5cGUnIHByb3BlcnR5ICgke2NoaWxkLl90eXBlfSkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRUeXBlOiBjaGlsZC5fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyAnX3R5cGUnIHByb3BlcnR5LmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKTtcbiAgICAgIH0pICYmICh2YWxpZCA9ICExKTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9KSAmJiAodmFsaWQgPSAhMSksIHtcbiAgICB2YWxpZCxcbiAgICByZXNvbHV0aW9uLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuY29uc3QgZGVidWckNSA9IGRlYnVnV2l0aE5hbWUoXCJzeW5jIG1hY2hpbmVcIiksIHN5bmNWYWx1ZUNhbGxiYWNrID0gKHtcbiAgc2VuZEJhY2ssXG4gIGlucHV0XG59KSA9PiB7XG4gIHVwZGF0ZVZhbHVlKHtcbiAgICBjb250ZXh0OiBpbnB1dC5jb250ZXh0LFxuICAgIHNlbmRCYWNrLFxuICAgIHNsYXRlRWRpdG9yOiBpbnB1dC5zbGF0ZUVkaXRvcixcbiAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgc3RyZWFtQmxvY2tzOiBpbnB1dC5zdHJlYW1CbG9ja3NcbiAgfSk7XG59LCBzeW5jVmFsdWVMb2dpYyA9IGZyb21DYWxsYmFjayhzeW5jVmFsdWVDYWxsYmFjayksIHN5bmNNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiOiBhc3NpZ24oe1xuICAgICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMFxuICAgIH0pLFxuICAgIFwiYXNzaWduIHJlYWRPbmx5XCI6IGFzc2lnbih7XG4gICAgICByZWFkT25seTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgcmVhZE9ubHlcIiksIGV2ZW50LnJlYWRPbmx5KVxuICAgIH0pLFxuICAgIFwiYXNzaWduIHBlbmRpbmcgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdWYWx1ZTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgdmFsdWVcIiksIGV2ZW50LnZhbHVlKVxuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyB2YWx1ZVwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDBcbiAgICB9KSxcbiAgICBcImFzc2lnbiBwcmV2aW91cyB2YWx1ZVwiOiBhc3NpZ24oe1xuICAgICAgcHJldmlvdXNWYWx1ZTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJkb25lIHN5bmNpbmdcIiksIGV2ZW50LnZhbHVlKVxuICAgIH0pLFxuICAgIFwiZW1pdCBkb25lIHN5bmNpbmcgdmFsdWVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImRvbmUgc3luY2luZyB2YWx1ZVwiXG4gICAgfSksXG4gICAgXCJlbWl0IHN5bmNpbmcgdmFsdWVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcInN5bmNpbmcgdmFsdWVcIlxuICAgIH0pXG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwiaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxWYWx1ZVN5bmNlZCxcbiAgICBcImlzIGJ1c3lcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBlZGl0YWJsZSA9ICFjb250ZXh0LnJlYWRPbmx5LCBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMgPSBjb250ZXh0LmlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlcywgaXNDaGFuZ2luZyA9IGlzQ2hhbmdpbmdSZW1vdGVseShjb250ZXh0LnNsYXRlRWRpdG9yKSA/PyAhMSwgaXNCdXN5ID0gZWRpdGFibGUgJiYgKGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlcyB8fCBpc0NoYW5naW5nKTtcbiAgICAgIHJldHVybiBkZWJ1ZyQ1KFwiaXNCdXN5XCIsIHtcbiAgICAgICAgaXNCdXN5LFxuICAgICAgICBlZGl0YWJsZSxcbiAgICAgICAgaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzLFxuICAgICAgICBpc0NoYW5naW5nXG4gICAgICB9KSwgaXNCdXN5O1xuICAgIH0sXG4gICAgXCJpcyBlbXB0eSB2YWx1ZVwiOiAoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBldmVudC50eXBlID09PSBcInVwZGF0ZSB2YWx1ZVwiICYmIGV2ZW50LnZhbHVlID09PSB2b2lkIDAsXG4gICAgXCJpcyBlbXB0eSBhcnJheVwiOiAoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBldmVudC50eXBlID09PSBcInVwZGF0ZSB2YWx1ZVwiICYmIEFycmF5LmlzQXJyYXkoZXZlbnQudmFsdWUpICYmIGV2ZW50LnZhbHVlLmxlbmd0aCA9PT0gMCxcbiAgICBcImlzIG5ldyB2YWx1ZVwiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gZXZlbnQudHlwZSA9PT0gXCJ1cGRhdGUgdmFsdWVcIiAmJiBjb250ZXh0LnByZXZpb3VzVmFsdWUgIT09IGV2ZW50LnZhbHVlLFxuICAgIFwidmFsdWUgY2hhbmdlZCB3aGlsZSBzeW5jaW5nXCI6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiZG9uZSBzeW5jaW5nXCIpLCBjb250ZXh0LnBlbmRpbmdWYWx1ZSAhPT0gZXZlbnQudmFsdWUpLFxuICAgIFwicGVuZGluZyB2YWx1ZSBlcXVhbHMgcHJldmlvdXMgdmFsdWVcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBpc0VxdWFsKGNvbnRleHQucGVuZGluZ1ZhbHVlLCBjb250ZXh0LnByZXZpb3VzVmFsdWUpXG4gIH0sXG4gIGFjdG9yczoge1xuICAgIFwic3luYyB2YWx1ZVwiOiBzeW5jVmFsdWVMb2dpY1xuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwic3luY1wiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgaW5pdGlhbFZhbHVlOiBpbnB1dC5pbml0aWFsVmFsdWUsXG4gICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMSxcbiAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICExLFxuICAgIGtleUdlbmVyYXRvcjogaW5wdXQua2V5R2VuZXJhdG9yLFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hLFxuICAgIHJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3IsXG4gICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDAsXG4gICAgcHJldmlvdXNWYWx1ZTogdm9pZCAwXG4gIH0pLFxuICBlbnRyeTogW3JhaXNlJDEoKHtcbiAgICBjb250ZXh0XG4gIH0pID0+ICh7XG4gICAgdHlwZTogXCJ1cGRhdGUgdmFsdWVcIixcbiAgICB2YWx1ZTogY29udGV4dC5pbml0aWFsVmFsdWVcbiAgfSkpXSxcbiAgb246IHtcbiAgICBcImhhcyBwZW5kaW5nIHBhdGNoZXNcIjoge1xuICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAgICAgICAgaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzOiAhMFxuICAgICAgfSlcbiAgICB9LFxuICAgIG11dGF0aW9uOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICExXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgcmVhZE9ubHlcIjoge1xuICAgICAgYWN0aW9uczogW1wiYXNzaWduIHJlYWRPbmx5XCJdXG4gICAgfVxuICB9LFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgc3RhdGVzOiB7XG4gICAgaWRsZToge1xuICAgICAgZW50cnk6IFsoKSA9PiB7XG4gICAgICAgIGRlYnVnJDUoXCJlbnRyeTogc3luY2luZy0+aWRsZVwiKTtcbiAgICAgIH1dLFxuICAgICAgZXhpdDogWygpID0+IHtcbiAgICAgICAgZGVidWckNShcImV4aXQ6IHN5bmNpbmctPmlkbGVcIik7XG4gICAgICB9XSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwidXBkYXRlIHZhbHVlXCI6IFt7XG4gICAgICAgICAgZ3VhcmQ6IGFuZChbXCJpcyBlbXB0eSB2YWx1ZVwiLCBub3QoXCJpbml0aWFsIHZhbHVlIHN5bmNlZFwiKV0pLFxuICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiLCBcImVtaXQgZG9uZSBzeW5jaW5nIHZhbHVlXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBndWFyZDogYW5kKFtcImlzIGVtcHR5IGFycmF5XCIsIG5vdChcImluaXRpYWwgdmFsdWUgc3luY2VkXCIpXSksXG4gICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCIsIGVtaXQoe1xuICAgICAgICAgICAgdHlwZTogXCJ2YWx1ZSBjaGFuZ2VkXCIsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICB9KSwgXCJlbWl0IGRvbmUgc3luY2luZyB2YWx1ZVwiXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZ3VhcmQ6IGFuZChbXCJpcyBidXN5XCIsIFwiaXMgbmV3IHZhbHVlXCJdKSxcbiAgICAgICAgICB0YXJnZXQ6IFwiYnVzeVwiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBndWFyZDogXCJpcyBuZXcgdmFsdWVcIixcbiAgICAgICAgICB0YXJnZXQ6IFwic3luY2luZ1wiLFxuICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBndWFyZDogbm90KFwiaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIiksXG4gICAgICAgICAgYWN0aW9uczogWygpID0+IHtcbiAgICAgICAgICAgIGRlYnVnJDUoXCJubyBuZXcgdmFsdWUgXFx1MjAxMyBzZXR0aW5nIGluaXRpYWwgdmFsdWUgYXMgc3luY2VkXCIpO1xuICAgICAgICAgIH0sIFwiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCIsIFwiZW1pdCBkb25lIHN5bmNpbmcgdmFsdWVcIl1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGFjdGlvbnM6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyQ1KFwibm8gbmV3IHZhbHVlIGFuZCBpbml0aWFsIHZhbHVlIGFscmVhZHkgc3luY2VkXCIpO1xuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfSxcbiAgICBidXN5OiB7XG4gICAgICBlbnRyeTogWygpID0+IHtcbiAgICAgICAgZGVidWckNShcImVudHJ5OiBzeW5jaW5nLT5idXN5XCIpO1xuICAgICAgfV0sXG4gICAgICBleGl0OiBbKCkgPT4ge1xuICAgICAgICBkZWJ1ZyQ1KFwiZXhpdDogc3luY2luZy0+YnVzeVwiKTtcbiAgICAgIH1dLFxuICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgMWUzOiBbe1xuICAgICAgICAgIGd1YXJkOiBcImlzIGJ1c3lcIixcbiAgICAgICAgICB0YXJnZXQ6IFwiLlwiLFxuICAgICAgICAgIHJlZW50ZXI6ICEwLFxuICAgICAgICAgIGFjdGlvbnM6IFsoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyQ1KFwicmVlbnRlcjogc3luY2luZy0+YnVzeVwiKTtcbiAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgdGFyZ2V0OiBcInN5bmNpbmdcIlxuICAgICAgICB9XVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwidXBkYXRlIHZhbHVlXCI6IFt7XG4gICAgICAgICAgZ3VhcmQ6IFwiaXMgbmV3IHZhbHVlXCIsXG4gICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN5bmNpbmc6IHtcbiAgICAgIGVudHJ5OiBbKCkgPT4ge1xuICAgICAgICBkZWJ1ZyQ1KFwiZW50cnk6IHN5bmNpbmctPnN5bmNpbmdcIik7XG4gICAgICB9LCBcImVtaXQgc3luY2luZyB2YWx1ZVwiXSxcbiAgICAgIGV4aXQ6IFsoKSA9PiB7XG4gICAgICAgIGRlYnVnJDUoXCJleGl0OiBzeW5jaW5nLT5zeW5jaW5nXCIpO1xuICAgICAgfSwgXCJlbWl0IGRvbmUgc3luY2luZyB2YWx1ZVwiXSxcbiAgICAgIGludm9rZToge1xuICAgICAgICBzcmM6IFwic3luYyB2YWx1ZVwiLFxuICAgICAgICBpZDogXCJzeW5jIHZhbHVlXCIsXG4gICAgICAgIGlucHV0OiAoe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogY29udGV4dC5wcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgcmVhZE9ubHk6IGNvbnRleHQucmVhZE9ubHksXG4gICAgICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbGF0ZUVkaXRvcjogY29udGV4dC5zbGF0ZUVkaXRvcixcbiAgICAgICAgICBzdHJlYW1CbG9ja3M6ICFjb250ZXh0LmluaXRpYWxWYWx1ZVN5bmNlZCxcbiAgICAgICAgICB2YWx1ZTogY29udGV4dC5wZW5kaW5nVmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcInVwZGF0ZSB2YWx1ZVwiOiB7XG4gICAgICAgICAgZ3VhcmQ6IFwiaXMgbmV3IHZhbHVlXCIsXG4gICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgfSxcbiAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbZW1pdCgoe1xuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9KSA9PiBldmVudCldXG4gICAgICAgIH0sXG4gICAgICAgIFwiaW52YWxpZCB2YWx1ZVwiOiB7XG4gICAgICAgICAgYWN0aW9uczogW2VtaXQoKHtcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgfSkgPT4gZXZlbnQpXVxuICAgICAgICB9LFxuICAgICAgICBcInZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgICAgICBldmVudFxuICAgICAgICAgIH0pID0+IGV2ZW50KV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkb25lIHN5bmNpbmdcIjogW3tcbiAgICAgICAgICBndWFyZDogXCJ2YWx1ZSBjaGFuZ2VkIHdoaWxlIHN5bmNpbmdcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcHJldmlvdXMgdmFsdWVcIiwgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIl0sXG4gICAgICAgICAgdGFyZ2V0OiBcInN5bmNpbmdcIixcbiAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJjbGVhciBwZW5kaW5nIHZhbHVlXCIsIFwiYXNzaWduIHByZXZpb3VzIHZhbHVlXCIsIFwiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCJdXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKHtcbiAgY29udGV4dCxcbiAgc2VuZEJhY2ssXG4gIHNsYXRlRWRpdG9yLFxuICBzdHJlYW1CbG9ja3MsXG4gIHZhbHVlXG59KSB7XG4gIGxldCBkb25lU3luY2luZyA9ICExLCBpc0NoYW5nZWQgPSAhMSwgaXNWYWxpZCA9ICEwO1xuICBjb25zdCBoYWRTZWxlY3Rpb24gPSAhIXNsYXRlRWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKCghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSAmJiAoZGVidWckNShcIlZhbHVlIGlzIGVtcHR5XCIpLCBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgd2l0aG91dFNhdmluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGlmIChkb25lU3luY2luZylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhhZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IFtjaGlsZHJlbkxlbmd0aCAtIDEgLSBpbmRleF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgfSksIHtcbiAgICAgICAgICBhdDogWzBdXG4gICAgICAgIH0pLCBoYWRTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIFswLCAwXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIGlzQ2hhbmdlZCA9ICEwKSwgdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNsYXRlVmFsdWVGcm9tUHJvcHMgPSB0b1NsYXRlVmFsdWUodmFsdWUsIHtcbiAgICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICAgIH0pO1xuICAgIHN0cmVhbUJsb2NrcyA/IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZVN5bmNpbmcpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0NoYW5nZWQgPSByZW1vdmVFeHRyYUJsb2Nrcyh7XG4gICAgICAgICAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgICAgICAgICBzbGF0ZVZhbHVlRnJvbVByb3BzXG4gICAgICAgICAgICB9KSwgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBbY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleF0gb2YgZ2V0U3RyZWFtZWRCbG9ja3Moe1xuICAgICAgICAgICAgICAgIHNsYXRlVmFsdWU6IHNsYXRlVmFsdWVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICBibG9ja0NoYW5nZWQsXG4gICAgICAgICAgICAgICAgICBibG9ja1ZhbGlkXG4gICAgICAgICAgICAgICAgfSA9IHN5bmNCbG9jayh7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgc2VuZEJhY2ssXG4gICAgICAgICAgICAgICAgICBibG9jazogY3VycmVudEJsb2NrLFxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRCbG9ja0luZGV4LFxuICAgICAgICAgICAgICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlzQ2hhbmdlZCA9IGJsb2NrQ2hhbmdlZCB8fCBpc0NoYW5nZWQsIGlzVmFsaWQgPSBpc1ZhbGlkICYmIGJsb2NrVmFsaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSA6IEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIGlmIChkb25lU3luY2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpc0NoYW5nZWQgPSByZW1vdmVFeHRyYUJsb2Nrcyh7XG4gICAgICAgICAgICBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgIHNsYXRlVmFsdWVGcm9tUHJvcHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudEJsb2NrIG9mIHNsYXRlVmFsdWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYmxvY2tDaGFuZ2VkLFxuICAgICAgICAgICAgICBibG9ja1ZhbGlkXG4gICAgICAgICAgICB9ID0gc3luY0Jsb2NrKHtcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgc2VuZEJhY2ssXG4gICAgICAgICAgICAgIGJsb2NrOiBjdXJyZW50QmxvY2ssXG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXNDaGFuZ2VkID0gYmxvY2tDaGFuZ2VkIHx8IGlzQ2hhbmdlZCwgaXNWYWxpZCA9IGlzVmFsaWQgJiYgYmxvY2tWYWxpZCwgaW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgZGVidWckNShcIkludmFsaWQgdmFsdWUsIHJldHVybmluZ1wiKSwgZG9uZVN5bmNpbmcgPSAhMCwgc2VuZEJhY2soe1xuICAgICAgdHlwZTogXCJkb25lIHN5bmNpbmdcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0NoYW5nZWQpIHtcbiAgICBkZWJ1ZyQ1KFwiU2VydmVyIHZhbHVlIGNoYW5nZWQsIHN5bmNpbmcgZWRpdG9yXCIpO1xuICAgIHRyeSB7XG4gICAgICBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpLCBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiaW52YWxpZCB2YWx1ZVwiLFxuICAgICAgICByZXNvbHV0aW9uOiBudWxsLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSksIGRvbmVTeW5jaW5nID0gITAsIHNlbmRCYWNrKHtcbiAgICAgICAgdHlwZTogXCJkb25lIHN5bmNpbmdcIixcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYWRTZWxlY3Rpb24gJiYgIXNsYXRlRWRpdG9yLnNlbGVjdGlvbiAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBzZW5kQmFjayh7XG4gICAgICB0eXBlOiBcInZhbHVlIGNoYW5nZWRcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZVxuICAgIGRlYnVnJDUoXCJTZXJ2ZXIgdmFsdWUgYW5kIGVkaXRvciB2YWx1ZSBpcyBlcXVhbCwgbm8gbmVlZCB0byBzeW5jLlwiKTtcbiAgZG9uZVN5bmNpbmcgPSAhMCwgc2VuZEJhY2soe1xuICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nXCIsXG4gICAgdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVFeHRyYUJsb2Nrcyh7XG4gIHNsYXRlRWRpdG9yLFxuICBzbGF0ZVZhbHVlRnJvbVByb3BzXG59KSB7XG4gIGxldCBpc0NoYW5nZWQgPSAhMTtcbiAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChzbGF0ZVZhbHVlRnJvbVByb3BzLmxlbmd0aCA8IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuTGVuZ3RoIC0gMTsgaSA+IHNsYXRlVmFsdWVGcm9tUHJvcHMubGVuZ3RoIC0gMTsgaS0tKVxuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICBhdDogW2ldXG4gICAgICB9KTtcbiAgICBpc0NoYW5nZWQgPSAhMDtcbiAgfVxuICByZXR1cm4gaXNDaGFuZ2VkO1xufVxuYXN5bmMgZnVuY3Rpb24qIGdldFN0cmVhbWVkQmxvY2tzKHtcbiAgc2xhdGVWYWx1ZVxufSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGJsb2NrIG9mIHNsYXRlVmFsdWUpXG4gICAgaW5kZXggJSAxMCA9PT0gMCAmJiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSksIHlpZWxkIFtibG9jaywgaW5kZXhdLCBpbmRleCsrO1xufVxuZnVuY3Rpb24gc3luY0Jsb2NrKHtcbiAgY29udGV4dCxcbiAgc2VuZEJhY2ssXG4gIGJsb2NrLFxuICBpbmRleCxcbiAgc2xhdGVFZGl0b3IsXG4gIHZhbHVlXG59KSB7XG4gIGxldCBibG9ja0NoYW5nZWQgPSAhMSwgYmxvY2tWYWxpZCA9ICEwO1xuICBjb25zdCBjdXJyZW50QmxvY2sgPSBibG9jaywgY3VycmVudEJsb2NrSW5kZXggPSBpbmRleCwgb2xkQmxvY2sgPSBzbGF0ZUVkaXRvci5jaGlsZHJlbltjdXJyZW50QmxvY2tJbmRleF0sIGhhc0NoYW5nZXMgPSBvbGRCbG9jayAmJiAhaXNFcXVhbChjdXJyZW50QmxvY2ssIG9sZEJsb2NrKTtcbiAgcmV0dXJuIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICB3aXRoUmVtb3RlQ2hhbmdlcyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VzICYmIGJsb2NrVmFsaWQpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uVmFsdWUgPSBbdmFsdWVbY3VycmVudEJsb2NrSW5kZXhdXSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUodmFsaWRhdGlvblZhbHVlLCBjb250ZXh0LnNjaGVtYSwgY29udGV4dC5rZXlHZW5lcmF0b3IpO1xuICAgICAgICAgICF2YWxpZGF0aW9uLnZhbGlkICYmIHZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgJiYgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5wYXRjaGVzLmxlbmd0aCA+IDAgJiYgIWNvbnRleHQucmVhZE9ubHkgJiYgY29udGV4dC5wcmV2aW91c1ZhbHVlICYmIGNvbnRleHQucHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUgJiYgKGNvbnNvbGUud2FybihgJHt2YWxpZGF0aW9uLnJlc29sdXRpb24uYWN0aW9ufSBmb3IgYmxvY2sgd2l0aCBfa2V5ICcke3ZhbGlkYXRpb25WYWx1ZVswXS5fa2V5fScuICR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5kZXNjcmlwdGlvbn1gKSwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uLnBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlbmRCYWNrKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgICAgICAgICBwYXRjaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpLCB2YWxpZGF0aW9uLnZhbGlkIHx8IHZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgPyAob2xkQmxvY2suX2tleSA9PT0gY3VycmVudEJsb2NrLl9rZXkgPyAoZGVidWckNS5lbmFibGVkICYmIGRlYnVnJDUoXCJVcGRhdGluZyBibG9ja1wiLCBvbGRCbG9jaywgY3VycmVudEJsb2NrKSwgX3VwZGF0ZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIG9sZEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkpIDogKGRlYnVnJDUuZW5hYmxlZCAmJiBkZWJ1ZyQ1KFwiUmVwbGFjaW5nIGJsb2NrXCIsIG9sZEJsb2NrLCBjdXJyZW50QmxvY2spLCBfcmVwbGFjZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSksIGJsb2NrQ2hhbmdlZCA9ICEwKSA6IChzZW5kQmFjayh7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IHZhbGlkYXRpb24ucmVzb2x1dGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSksIGJsb2NrVmFsaWQgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRCbG9jayAmJiBibG9ja1ZhbGlkKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGlvblZhbHVlID0gW3ZhbHVlW2N1cnJlbnRCbG9ja0luZGV4XV0sIHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHZhbGlkYXRpb25WYWx1ZSwgY29udGV4dC5zY2hlbWEsIGNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICBkZWJ1ZyQ1LmVuYWJsZWQgJiYgZGVidWckNShcIlZhbGlkYXRpbmcgYW5kIGluc2VydGluZyBuZXcgYmxvY2sgaW4gdGhlIGVuZCBvZiB0aGUgdmFsdWVcIiwgY3VycmVudEJsb2NrKSwgdmFsaWRhdGlvbi52YWxpZCB8fCB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlID8gVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICAgICAgICAgIH0pIDogKGRlYnVnJDUoXCJJbnZhbGlkXCIsIHZhbGlkYXRpb24pLCBzZW5kQmFjayh7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IHZhbGlkYXRpb24ucmVzb2x1dGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSksIGJsb2NrVmFsaWQgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSwge1xuICAgIGJsb2NrQ2hhbmdlZCxcbiAgICBibG9ja1ZhbGlkXG4gIH07XG59XG5mdW5jdGlvbiBfcmVwbGFjZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSB7XG4gIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24sIHNlbGVjdGlvbkZvY3VzT25CbG9jayA9IGN1cnJlbnRTZWxlY3Rpb24gJiYgY3VycmVudFNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdID09PSBjdXJyZW50QmxvY2tJbmRleDtcbiAgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpLCBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIGN1cnJlbnRTZWxlY3Rpb24pO1xufVxuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIG9sZEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkge1xuICBpZiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgfSksIHNsYXRlRWRpdG9yLmlzVGV4dEJsb2NrKGN1cnJlbnRCbG9jaykgJiYgc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2sob2xkQmxvY2spKSB7XG4gICAgY29uc3Qgb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCA9IG9sZEJsb2NrLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBjdXJyZW50QmxvY2suY2hpbGRyZW4ubGVuZ3RoIDwgb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAmJiBBcnJheS5mcm9tKEFycmF5KG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggLSBjdXJyZW50QmxvY2suY2hpbGRyZW4ubGVuZ3RoKSkuZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gMSAtIGluZGV4O1xuICAgICAgY2hpbGRJbmRleCA+IDAgJiYgKGRlYnVnJDUoXCJSZW1vdmluZyBjaGlsZFwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjaGlsZEluZGV4XVxuICAgICAgfSkpO1xuICAgIH0pLCBjdXJyZW50QmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoY3VycmVudEJsb2NrQ2hpbGQsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG9sZEJsb2NrQ2hpbGQgPSBvbGRCbG9jay5jaGlsZHJlbltjdXJyZW50QmxvY2tDaGlsZEluZGV4XSwgaXNDaGlsZENoYW5nZWQgPSAhaXNFcXVhbChjdXJyZW50QmxvY2tDaGlsZCwgb2xkQmxvY2tDaGlsZCksIGlzVGV4dENoYW5nZWQgPSAhaXNFcXVhbChjdXJyZW50QmxvY2tDaGlsZC50ZXh0LCBvbGRCbG9ja0NoaWxkPy50ZXh0KSwgcGF0aCA9IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF07XG4gICAgICBpZiAoaXNDaGlsZENoYW5nZWQpXG4gICAgICAgIGlmIChjdXJyZW50QmxvY2tDaGlsZC5fa2V5ID09PSBvbGRCbG9ja0NoaWxkPy5fa2V5KSB7XG4gICAgICAgICAgZGVidWckNShcIlVwZGF0aW5nIGNoYW5nZWQgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpc1NwYW5Ob2RlID0gVGV4dC5pc1RleHQoY3VycmVudEJsb2NrQ2hpbGQpICYmIGN1cnJlbnRCbG9ja0NoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiBUZXh0LmlzVGV4dChvbGRCbG9ja0NoaWxkKSAmJiBvbGRCbG9ja0NoaWxkLl90eXBlID09PSBcInNwYW5cIjtcbiAgICAgICAgICBpc1NwYW5Ob2RlICYmIGlzVGV4dENoYW5nZWQgPyAob2xkQmxvY2tDaGlsZC50ZXh0Lmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5kZWxldGUoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9sZEJsb2NrQ2hpbGQudGV4dC5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydFRleHQoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLnRleHQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpIDogaXNTcGFuTm9kZSB8fCAoZGVidWckNShcIlVwZGF0aW5nIGNoYW5nZWQgaW5saW5lIG9iamVjdCBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgIF9rZXk6IFZPSURfQ0hJTERfS0VZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCAwXSxcbiAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIG9sZEJsb2NrQ2hpbGQgPyAoZGVidWckNShcIlJlcGxhY2luZyBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSkgOiBvbGRCbG9ja0NoaWxkIHx8IChkZWJ1ZyQ1KFwiSW5zZXJ0aW5nIG5ldyBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBkZWJ1ZyQ0ID0gZGVidWdXaXRoTmFtZShcInNldHVwXCIpO1xuZnVuY3Rpb24gY29tcGlsZVNjaGVtYXNGcm9tRWRpdG9yQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCBsZWdhY3lTY2hlbWEgPSBjb25maWcuc2NoZW1hRGVmaW5pdGlvbiA/IGNvbXBpbGVTY2hlbWFEZWZpbml0aW9uVG9MZWdhY3lTY2hlbWEoY29uZmlnLnNjaGVtYURlZmluaXRpb24pIDogY3JlYXRlTGVnYWN5U2NoZW1hKGNvbmZpZy5zY2hlbWEuaGFzT3duUHJvcGVydHkoXCJqc29uVHlwZVwiKSA/IGNvbmZpZy5zY2hlbWEgOiBjb21waWxlVHlwZShjb25maWcuc2NoZW1hKSksIHNjaGVtYSA9IGxlZ2FjeVNjaGVtYVRvRWRpdG9yU2NoZW1hKGxlZ2FjeVNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgbGVnYWN5U2NoZW1hLFxuICAgIHNjaGVtYVxuICB9O1xufVxuZnVuY3Rpb24gZWRpdG9yQ29uZmlnVG9NYWNoaW5lSW5wdXQoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBsZWdhY3lTY2hlbWEsXG4gICAgc2NoZW1hXG4gIH0gPSBjb21waWxlU2NoZW1hc0Zyb21FZGl0b3JDb25maWcoY29uZmlnKTtcbiAgcmV0dXJuIHtcbiAgICBjb252ZXJ0ZXJzOiBjcmVhdGVDb3JlQ29udmVydGVycyhsZWdhY3lTY2hlbWEpLFxuICAgIGdldExlZ2FjeVNjaGVtYTogKCkgPT4gbGVnYWN5U2NoZW1hLFxuICAgIGtleUdlbmVyYXRvcjogY29uZmlnLmtleUdlbmVyYXRvciA/PyBkZWZhdWx0S2V5R2VuZXJhdG9yLFxuICAgIG1heEJsb2NrczogY29uZmlnLm1heEJsb2NrcyxcbiAgICByZWFkT25seTogY29uZmlnLnJlYWRPbmx5LFxuICAgIHNjaGVtYSxcbiAgICBpbml0aWFsVmFsdWU6IGNvbmZpZy5pbml0aWFsVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsRWRpdG9yKGNvbmZpZykge1xuICBkZWJ1ZyQ0KFwiQ3JlYXRpbmcgbmV3IEVkaXRvciBpbnN0YW5jZVwiKTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IFtdLCBlZGl0b3JBY3RvciA9IGNyZWF0ZUFjdG9yKGVkaXRvck1hY2hpbmUsIHtcbiAgICBpbnB1dDogZWRpdG9yQ29uZmlnVG9NYWNoaW5lSW5wdXQoY29uZmlnKVxuICB9KSwgc2xhdGVFZGl0b3IgPSBjcmVhdGVTbGF0ZUVkaXRvcih7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgc3Vic2NyaXB0aW9uc1xuICB9KSwgZWRpdGFibGUgPSBjcmVhdGVFZGl0YWJsZUFQSShzbGF0ZUVkaXRvci5pbnN0YW5jZSwgZWRpdG9yQWN0b3IpLCB7XG4gICAgbXV0YXRpb25BY3RvcixcbiAgICBzeW5jQWN0b3JcbiAgfSA9IGNyZWF0ZUFjdG9ycyh7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgc2xhdGVFZGl0b3I6IHNsYXRlRWRpdG9yLmluc3RhbmNlLFxuICAgIHN1YnNjcmlwdGlvbnNcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYWN0b3JzOiB7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIG11dGF0aW9uQWN0b3IsXG4gICAgICBzeW5jQWN0b3JcbiAgICB9LFxuICAgIGVkaXRvcjoge1xuICAgICAgZ2V0U25hcHNob3Q6ICgpID0+IGdldEVkaXRvclNuYXBzaG90KHtcbiAgICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSxcbiAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICAgIH0pLFxuICAgICAgcmVnaXN0ZXJCZWhhdmlvcjogKGJlaGF2aW9yQ29uZmlnKSA9PiB7XG4gICAgICAgIGNvbnN0IHByaW9yaXR5ID0gY3JlYXRlRWRpdG9yUHJpb3JpdHkoe1xuICAgICAgICAgIG5hbWU6IFwiY3VzdG9tXCIsXG4gICAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgICBwcmlvcml0eTogY29yZVByaW9yaXR5LFxuICAgICAgICAgICAgaW1wb3J0YW5jZTogXCJoaWdoZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSksIGJlaGF2aW9yQ29uZmlnV2l0aFByaW9yaXR5ID0ge1xuICAgICAgICAgIC4uLmJlaGF2aW9yQ29uZmlnLFxuICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImFkZCBiZWhhdmlvclwiLFxuICAgICAgICAgIGJlaGF2aW9yQ29uZmlnOiBiZWhhdmlvckNvbmZpZ1dpdGhQcmlvcml0eVxuICAgICAgICB9KSwgKCkgPT4ge1xuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJyZW1vdmUgYmVoYXZpb3JcIixcbiAgICAgICAgICAgIGJlaGF2aW9yQ29uZmlnOiBiZWhhdmlvckNvbmZpZ1dpdGhQcmlvcml0eVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNlbmQ6IChldmVudCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidXBkYXRlIHZhbHVlXCI6XG4gICAgICAgICAgICBzeW5jQWN0b3Iuc2VuZChldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidXBkYXRlIGtleSBnZW5lcmF0b3JcIjpcbiAgICAgICAgICBjYXNlIFwidXBkYXRlIHJlYWRPbmx5XCI6XG4gICAgICAgICAgY2FzZSBcInBhdGNoZXNcIjpcbiAgICAgICAgICBjYXNlIFwidXBkYXRlIHNjaGVtYVwiOlxuICAgICAgICAgIGNhc2UgXCJ1cGRhdGUgbWF4QmxvY2tzXCI6XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJibHVyXCIsXG4gICAgICAgICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImZvY3VzXCI6XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLmluc3RhbmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCI6XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgICAgICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IGV2ZW50LmJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAuLi5ldmVudC5ibG9ja09iamVjdC52YWx1ZSA/PyB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBldmVudC5wbGFjZW1lbnRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvci5pbnN0YW5jZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb246IChldmVudCwgbGlzdGVuZXIpID0+IGVkaXRvckFjdG9yLm9uKGV2ZW50LCAoZXZlbnQyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYmx1cnJlZFwiOlxuICAgICAgICAgIGNhc2UgXCJkb25lIGxvYWRpbmdcIjpcbiAgICAgICAgICBjYXNlIFwiZWRpdGFibGVcIjpcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICBjYXNlIFwiZm9jdXNlZFwiOlxuICAgICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6XG4gICAgICAgICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgICAgICBjYXNlIFwibXV0YXRpb25cIjpcbiAgICAgICAgICBjYXNlIFwicGF0Y2hcIjpcbiAgICAgICAgICBjYXNlIFwicmVhZCBvbmx5XCI6XG4gICAgICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICAgICAgY2FzZSBcInNlbGVjdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJ2YWx1ZSBjaGFuZ2VkXCI6XG4gICAgICAgICAgICBsaXN0ZW5lcihldmVudDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgX2ludGVybmFsOiB7XG4gICAgICAgIGVkaXRhYmxlLFxuICAgICAgICBlZGl0b3JBY3RvcixcbiAgICAgICAgc2xhdGVFZGl0b3JcbiAgICAgIH1cbiAgICB9LFxuICAgIHN1YnNjcmlwdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdG9ycyhjb25maWcpIHtcbiAgZGVidWckNChcIkNyZWF0aW5nIG5ldyBBY3RvcnNcIik7XG4gIGNvbnN0IG11dGF0aW9uQWN0b3IgPSBjcmVhdGVBY3RvcihtdXRhdGlvbk1hY2hpbmUsIHtcbiAgICBpbnB1dDoge1xuICAgICAgc2NoZW1hOiBjb25maWcuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgIHNsYXRlRWRpdG9yOiBjb25maWcuc2xhdGVFZGl0b3JcbiAgICB9XG4gIH0pLCBzeW5jQWN0b3IgPSBjcmVhdGVBY3RvcihzeW5jTWFjaGluZSwge1xuICAgIGlucHV0OiB7XG4gICAgICBpbml0aWFsVmFsdWU6IGNvbmZpZy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuaW5pdGlhbFZhbHVlLFxuICAgICAga2V5R2VuZXJhdG9yOiBjb25maWcuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgIHJlYWRPbmx5OiBjb25maWcuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSksXG4gICAgICBzY2hlbWE6IGNvbmZpZy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLFxuICAgICAgc2xhdGVFZGl0b3I6IGNvbmZpZy5zbGF0ZUVkaXRvclxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb25maWcuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBtdXRhdGlvbkFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnR5cGUgPT09IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiICYmIHN5bmNBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJoYXMgcGVuZGluZyBwYXRjaGVzXCJcbiAgICAgIH0pLCBldmVudC50eXBlID09PSBcIm11dGF0aW9uXCIgJiYgKHN5bmNBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiXG4gICAgICB9KSwgY29uZmlnLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICAgIHBhdGNoZXM6IGV2ZW50LnBhdGNoZXMsXG4gICAgICAgIHNuYXBzaG90OiBldmVudC5zbmFwc2hvdCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LnNuYXBzaG90XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0pLCBjb25maWcuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzeW5jQWN0b3Iub24oXCIqXCIsIChldmVudCkgPT4ge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6XG4gICAgICAgICAgY29uZmlnLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5pbnZhbGlkIHZhbHVlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZhbHVlIGNoYW5nZWRcIjpcbiAgICAgICAgICBjb25maWcuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgIHR5cGU6IFwibm90aWZ5LnZhbHVlIGNoYW5nZWRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicGF0Y2hcIjpcbiAgICAgICAgICBjb25maWcuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZXJuYWwucGF0Y2hcIixcbiAgICAgICAgICAgIHZhbHVlOiBmcm9tU2xhdGVWYWx1ZShjb25maWcuc2xhdGVFZGl0b3IuY2hpbGRyZW4sIGNvbmZpZy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChjb25maWcuc2xhdGVFZGl0b3IpKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbmZpZy5lZGl0b3JBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSksIGNvbmZpZy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNvbmZpZy5lZGl0b3JBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25maWcuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkgPyBzeW5jQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlIHJlYWRPbmx5XCIsXG4gICAgICAgIHJlYWRPbmx5OiAhMFxuICAgICAgfSkgOiBzeW5jQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlIHJlYWRPbmx5XCIsXG4gICAgICAgIHJlYWRPbmx5OiAhMVxuICAgICAgfSksIGV2ZW50LnR5cGUgPT09IFwiaW50ZXJuYWwucGF0Y2hcIiAmJiBtdXRhdGlvbkFjdG9yLnNlbmQoe1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJwYXRjaFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSksIHtcbiAgICBzeW5jQWN0b3IsXG4gICAgbXV0YXRpb25BY3RvclxuICB9O1xufVxuY29uc3QgUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCksIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbiA9ICgpID0+IHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0KTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufSwgZGVidWckMyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlNlbGVjdGlvblByb3ZpZGVyXCIpO1xuZnVuY3Rpb24gUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNiksIFtzZWxlY3Rpb24sIHNldFNlbGVjdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgbGV0IHQwLCB0MTtcbiAgJFswXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDAgPSAoKSA9PiB7XG4gICAgZGVidWckMyhcIlN1YnNjcmliaW5nIHRvIHNlbGVjdGlvbiBjaGFuZ2VzXCIpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHByb3BzLmVkaXRvckFjdG9yLm9uKFwic2VsZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGV2ZW50LnNlbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWckMyhcIlVuc3Vic2NyaWJpbmcgdG8gc2VsZWN0aW9uIGNoYW5nZXNcIiksIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yXSwgJFswXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzFdID0gdDAsICRbMl0gPSB0MSkgOiAodDAgPSAkWzFdLCB0MSA9ICRbMl0pLCB1c2VFZmZlY3QodDAsIHQxKTtcbiAgbGV0IHQyO1xuICByZXR1cm4gJFszXSAhPT0gcHJvcHMuY2hpbGRyZW4gfHwgJFs0XSAhPT0gc2VsZWN0aW9uID8gKHQyID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZWxlY3Rpb24sIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFszXSA9IHByb3BzLmNoaWxkcmVuLCAkWzRdID0gc2VsZWN0aW9uLCAkWzVdID0gdDIpIDogdDIgPSAkWzVdLCB0Mjtcbn1cbmZ1bmN0aW9uIFJvdXRlRXZlbnRzVG9DaGFuZ2VzKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDcpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzID8gKHQwID0gKGNoYW5nZSkgPT4gcHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgJFswXSA9IHByb3BzLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh0MCk7XG4gIGxldCB0MTtcbiAgJFsyXSAhPT0gaGFuZGxlQ2hhbmdlIHx8ICRbM10gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQxID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YiA9IHByb3BzLmVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5nZV8wID0gZXZlbnRUb0NoYW5nZShldmVudCk7XG4gICAgICBjaGFuZ2VfMCAmJiBoYW5kbGVDaGFuZ2UoY2hhbmdlXzApO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCAkWzJdID0gaGFuZGxlQ2hhbmdlLCAkWzNdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbNF0gPSB0MSkgOiB0MSA9ICRbNF07XG4gIGxldCB0MjtcbiAgcmV0dXJuICRbNV0gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQyID0gW3Byb3BzLmVkaXRvckFjdG9yXSwgJFs1XSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzZdID0gdDIpIDogdDIgPSAkWzZdLCB1c2VFZmZlY3QodDEsIHQyKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIGV2ZW50VG9DaGFuZ2UoZXZlbnQpIHtcbiAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgY2FzZSBcImJsdXJyZWRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYmx1clwiLFxuICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgIH07XG4gICAgY2FzZSBcInBhdGNoXCI6XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBpc0xvYWRpbmc6ICEwXG4gICAgICB9O1xuICAgIGNhc2UgXCJkb25lIGxvYWRpbmdcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBpc0xvYWRpbmc6ICExXG4gICAgICB9O1xuICAgIGNhc2UgXCJmb2N1c2VkXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZvY3VzXCIsXG4gICAgICAgIGV2ZW50OiBldmVudC5ldmVudFxuICAgICAgfTtcbiAgICBjYXNlIFwidmFsdWUgY2hhbmdlZFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZXZlbnQudmFsdWVcbiAgICAgIH07XG4gICAgY2FzZSBcImludmFsaWQgdmFsdWVcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaW52YWxpZFZhbHVlXCIsXG4gICAgICAgIHJlc29sdXRpb246IGV2ZW50LnJlc29sdXRpb24sXG4gICAgICAgIHZhbHVlOiBldmVudC52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCJcbiAgICAgIH07XG4gICAgY2FzZSBcIm11dGF0aW9uXCI6XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgY2FzZSBcInNlbGVjdGlvblwiOlxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgcmV0dXJuIGV2ZW50O1xuICB9XG59XG5jb25zdCBkZWJ1ZyQyID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3JcIik7XG5jbGFzcyBQb3J0YWJsZVRleHRFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSBcIlBvcnRhYmxlVGV4dEVkaXRvclwiO1xuICAvKipcbiAgICogQW4gb2JzZXJ2YWJsZSBvZiBhbGwgdGhlIGVkaXRvciBjaGFuZ2VzLlxuICAgKi9cbiAgY2hhbmdlJCA9IG5ldyBTdWJqZWN0KCk7XG4gIC8qKlxuICAgKiBBIGxvb2t1cCB0YWJsZSBmb3IgYWxsIHRoZSByZWxldmFudCBzY2hlbWEgdHlwZXMgZm9yIHRoaXMgcG9ydGFibGUgdGV4dCB0eXBlLlxuICAgKi9cbiAgLyoqXG4gICAqIFRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICovXG4gIC8qXG4gICAqIFRoZSBlZGl0b3IgQVBJIChjdXJyZW50bHkgaW1wbGVtZW50ZWQgd2l0aCBTbGF0ZSkuXG4gICAqL1xuICB1bnN1YnNjcmliZXJzID0gW107XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgaWYgKHN1cGVyKHByb3BzKSwgcHJvcHMuZWRpdG9yKVxuICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3IsIHRoaXMuc2NoZW1hVHlwZXMgPSB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmdldExlZ2FjeVNjaGVtYSgpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RvcnMsXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc3Vic2NyaXB0aW9uc1xuICAgICAgfSA9IGNyZWF0ZUludGVybmFsRWRpdG9yKHtcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSxcbiAgICAgICAga2V5R2VuZXJhdG9yOiBwcm9wcy5rZXlHZW5lcmF0b3IsXG4gICAgICAgIG1heEJsb2NrczogcHJvcHMubWF4QmxvY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBOdW1iZXIucGFyc2VJbnQocHJvcHMubWF4QmxvY2tzLnRvU3RyaW5nKCksIDEwKSxcbiAgICAgICAgcmVhZE9ubHk6IHByb3BzLnJlYWRPbmx5LFxuICAgICAgICBzY2hlbWE6IHByb3BzLnNjaGVtYVR5cGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51bnN1YnNjcmliZXJzLnB1c2goKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0b3JzLmVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBldmVudFRvQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICBjaGFuZ2UgJiYgKHByb3BzLm9uQ2hhbmdlKGNoYW5nZSksIHRoaXMuY2hhbmdlJC5uZXh0KGNoYW5nZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKCkpO1xuICAgICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2Ygc3Vic2NyaXB0aW9ucylcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKCkpO1xuICAgICAgdGhpcy5hY3RvcnMgPSBhY3RvcnMsIHRoaXMuZWRpdG9yID0gZWRpdG9yLCB0aGlzLnNjaGVtYVR5cGVzID0gYWN0b3JzLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5nZXRMZWdhY3lTY2hlbWEoKTtcbiAgICB9XG4gICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmFjdG9ycyAmJiAodGhpcy5hY3RvcnMuZWRpdG9yQWN0b3Iuc3RhcnQoKSwgdGhpcy5hY3RvcnMubXV0YXRpb25BY3Rvci5zdGFydCgpLCB0aGlzLmFjdG9ycy5zeW5jQWN0b3Iuc3RhcnQoKSk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICF0aGlzLnByb3BzLmVkaXRvciAmJiAhcHJldlByb3BzLmVkaXRvciAmJiB0aGlzLnByb3BzLnNjaGVtYVR5cGUgIT09IHByZXZQcm9wcy5zY2hlbWFUeXBlICYmICh0aGlzLnNjaGVtYVR5cGVzID0gY3JlYXRlTGVnYWN5U2NoZW1hKHRoaXMucHJvcHMuc2NoZW1hVHlwZS5oYXNPd25Qcm9wZXJ0eShcImpzb25UeXBlXCIpID8gdGhpcy5wcm9wcy5zY2hlbWFUeXBlIDogY29tcGlsZVR5cGUodGhpcy5wcm9wcy5zY2hlbWFUeXBlKSksIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIHNjaGVtYVwiLFxuICAgICAgc2NoZW1hOiBsZWdhY3lTY2hlbWFUb0VkaXRvclNjaGVtYSh0aGlzLnNjaGVtYVR5cGVzKVxuICAgIH0pKSwgIXRoaXMucHJvcHMuZWRpdG9yICYmICFwcmV2UHJvcHMuZWRpdG9yICYmICh0aGlzLnByb3BzLnJlYWRPbmx5ICE9PSBwcmV2UHJvcHMucmVhZE9ubHkgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgcmVhZE9ubHlcIixcbiAgICAgIHJlYWRPbmx5OiB0aGlzLnByb3BzLnJlYWRPbmx5ID8/ICExXG4gICAgfSksIHRoaXMucHJvcHMubWF4QmxvY2tzICE9PSBwcmV2UHJvcHMubWF4QmxvY2tzICYmIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIG1heEJsb2Nrc1wiLFxuICAgICAgbWF4QmxvY2tzOiB0aGlzLnByb3BzLm1heEJsb2NrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogTnVtYmVyLnBhcnNlSW50KHRoaXMucHJvcHMubWF4QmxvY2tzLnRvU3RyaW5nKCksIDEwKVxuICAgIH0pLCB0aGlzLnByb3BzLnZhbHVlICE9PSBwcmV2UHJvcHMudmFsdWUgJiYgdGhpcy5lZGl0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSB2YWx1ZVwiLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWVcbiAgICB9KSwgdGhpcy5wcm9wcy5lZGl0b3JSZWYgIT09IHByZXZQcm9wcy5lZGl0b3JSZWYgJiYgdGhpcy5wcm9wcy5lZGl0b3JSZWYgJiYgKHRoaXMucHJvcHMuZWRpdG9yUmVmLmN1cnJlbnQgPSB0aGlzKSk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgZm9yIChjb25zdCB1bnN1YnNjcmliZSBvZiB0aGlzLnVuc3Vic2NyaWJlcnMpXG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuYWN0b3JzICYmIChzdG9wQWN0b3IodGhpcy5hY3RvcnMuZWRpdG9yQWN0b3IpLCBzdG9wQWN0b3IodGhpcy5hY3RvcnMubXV0YXRpb25BY3RvciksIHN0b3BBY3Rvcih0aGlzLmFjdG9ycy5zeW5jQWN0b3IpKTtcbiAgfVxuICBzZXRFZGl0YWJsZSA9IChlZGl0YWJsZSkgPT4ge1xuICAgIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZSA9IHtcbiAgICAgIC4uLnRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0YWJsZSxcbiAgICAgIC4uLmVkaXRhYmxlXG4gICAgfTtcbiAgfTtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGxlZ2FjeVBhdGNoZXMgPSB0aGlzLnByb3BzLmVkaXRvciA/IHZvaWQgMCA6IHRoaXMucHJvcHMuaW5jb21pbmdQYXRjaGVzJCA/PyB0aGlzLnByb3BzLnBhdGNoZXMkO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgbGVnYWN5UGF0Y2hlcyA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUm91dGVQYXRjaGVzT2JzZXJ2YWJsZVRvRWRpdG9yQWN0b3IsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgcGF0Y2hlcyQ6IGxlZ2FjeVBhdGNoZXMgfSkgOiBudWxsLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JBY3RvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2xhdGUsIHsgZWRpdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGluaXRpYWxWYWx1ZTogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluaXRpYWxWYWx1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSkgfSkgfSkgfSlcbiAgICBdIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmdldEFjdGl2ZUFubm90YXRpb25zKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBhY3RpdmVBbm5vdGF0aW9ucyA9IChlZGl0b3IpID0+IGVkaXRvciAmJiBlZGl0b3IuZWRpdGFibGUgPyBlZGl0b3IuZWRpdGFibGUuYWN0aXZlQW5ub3RhdGlvbnMoKSA6IFtdO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgaXNBY3RpdmUgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5pc0FjdGl2ZUFubm90YXRpb24oLi4uKSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaXNBbm5vdGF0aW9uQWN0aXZlID0gKGVkaXRvciwgYW5ub3RhdGlvblR5cGUpID0+IGVkaXRvciAmJiBlZGl0b3IuZWRpdGFibGUgPyBlZGl0b3IuZWRpdGFibGUuaXNBbm5vdGF0aW9uQWN0aXZlKGFubm90YXRpb25UeXBlKSA6ICExO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnYW5ub3RhdGlvbi5hZGQnLFxuICAgKiAgYW5ub3RhdGlvbjoge1xuICAgKiAgICBuYW1lOiAnLi4uJyxcbiAgICogICAgdmFsdWU6IHsuLi59LFxuICAgKiAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBhZGRBbm5vdGF0aW9uID0gKGVkaXRvciwgdHlwZSwgdmFsdWUpID0+IGVkaXRvci5lZGl0YWJsZT8uYWRkQW5ub3RhdGlvbih0eXBlLCB2YWx1ZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdibHVyJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgYmx1ciA9IChlZGl0b3IpID0+IHtcbiAgICBkZWJ1ZyQyKFwiSG9zdCBibHVycmVkXCIpLCBlZGl0b3IuZWRpdGFibGU/LmJsdXIoKTtcbiAgfTtcbiAgc3RhdGljIGRlbGV0ZSA9IChlZGl0b3IsIHNlbGVjdGlvbiwgb3B0aW9ucykgPT4gZWRpdG9yLmVkaXRhYmxlPy5kZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKTtcbiAgc3RhdGljIGZpbmRET01Ob2RlID0gKGVkaXRvciwgZWxlbWVudCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5maW5kRE9NTm9kZShlbGVtZW50KTtcbiAgc3RhdGljIGZpbmRCeVBhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiBlZGl0b3IuZWRpdGFibGU/LmZpbmRCeVBhdGgocGF0aCkgfHwgW107XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdmb2N1cycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGZvY3VzID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDIoXCJIb3N0IHJlcXVlc3RpbmcgZm9jdXNcIiksIGVkaXRvci5lZGl0YWJsZT8uZm9jdXMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGZvY3VzQmxvY2sgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5nZXRGb2N1c0Jsb2NrKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBmb2N1c0Jsb2NrID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5mb2N1c0Jsb2NrKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBmb2N1c0NoaWxkID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0Rm9jdXNDaGlsZClcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZm9jdXNDaGlsZCA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNDaGlsZCgpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3Qgc2VsZWN0aW9uID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuZ2V0U2VsZWN0aW9uKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBnZXRTZWxlY3Rpb24gPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGUgPyBlZGl0b3IuZWRpdGFibGUuZ2V0U2VsZWN0aW9uKCkgOiBudWxsO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGJ1aWx0LWluIHNlbGVjdG9ycyBvciB3cml0ZSB5b3VyIG93bjogaHR0cHM6Ly93d3cucG9ydGFibGV0ZXh0Lm9yZy9yZWZlcmVuY2Uvc2VsZWN0b3JzL1xuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0ICogYXMgc2VsZWN0b3JzIGZyb20gJ0Bwb3J0YWJsZXRleHQvZWRpdG9yL3NlbGVjdG9ycydcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogY29uc3QgdmFsdWUgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5nZXRWYWx1ZSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgZ2V0VmFsdWUgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmdldFZhbHVlKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzQWN0aXZlU3R5bGUoLi4uKSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaGFzQmxvY2tTdHlsZSA9IChlZGl0b3IsIGJsb2NrU3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzQmxvY2tTdHlsZShibG9ja1N0eWxlKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGlzQWN0aXZlID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuaXNBY3RpdmVMaXN0SXRlbSguLi4pKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBoYXNMaXN0U3R5bGUgPSAoZWRpdG9yLCBsaXN0U3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzTGlzdFN0eWxlKGxpc3RTdHlsZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzU2VsZWN0aW9uQ29sbGFwc2VkKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpc0NvbGxhcHNlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNDb2xsYXBzZWRTZWxlY3Rpb24oKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IGlzU2VsZWN0aW9uRXhwYW5kZWQgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5pc1NlbGVjdGlvbkV4cGFuZGVkKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpc0V4cGFuZGVkU2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc0V4cGFuZGVkU2VsZWN0aW9uKCk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc0FjdGl2ZSA9IHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3JzLmlzQWN0aXZlRGVjb3JhdG9yKC4uLikpXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGlzTWFya0FjdGl2ZSA9IChlZGl0b3IsIG1hcmspID0+IGVkaXRvci5lZGl0YWJsZT8uaXNNYXJrQWN0aXZlKG1hcmspO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnaW5zZXJ0LnNwYW4nLFxuICAgKiAgdGV4dDogJy4uLicsXG4gICAqICBhbm5vdGF0aW9uczogW3tuYW1lOiAnLi4uJywgdmFsdWU6IHsuLi59fV0sXG4gICAqICBkZWNvcmF0b3JzOiBbJy4uLiddLFxuICAgKiB9KVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnaW5zZXJ0LmlubGluZSBvYmplY3QnLFxuICAgKiAgaW5saW5lT2JqZWN0OiB7XG4gICAqICAgIG5hbWU6ICcuLi4nLFxuICAgKiAgICB2YWx1ZTogey4uLn0sXG4gICAqICB9LFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBpbnNlcnRDaGlsZCA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiAoZGVidWckMihcIkhvc3QgaW5zZXJ0aW5nIGNoaWxkXCIpLCBlZGl0b3IuZWRpdGFibGU/Lmluc2VydENoaWxkKHR5cGUsIHZhbHVlKSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdpbnNlcnQuYmxvY2sgb2JqZWN0JyxcbiAgICogIGJsb2NrT2JqZWN0OiB7XG4gICAqICAgIG5hbWU6ICcuLi4nLFxuICAgKiAgICB2YWx1ZTogey4uLn0sXG4gICAqICB9LFxuICAgKiAgcGxhY2VtZW50OiAnYXV0bycgfCAnYWZ0ZXInIHwgJ2JlZm9yZScsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGluc2VydEJsb2NrID0gKGVkaXRvciwgdHlwZSwgdmFsdWUpID0+IGVkaXRvci5lZGl0YWJsZT8uaW5zZXJ0QmxvY2sodHlwZSwgdmFsdWUpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnaW5zZXJ0LmJyZWFrJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaW5zZXJ0QnJlYWsgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmluc2VydEJyZWFrKCk7XG4gIHN0YXRpYyBpc1ZvaWQgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzVm9pZChlbGVtZW50KTtcbiAgc3RhdGljIGlzT2JqZWN0UGF0aCA9IChfZWRpdG9yLCBwYXRoKSA9PiB7XG4gICAgaWYgKCFwYXRoIHx8ICFBcnJheS5pc0FycmF5KHBhdGgpKSByZXR1cm4gITE7XG4gICAgY29uc3QgaXNDaGlsZE9iamVjdEVkaXRQYXRoID0gcGF0aC5sZW5ndGggPiAzICYmIHBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIjtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxICYmIHBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIiB8fCBpc0NoaWxkT2JqZWN0RWRpdFBhdGg7XG4gIH07XG4gIHN0YXRpYyBtYXJrcyA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8ubWFya3MoKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgdHlwZTogJ3NlbGVjdCcsXG4gICAqICBzZWxlY3Rpb246IHsuLi59LFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBzZWxlY3QgPSAoZWRpdG9yLCBzZWxlY3Rpb24pID0+IHtcbiAgICBkZWJ1ZyQyKFwiSG9zdCBzZXR0aW5nIHNlbGVjdGlvblwiLCBzZWxlY3Rpb24pLCBlZGl0b3IuZWRpdGFibGU/LnNlbGVjdChzZWxlY3Rpb24pO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnYW5ub3RhdGlvbi5yZW1vdmUnLFxuICAgKiAgYW5ub3RhdGlvbjoge1xuICAgKiAgICBuYW1lOiAnLi4uJyxcbiAgICogIH0sXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHJlbW92ZUFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnJlbW92ZUFubm90YXRpb24odHlwZSk7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYGVkaXRvci5zZW5kKC4uLilgIGluc3RlYWRcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGVkaXRvci5zZW5kKHtcbiAgICogIHR5cGU6ICdzdHlsZS50b2dnbGUnLFxuICAgKiAgc3R5bGU6ICcuLi4nLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyB0b2dnbGVCbG9ja1N0eWxlID0gKGVkaXRvciwgYmxvY2tTdHlsZSkgPT4gKGRlYnVnJDIoXCJIb3N0IGlzIHRvZ2dsaW5nIGJsb2NrIHN0eWxlXCIpLCBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUJsb2NrU3R5bGUoYmxvY2tTdHlsZSkpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnbGlzdCBpdGVtLnRvZ2dsZScsXG4gICAqICBsaXN0SXRlbTogJy4uLicsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHRvZ2dsZUxpc3QgPSAoZWRpdG9yLCBsaXN0U3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlTGlzdChsaXN0U3R5bGUpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICB0eXBlOiAnZGVjb3JhdG9yLnRvZ2dsZScsXG4gICAqICBkZWNvcmF0b3I6ICcuLi4nLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyB0b2dnbGVNYXJrID0gKGVkaXRvciwgbWFyaykgPT4ge1xuICAgIGRlYnVnJDIoXCJIb3N0IHRvZ2dsaW5nIG1hcmtcIiwgbWFyayksIGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlTWFyayhtYXJrKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBidWlsdC1pbiBzZWxlY3RvcnMgb3Igd3JpdGUgeW91ciBvd246IGh0dHBzOi8vd3d3LnBvcnRhYmxldGV4dC5vcmcvcmVmZXJlbmNlL3NlbGVjdG9ycy9cbiAgICpcbiAgICogYGBgXG4gICAqIGltcG9ydCAqIGFzIHNlbGVjdG9ycyBmcm9tICdAcG9ydGFibGV0ZXh0L2VkaXRvci9zZWxlY3RvcnMnXG4gICAqIGNvbnN0IGVkaXRvciA9IHVzZUVkaXRvcigpXG4gICAqIGNvbnN0IHNlbGVjdGVkU2xpY2UgPSB1c2VFZGl0b3JTZWxlY3RvcihlZGl0b3IsIHNlbGVjdG9ycy5nZXRTZWxlY3RlZFNsaWNlKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBnZXRGcmFnbWVudCA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZ2V0RnJhZ21lbnQoKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFVzZSBgZWRpdG9yLnNlbmQoLi4uKWAgaW5zdGVhZFxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKClcbiAgICogZWRpdG9yLnNlbmQoe1xuICAgKiAgIHR5cGU6ICdoaXN0b3J5LnVuZG8nLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyB1bmRvID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDIoXCJIb3N0IHVuZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8udW5kbygpO1xuICB9O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVXNlIGBlZGl0b3Iuc2VuZCguLi4pYCBpbnN0ZWFkXG4gICAqXG4gICAqIGBgYFxuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBlZGl0b3Iuc2VuZCh7XG4gICAqICAgdHlwZTogJ2hpc3RvcnkucmVkbycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIHJlZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckMihcIkhvc3QgcmVkb2luZ1wiKSwgZWRpdG9yLmVkaXRhYmxlPy5yZWRvKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBVc2UgYnVpbHQtaW4gc2VsZWN0b3JzIG9yIHdyaXRlIHlvdXIgb3duOiBodHRwczovL3d3dy5wb3J0YWJsZXRleHQub3JnL3JlZmVyZW5jZS9zZWxlY3RvcnMvXG4gICAqXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgKiBhcyBzZWxlY3RvcnMgZnJvbSAnQHBvcnRhYmxldGV4dC9lZGl0b3Ivc2VsZWN0b3JzJ1xuICAgKiBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoKVxuICAgKiBjb25zdCBpc092ZXJsYXBwaW5nID0gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvcnMuaXNPdmVybGFwcGluZ1NlbGVjdGlvbihzZWxlY3Rpb25CKSlcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmcgPSAoZWRpdG9yLCBzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzU2VsZWN0aW9uc092ZXJsYXBwaW5nKHNlbGVjdGlvbkEsIHNlbGVjdGlvbkIpO1xufVxuZnVuY3Rpb24gUm91dGVQYXRjaGVzT2JzZXJ2YWJsZVRvRWRpdG9yQWN0b3IocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MCwgdDE7XG4gIHJldHVybiAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciB8fCAkWzFdICE9PSBwcm9wcy5wYXRjaGVzJCA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwcm9wcy5wYXRjaGVzJC5zdWJzY3JpYmUoKHBheWxvYWQpID0+IHtcbiAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInBhdGNoZXNcIixcbiAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yLCBwcm9wcy5wYXRjaGVzJF0sICRbMF0gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFsxXSA9IHByb3BzLnBhdGNoZXMkLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIFJlbmRlclNwYW4ocHJvcHMpIHtcbiAgY29uc3Qgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgbGVnYWN5U2NoZW1hID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIChzKSA9PiBzLmNvbnRleHQuZ2V0TGVnYWN5U2NoZW1hKCkpLCBzcGFuUmVmID0gdXNlUmVmKG51bGwpLCBwb3J0YWJsZVRleHRFZGl0b3IgPSB1c2VQb3J0YWJsZVRleHRFZGl0b3IoKSwgYmxvY2tTZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKCExKSwgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZSghMSksIHBhcmVudCA9IHByb3BzLmNoaWxkcmVuLnByb3BzLnBhcmVudCwgYmxvY2sgPSBwYXJlbnQgJiYgc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2socGFyZW50KSA/IHBhcmVudCA6IHZvaWQgMCwgcGF0aCA9IHVzZU1lbW8oKCkgPT4gYmxvY2sgPyBbe1xuICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgX2tleTogcHJvcHMubGVhZi5fa2V5XG4gIH1dIDogdm9pZCAwLCBbYmxvY2ssIHByb3BzLmxlYWYuX2tleV0pLCBkZWNvcmF0b3JTY2hlbWFUeXBlcyA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLm5hbWUpLCBkZWNvcmF0b3JzID0gdW5pcSgocHJvcHMubGVhZi5tYXJrcyA/PyBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JTY2hlbWFUeXBlcy5pbmNsdWRlcyhtYXJrKSkpLCBhbm5vdGF0aW9uTWFya0RlZnMgPSAocHJvcHMubGVhZi5tYXJrcyA/PyBbXSkuZmxhdE1hcCgobWFya18wKSA9PiB7XG4gICAgaWYgKGRlY29yYXRvclNjaGVtYVR5cGVzLmluY2x1ZGVzKG1hcmtfMCkpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbWFya0RlZl8wID0gYmxvY2s/Lm1hcmtEZWZzPy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmtfMCk7XG4gICAgcmV0dXJuIG1hcmtEZWZfMCA/IFttYXJrRGVmXzBdIDogW107XG4gIH0pLCBzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzID0gYW5ub3RhdGlvbk1hcmtEZWZzLmxlbmd0aCA+IDAgJiYgYmxvY2tTZWxlY3RlZDtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpIHtcbiAgICAgIHNldEZvY3VzZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWwgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgc2VsICYmIGlzRXF1YWwoc2VsLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpICYmIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBzZXRGb2N1c2VkKCEwKTtcbiAgICB9KTtcbiAgfSwgW3Nob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMsIHBhdGgsIHBvcnRhYmxlVGV4dEVkaXRvcl0pO1xuICBjb25zdCBzZXRTZWxlY3RlZEZyb21SYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgd2luU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghd2luU2VsZWN0aW9uKSB7XG4gICAgICBzZXRTZWxlY3RlZCghMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3aW5TZWxlY3Rpb24gJiYgd2luU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCByYW5nZSA9IHdpblNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgc3BhblJlZi5jdXJyZW50ICYmIHJhbmdlLmludGVyc2VjdHNOb2RlKHNwYW5SZWYuY3VycmVudCkgPyBzZXRTZWxlY3RlZCghMCkgOiBzZXRTZWxlY3RlZCghMSk7XG4gICAgfSBlbHNlXG4gICAgICBzZXRTZWxlY3RlZCghMSk7XG4gIH0sIFtzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9uQmx1ciA9IGVkaXRvckFjdG9yLm9uKFwiYmx1cnJlZFwiLCAoKSA9PiB7XG4gICAgICBzZXRGb2N1c2VkKCExKSwgc2V0U2VsZWN0ZWQoITEpO1xuICAgIH0pLCBvbkZvY3VzID0gZWRpdG9yQWN0b3Iub24oXCJmb2N1c2VkXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbF8wID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgc2VsXzAgJiYgaXNFcXVhbChzZWxfMC5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSAmJiBzZXRGb2N1c2VkKCEwKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKTtcbiAgICB9KSwgb25TZWxlY3Rpb24gPSBlZGl0b3JBY3Rvci5vbihcInNlbGVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnNlbGVjdGlvbiAmJiBpc0VxdWFsKGV2ZW50LnNlbGVjdGlvbi5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSA/IHNldEZvY3VzZWQoITApIDogc2V0Rm9jdXNlZCghMSksIHNldFNlbGVjdGVkRnJvbVJhbmdlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uQmx1ci51bnN1YnNjcmliZSgpLCBvbkZvY3VzLnVuc3Vic2NyaWJlKCksIG9uU2VsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2VkaXRvckFjdG9yLCBwYXRoLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNldFNlbGVjdGVkRnJvbVJhbmdlLCBzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzXSksIHVzZUVmZmVjdCgoKSA9PiBzZXRTZWxlY3RlZEZyb21SYW5nZSgpLCBbc2V0U2VsZWN0ZWRGcm9tUmFuZ2VdKTtcbiAgbGV0IGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIGZvciAoY29uc3QgbWFya18xIG9mIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBsZWdhY3lEZWNvcmF0b3JTY2hlbWFUeXBlID0gbGVnYWN5U2NoZW1hLmRlY29yYXRvcnMuZmluZCgoZGVjKSA9PiBkZWMudmFsdWUgPT09IG1hcmtfMSk7XG4gICAgcGF0aCAmJiBsZWdhY3lEZWNvcmF0b3JTY2hlbWFUeXBlICYmIHByb3BzLnJlbmRlckRlY29yYXRvciAmJiAoY2hpbGRyZW4gPSBwcm9wcy5yZW5kZXJEZWNvcmF0b3Ioe1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIHBhdGgsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHNjaGVtYVR5cGU6IGxlZ2FjeURlY29yYXRvclNjaGVtYVR5cGUsXG4gICAgICB2YWx1ZTogbWFya18xLFxuICAgICAgdHlwZTogbGVnYWN5RGVjb3JhdG9yU2NoZW1hVHlwZVxuICAgIH0pKTtcbiAgfVxuICBmb3IgKGNvbnN0IGFubm90YXRpb25NYXJrRGVmIG9mIGFubm90YXRpb25NYXJrRGVmcykge1xuICAgIGNvbnN0IGxlZ2FjeUFubm90YXRpb25TY2hlbWFUeXBlID0gbGVnYWN5U2NoZW1hLmFubm90YXRpb25zLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gYW5ub3RhdGlvbk1hcmtEZWYuX3R5cGUpO1xuICAgIGxlZ2FjeUFubm90YXRpb25TY2hlbWFUeXBlICYmIChibG9jayAmJiBwYXRoICYmIHByb3BzLnJlbmRlckFubm90YXRpb24gPyBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogcHJvcHMucmVuZGVyQW5ub3RhdGlvbih7XG4gICAgICBibG9jayxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogc3BhblJlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBwYXRoLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBzY2hlbWFUeXBlOiBsZWdhY3lBbm5vdGF0aW9uU2NoZW1hVHlwZSxcbiAgICAgIHZhbHVlOiBhbm5vdGF0aW9uTWFya0RlZixcbiAgICAgIHR5cGU6IGxlZ2FjeUFubm90YXRpb25TY2hlbWFUeXBlXG4gICAgfSkgfSkgOiBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbiB9KSk7XG4gIH1cbiAgaWYgKGJsb2NrICYmIHBhdGggJiYgcHJvcHMucmVuZGVyQ2hpbGQpIHtcbiAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKF9jaGlsZCkgPT4gX2NoaWxkLl9rZXkgPT09IHByb3BzLmxlYWYuX2tleSk7XG4gICAgY2hpbGQgJiYgKGNoaWxkcmVuID0gcHJvcHMucmVuZGVyQ2hpbGQoe1xuICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25NYXJrRGVmcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogc3BhblJlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBwYXRoLFxuICAgICAgc2NoZW1hVHlwZTogbGVnYWN5U2NoZW1hLnNwYW4sXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHZhbHVlOiBjaGlsZCxcbiAgICAgIHR5cGU6IGxlZ2FjeVNjaGVtYS5zcGFuXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IC4uLnByb3BzLmF0dHJpYnV0ZXMsIHJlZjogc3BhblJlZiwgY2hpbGRyZW4gfSk7XG59XG5jb25zdCBQTEFDRUhPTERFUl9TVFlMRSA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICBsZWZ0OiAwLFxuICByaWdodDogMFxufTtcbmZ1bmN0aW9uIFJlbmRlckxlYWYocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoMTIpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgc2NoZW1hID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIF90ZW1wKTtcbiAgaWYgKHByb3BzLmxlYWYuX3R5cGUgIT09IHNjaGVtYS5zcGFuLm5hbWUpXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzID8gKHQwID0gLyogQF9fUFVSRV9fICovIGpzeChSZW5kZXJTcGFuLCB7IC4uLnByb3BzIH0pLCAkWzBdID0gcHJvcHMsICRbMV0gPSB0MCkgOiB0MCA9ICRbMV07XG4gIGxldCByZW5kZXJlZFNwYW4gPSB0MDtcbiAgaWYgKHByb3BzLnJlbmRlclBsYWNlaG9sZGVyICYmIHByb3BzLmxlYWYucGxhY2Vob2xkZXIgJiYgcHJvcHMudGV4dC50ZXh0ID09PSBcIlwiKSB7XG4gICAgbGV0IHQxO1xuICAgICRbMl0gIT09IHByb3BzLnJlbmRlclBsYWNlaG9sZGVyID8gKHQxID0gcHJvcHMucmVuZGVyUGxhY2Vob2xkZXIoKSwgJFsyXSA9IHByb3BzLnJlbmRlclBsYWNlaG9sZGVyLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdO1xuICAgIGxldCB0MjtcbiAgICAkWzRdICE9PSB0MSA/ICh0MiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgc3R5bGU6IFBMQUNFSE9MREVSX1NUWUxFLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogdDEgfSksICRbNF0gPSB0MSwgJFs1XSA9IHQyKSA6IHQyID0gJFs1XTtcbiAgICBsZXQgdDM7XG4gICAgcmV0dXJuICRbNl0gIT09IHJlbmRlcmVkU3BhbiB8fCAkWzddICE9PSB0MiA/ICh0MyA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICB0MixcbiAgICAgIHJlbmRlcmVkU3BhblxuICAgIF0gfSksICRbNl0gPSByZW5kZXJlZFNwYW4sICRbN10gPSB0MiwgJFs4XSA9IHQzKSA6IHQzID0gJFs4XSwgdDM7XG4gIH1cbiAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uID0gcHJvcHMubGVhZi5yYW5nZURlY29yYXRpb247XG4gIGlmIChyYW5nZURlY29yYXRpb24pIHtcbiAgICBsZXQgdDE7XG4gICAgJFs5XSAhPT0gcmFuZ2VEZWNvcmF0aW9uIHx8ICRbMTBdICE9PSByZW5kZXJlZFNwYW4gPyAodDEgPSByYW5nZURlY29yYXRpb24uY29tcG9uZW50KHtcbiAgICAgIGNoaWxkcmVuOiByZW5kZXJlZFNwYW5cbiAgICB9KSwgJFs5XSA9IHJhbmdlRGVjb3JhdGlvbiwgJFsxMF0gPSByZW5kZXJlZFNwYW4sICRbMTFdID0gdDEpIDogdDEgPSAkWzExXSwgcmVuZGVyZWRTcGFuID0gdDE7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkU3Bhbjtcbn1cbmZ1bmN0aW9uIF90ZW1wKHMpIHtcbiAgcmV0dXJuIHMuY29udGV4dC5zY2hlbWE7XG59XG5mdW5jdGlvbiBSZW5kZXJUZXh0KHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDUpO1xuICBsZXQgdDA7XG4gIHJldHVybiAkWzBdICE9PSBwcm9wcy5hdHRyaWJ1dGVzIHx8ICRbMV0gIT09IHByb3BzLmNoaWxkcmVuIHx8ICRbMl0gIT09IHByb3BzLnRleHQuX2tleSB8fCAkWzNdICE9PSBwcm9wcy50ZXh0Ll90eXBlID8gKHQwID0gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyAuLi5wcm9wcy5hdHRyaWJ1dGVzLCBcImRhdGEtY2hpbGQta2V5XCI6IHByb3BzLnRleHQuX2tleSwgXCJkYXRhLWNoaWxkLW5hbWVcIjogcHJvcHMudGV4dC5fdHlwZSwgXCJkYXRhLWNoaWxkLXR5cGVcIjogXCJzcGFuXCIsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFswXSA9IHByb3BzLmF0dHJpYnV0ZXMsICRbMV0gPSBwcm9wcy5jaGlsZHJlbiwgJFsyXSA9IHByb3BzLnRleHQuX2tleSwgJFszXSA9IHByb3BzLnRleHQuX3R5cGUsICRbNF0gPSB0MCkgOiB0MCA9ICRbNF0sIHQwO1xufVxuY29uc3QgZGVidWckMSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aEhvdEtleXNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoSG90a2V5cyhlZGl0b3JBY3RvciwgcG9ydGFibGVUZXh0RWRpdG9yLCBob3RrZXlzRnJvbU9wdGlvbnMpIHtcbiAgY29uc3QgcmVzZXJ2ZWRIb3RrZXlzID0gW1wiZW50ZXJcIiwgXCJ0YWJcIiwgXCJzaGlmdFwiLCBcImRlbGV0ZVwiLCBcImVuZFwiXSwgYWN0aXZlSG90a2V5cyA9IGhvdGtleXNGcm9tT3B0aW9ucyA/PyB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlV2l0aEhvdEtleXMgPSAoZXZlbnQpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGFjdGl2ZUhvdGtleXMpLmZvckVhY2goKGNhdCkgPT4ge1xuICAgICAgICBpZiAoY2F0ID09PSBcIm1hcmtzXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVNYXJrID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVNYXJrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyayA9IHBvc3NpYmxlTWFya1tob3RrZXldO1xuICAgICAgICAgICAgICAgIGRlYnVnJDEoYEhvdEtleSAke2hvdGtleX0gdG8gdG9nZ2xlICR7bWFya31gKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKGNhdCA9PT0gXCJjdXN0b21cIilcbiAgICAgICAgICBmb3IgKGNvbnN0IGhvdGtleSBpbiBhY3RpdmVIb3RrZXlzW2NhdF0pIHtcbiAgICAgICAgICAgIGlmIChyZXNlcnZlZEhvdGtleXMuaW5jbHVkZXMoaG90a2V5KSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaG90a2V5ICR7aG90a2V5fSBpcyByZXNlcnZlZCFgKTtcbiAgICAgICAgICAgIGlmIChpc0hvdGtleShob3RrZXksIGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZUNvbW1hbmQgPSBhY3RpdmVIb3RrZXlzW2NhdF07XG4gICAgICAgICAgICAgIGlmIChwb3NzaWJsZUNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kID0gcG9zc2libGVDb21tYW5kW2hvdGtleV07XG4gICAgICAgICAgICAgICAgY29tbWFuZChldmVudCwgcG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IHNsYXRlT3BlcmF0aW9uQ2FsbGJhY2sgPSAoe1xuICBpbnB1dCxcbiAgc2VuZEJhY2tcbn0pID0+IHtcbiAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5O1xuICByZXR1cm4gaW5wdXQuc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICBvcC50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIiAmJiBzZW5kQmFjayh7XG4gICAgICB0eXBlOiBcInNsYXRlIG9wZXJhdGlvblwiLFxuICAgICAgb3BlcmF0aW9uOiBvcFxuICAgIH0pLCBvcmlnaW5hbEFwcGx5KG9wKTtcbiAgfSwgKCkgPT4ge1xuICAgIGlucHV0LnNsYXRlRWRpdG9yLmFwcGx5ID0gb3JpZ2luYWxBcHBseTtcbiAgfTtcbn0sIHJhbmdlRGVjb3JhdGlvbnNNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBldmVudHM6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcInVwZGF0ZSBwZW5kaW5nIHJhbmdlIGRlY29yYXRpb25zXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUmFuZ2VEZWNvcmF0aW9uczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50LnR5cGUgIT09IFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiID8gY29udGV4dC5wZW5kaW5nUmFuZ2VEZWNvcmF0aW9ucyA6IGV2ZW50LnJhbmdlRGVjb3JhdGlvbnNcbiAgICB9KSxcbiAgICBcInNldCB1cCBpbml0aWFsIHJhbmdlIGRlY29yYXRpb25zXCI6IGFzc2lnbih7XG4gICAgICBkZWNvcmF0ZWRSYW5nZXM6ICh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uU3RhdGUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByYW5nZURlY29yYXRpb24gb2YgY29udGV4dC5wZW5kaW5nUmFuZ2VEZWNvcmF0aW9ucykge1xuICAgICAgICAgIGNvbnN0IHNsYXRlUmFuZ2UgPSB0b1NsYXRlUmFuZ2UocmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbiwgY29udGV4dC5zbGF0ZUVkaXRvcik7XG4gICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKHNsYXRlUmFuZ2UpKSB7XG4gICAgICAgICAgICByYW5nZURlY29yYXRpb24ub25Nb3ZlZD8uKHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgICByYW5nZURlY29yYXRpb24sXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYW5nZURlY29yYXRpb25TdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbixcbiAgICAgICAgICAgIC4uLnNsYXRlUmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VEZWNvcmF0aW9uU3RhdGU7XG4gICAgICB9XG4gICAgfSksXG4gICAgXCJ1cGRhdGUgcmFuZ2UgZGVjb3JhdGlvbnNcIjogYXNzaWduKHtcbiAgICAgIGRlY29yYXRlZFJhbmdlczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgIT09IFwicmFuZ2UgZGVjb3JhdGlvbnMgdXBkYXRlZFwiKVxuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRlY29yYXRlZFJhbmdlcztcbiAgICAgICAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uU3RhdGUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByYW5nZURlY29yYXRpb24gb2YgZXZlbnQucmFuZ2VEZWNvcmF0aW9ucykge1xuICAgICAgICAgIGNvbnN0IHNsYXRlUmFuZ2UgPSB0b1NsYXRlUmFuZ2UocmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbiwgY29udGV4dC5zbGF0ZUVkaXRvcik7XG4gICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKHNsYXRlUmFuZ2UpKSB7XG4gICAgICAgICAgICByYW5nZURlY29yYXRpb24ub25Nb3ZlZD8uKHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgICByYW5nZURlY29yYXRpb24sXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYW5nZURlY29yYXRpb25TdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbixcbiAgICAgICAgICAgIC4uLnNsYXRlUmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VEZWNvcmF0aW9uU3RhdGU7XG4gICAgICB9XG4gICAgfSksXG4gICAgXCJtb3ZlIHJhbmdlIGRlY29yYXRpb25zXCI6IGFzc2lnbih7XG4gICAgICBkZWNvcmF0ZWRSYW5nZXM6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50eXBlICE9PSBcInNsYXRlIG9wZXJhdGlvblwiKVxuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRlY29yYXRlZFJhbmdlcztcbiAgICAgICAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uU3RhdGUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkZWNvcmF0ZWRSYW5nZSBvZiBjb250ZXh0LmRlY29yYXRlZFJhbmdlcykge1xuICAgICAgICAgIGNvbnN0IHNsYXRlUmFuZ2UgPSB0b1NsYXRlUmFuZ2UoZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbiwgY29udGV4dC5zbGF0ZUVkaXRvcik7XG4gICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKHNsYXRlUmFuZ2UpKSB7XG4gICAgICAgICAgICBkZWNvcmF0ZWRSYW5nZS5yYW5nZURlY29yYXRpb24ub25Nb3ZlZD8uKHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgICByYW5nZURlY29yYXRpb246IGRlY29yYXRlZFJhbmdlLnJhbmdlRGVjb3JhdGlvbixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdSYW5nZTtcbiAgICAgICAgICBpZiAobmV3UmFuZ2UgPSBtb3ZlUmFuZ2VCeU9wZXJhdGlvbihzbGF0ZVJhbmdlLCBldmVudC5vcGVyYXRpb24pLCBuZXdSYW5nZSAmJiBuZXdSYW5nZSAhPT0gc2xhdGVSYW5nZSB8fCBuZXdSYW5nZSA9PT0gbnVsbCAmJiBzbGF0ZVJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZVNlbGVjdGlvbiA9IG5ld1JhbmdlID8gc2xhdGVSYW5nZVRvU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICAgICAgZWRpdG9yOiBjb250ZXh0LnNsYXRlRWRpdG9yLFxuICAgICAgICAgICAgICByYW5nZTogbmV3UmFuZ2VcbiAgICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgICAgIGRlY29yYXRlZFJhbmdlLnJhbmdlRGVjb3JhdGlvbi5vbk1vdmVkPy4oe1xuICAgICAgICAgICAgICBuZXdTZWxlY3Rpb246IG5ld1JhbmdlU2VsZWN0aW9uLFxuICAgICAgICAgICAgICByYW5nZURlY29yYXRpb246IGRlY29yYXRlZFJhbmdlLnJhbmdlRGVjb3JhdGlvbixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdSYW5nZSAhPT0gbnVsbCAmJiByYW5nZURlY29yYXRpb25TdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIC4uLm5ld1JhbmdlIHx8IHNsYXRlUmFuZ2UsXG4gICAgICAgICAgICByYW5nZURlY29yYXRpb246IHtcbiAgICAgICAgICAgICAgLi4uZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLFxuICAgICAgICAgICAgICBzZWxlY3Rpb246IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IGNvbnRleHQuc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IG5ld1JhbmdlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlRGVjb3JhdGlvblN0YXRlO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFwiYXNzaWduIHJlYWRPbmx5XCI6IGFzc2lnbih7XG4gICAgICByZWFkT25seTogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50LnR5cGUgIT09IFwidXBkYXRlIHJlYWQgb25seVwiID8gY29udGV4dC5yZWFkT25seSA6IGV2ZW50LnJlYWRPbmx5XG4gICAgfSksXG4gICAgXCJpbmNyZW1lbnQgdXBkYXRlIGNvdW50XCI6IGFzc2lnbih7XG4gICAgICB1cGRhdGVDb3VudDogKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSkgPT4gY29udGV4dC51cGRhdGVDb3VudCArIDFcbiAgICB9KVxuICB9LFxuICBhY3RvcnM6IHtcbiAgICBcInNsYXRlIG9wZXJhdGlvbiBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soc2xhdGVPcGVyYXRpb25DYWxsYmFjaylcbiAgfSxcbiAgZ3VhcmRzOiB7XG4gICAgXCJoYXMgcGVuZGluZyByYW5nZSBkZWNvcmF0aW9uc1wiOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IGNvbnRleHQucGVuZGluZ1JhbmdlRGVjb3JhdGlvbnMubGVuZ3RoID4gMCxcbiAgICBcImhhcyByYW5nZSBkZWNvcmF0aW9uc1wiOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IGNvbnRleHQuZGVjb3JhdGVkUmFuZ2VzLmxlbmd0aCA+IDAsXG4gICAgXCJoYXMgZGlmZmVyZW50IGRlY29yYXRpb25zXCI6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudHlwZSAhPT0gXCJyYW5nZSBkZWNvcmF0aW9ucyB1cGRhdGVkXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUmFuZ2VEZWNvcmF0aW9ucyA9IGNvbnRleHQuZGVjb3JhdGVkUmFuZ2VzLm1hcCgoZGVjb3JhdGVkUmFuZ2UpID0+ICh7XG4gICAgICAgIGFuY2hvcjogZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbj8uYW5jaG9yLFxuICAgICAgICBmb2N1czogZGVjb3JhdGVkUmFuZ2UucmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbj8uZm9jdXNcbiAgICAgIH0pKSwgbmV3UmFuZ2VEZWNvcmF0aW9ucyA9IGV2ZW50LnJhbmdlRGVjb3JhdGlvbnMubWFwKChyYW5nZURlY29yYXRpb24pID0+ICh7XG4gICAgICAgIGFuY2hvcjogcmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbj8uYW5jaG9yLFxuICAgICAgICBmb2N1czogcmFuZ2VEZWNvcmF0aW9uLnNlbGVjdGlvbj8uZm9jdXNcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiAhaXNFcXVhbChleGlzdGluZ1JhbmdlRGVjb3JhdGlvbnMsIG5ld1JhbmdlRGVjb3JhdGlvbnMpO1xuICAgIH0sXG4gICAgXCJub3QgcmVhZCBvbmx5XCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gIWNvbnRleHQucmVhZE9ubHksXG4gICAgXCJzaG91bGQgc2tpcCBzZXR1cFwiOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IGNvbnRleHQuc2tpcFNldHVwXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJyYW5nZSBkZWNvcmF0aW9uc1wiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgcmVhZE9ubHk6IGlucHV0LnJlYWRPbmx5LFxuICAgIHBlbmRpbmdSYW5nZURlY29yYXRpb25zOiBpbnB1dC5yYW5nZURlY29yYXRpb25zLFxuICAgIGRlY29yYXRlZFJhbmdlczogW10sXG4gICAgc2tpcFNldHVwOiBpbnB1dC5za2lwU2V0dXAsXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgc2xhdGVFZGl0b3I6IGlucHV0LnNsYXRlRWRpdG9yLFxuICAgIHVwZGF0ZUNvdW50OiAwXG4gIH0pLFxuICBpbnZva2U6IHtcbiAgICBzcmM6IFwic2xhdGUgb3BlcmF0aW9uIGxpc3RlbmVyXCIsXG4gICAgaW5wdXQ6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gKHtcbiAgICAgIHNsYXRlRWRpdG9yOiBjb250ZXh0LnNsYXRlRWRpdG9yXG4gICAgfSlcbiAgfSxcbiAgb246IHtcbiAgICBcInVwZGF0ZSByZWFkIG9ubHlcIjoge1xuICAgICAgYWN0aW9uczogW1wiYXNzaWduIHJlYWRPbmx5XCJdXG4gICAgfVxuICB9LFxuICBpbml0aWFsOiBcInNldHRpbmcgdXBcIixcbiAgc3RhdGVzOiB7XG4gICAgXCJzZXR0aW5nIHVwXCI6IHtcbiAgICAgIGFsd2F5czogW3tcbiAgICAgICAgZ3VhcmQ6IGFuZChbXCJzaG91bGQgc2tpcCBzZXR1cFwiLCBcImhhcyBwZW5kaW5nIHJhbmdlIGRlY29yYXRpb25zXCJdKSxcbiAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgIGFjdGlvbnM6IFtcInNldCB1cCBpbml0aWFsIHJhbmdlIGRlY29yYXRpb25zXCIsIFwiaW5jcmVtZW50IHVwZGF0ZSBjb3VudFwiXVxuICAgICAgfSwge1xuICAgICAgICBndWFyZDogXCJzaG91bGQgc2tpcCBzZXR1cFwiLFxuICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIlxuICAgICAgfV0sXG4gICAgICBvbjoge1xuICAgICAgICBcInJhbmdlIGRlY29yYXRpb25zIHVwZGF0ZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtcInVwZGF0ZSBwZW5kaW5nIHJhbmdlIGRlY29yYXRpb25zXCJdXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiBbe1xuICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgIGd1YXJkOiBcImhhcyBwZW5kaW5nIHJhbmdlIGRlY29yYXRpb25zXCIsXG4gICAgICAgICAgYWN0aW9uczogW1wic2V0IHVwIGluaXRpYWwgcmFuZ2UgZGVjb3JhdGlvbnNcIiwgXCJpbmNyZW1lbnQgdXBkYXRlIGNvdW50XCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIlxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVhZHk6IHtcbiAgICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgICAgb246IHtcbiAgICAgICAgXCJyYW5nZSBkZWNvcmF0aW9ucyB1cGRhdGVkXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiLmlkbGVcIixcbiAgICAgICAgICBndWFyZDogXCJoYXMgZGlmZmVyZW50IGRlY29yYXRpb25zXCIsXG4gICAgICAgICAgYWN0aW9uczogW1widXBkYXRlIHJhbmdlIGRlY29yYXRpb25zXCIsIFwiaW5jcmVtZW50IHVwZGF0ZSBjb3VudFwiXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIGlkbGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJzbGF0ZSBvcGVyYXRpb25cIjoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwibW92aW5nIHJhbmdlIGRlY29yYXRpb25zXCIsXG4gICAgICAgICAgICAgIGd1YXJkOiBhbmQoW1wiaGFzIHJhbmdlIGRlY29yYXRpb25zXCIsIFwibm90IHJlYWQgb25seVwiXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibW92aW5nIHJhbmdlIGRlY29yYXRpb25zXCI6IHtcbiAgICAgICAgICBlbnRyeTogW1wibW92ZSByYW5nZSBkZWNvcmF0aW9uc1wiXSxcbiAgICAgICAgICBhbHdheXM6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdGUocmFuZ2VEZWNvcmF0aW9uQWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKFtub2RlLCBwYXRoXSkge1xuICAgIGlmIChpc0VxdWFsVG9FbXB0eUVkaXRvcihyYW5nZURlY29yYXRpb25BY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2xhdGVFZGl0b3IuY2hpbGRyZW4sIHJhbmdlRGVjb3JhdGlvbkFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEpKVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlaG9sZGVyOiAhMFxuICAgICAgfV07XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICghRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBibG9ja0luZGV4ID0gcGF0aC5hdCgwKTtcbiAgICByZXR1cm4gYmxvY2tJbmRleCA9PT0gdm9pZCAwID8gW10gOiByYW5nZURlY29yYXRpb25BY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuZGVjb3JhdGVkUmFuZ2VzLmZpbHRlcigoZGVjb3JhdGVkUmFuZ2UpID0+IFJhbmdlLmlzQ29sbGFwc2VkKGRlY29yYXRlZFJhbmdlKSA/IG5vZGUuY2hpbGRyZW4uc29tZSgoXywgY2hpbGRJbmRleCkgPT4gUGF0aC5lcXVhbHMoZGVjb3JhdGVkUmFuZ2UuYW5jaG9yLnBhdGgsIFtibG9ja0luZGV4LCBjaGlsZEluZGV4XSkgJiYgUGF0aC5lcXVhbHMoZGVjb3JhdGVkUmFuZ2UuZm9jdXMucGF0aCwgW2Jsb2NrSW5kZXgsIGNoaWxkSW5kZXhdKSkgOiBSYW5nZS5pbnRlcnNlY3Rpb24oZGVjb3JhdGVkUmFuZ2UsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9KSB8fCBSYW5nZS5pbmNsdWRlcyhkZWNvcmF0ZWRSYW5nZSwgcGF0aCkpO1xuICB9O1xufVxuY29uc3QgZGVidWcgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OkVkaXRhYmxlXCIpLCBQb3J0YWJsZVRleHRFZGl0YWJsZSA9IGZvcndhcmRSZWYoZnVuY3Rpb24ocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgaG90a2V5cyxcbiAgICBvbkJsdXIsXG4gICAgb25Gb2N1cyxcbiAgICBvbkJlZm9yZUlucHV0LFxuICAgIG9uUGFzdGUsXG4gICAgb25Db3B5LFxuICAgIG9uQ3V0LFxuICAgIG9uQ2xpY2ssXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25EcmFnLFxuICAgIG9uRHJhZ0VuZCxcbiAgICBvbkRyYWdFbnRlcixcbiAgICBvbkRyYWdPdmVyLFxuICAgIG9uRHJvcCxcbiAgICBvbkRyYWdMZWF2ZSxcbiAgICByYW5nZURlY29yYXRpb25zLFxuICAgIHJlbmRlckFubm90YXRpb24sXG4gICAgcmVuZGVyQmxvY2ssXG4gICAgcmVuZGVyQ2hpbGQsXG4gICAgcmVuZGVyRGVjb3JhdG9yLFxuICAgIHJlbmRlckxpc3RJdGVtLFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlclN0eWxlLFxuICAgIHNlbGVjdGlvbjogcHJvcHNTZWxlY3Rpb24sXG4gICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgc3BlbGxDaGVjayxcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSA9IHByb3BzLCBwb3J0YWJsZVRleHRFZGl0b3IgPSB1c2VQb3J0YWJsZVRleHRFZGl0b3IoKSwgcmVmID0gdXNlUmVmKG51bGwpLCBbZWRpdGFibGVFbGVtZW50LCBzZXRFZGl0YWJsZUVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCksIFtoYXNJbnZhbGlkVmFsdWUsIHNldEhhc0ludmFsaWRWYWx1ZV0gPSB1c2VTdGF0ZSghMSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiByZWYuY3VycmVudCk7XG4gIGNvbnN0IGVkaXRvckFjdG9yID0gdXNlQ29udGV4dChFZGl0b3JBY3RvckNvbnRleHQpLCByZWFkT25seSA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCAocykgPT4gcy5tYXRjaGVzKHtcbiAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gIH0pKSwgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZSgpLCByYW5nZURlY29yYXRpb25zQWN0b3IgPSB1c2VBY3RvclJlZihyYW5nZURlY29yYXRpb25zTWFjaGluZSwge1xuICAgIGlucHV0OiB7XG4gICAgICByYW5nZURlY29yYXRpb25zOiByYW5nZURlY29yYXRpb25zID8/IFtdLFxuICAgICAgcmVhZE9ubHksXG4gICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICBzbGF0ZUVkaXRvcixcbiAgICAgIHNraXBTZXR1cDogIWVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIHNldHVwOiBcInNldHRpbmcgdXBcIlxuICAgICAgfSlcbiAgICB9XG4gIH0pO1xuICB1c2VTZWxlY3RvcihyYW5nZURlY29yYXRpb25zQWN0b3IsIChzXzApID0+IHNfMC5jb250ZXh0LnVwZGF0ZUNvdW50KTtcbiAgY29uc3QgZGVjb3JhdGUgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZURlY29yYXRlKHJhbmdlRGVjb3JhdGlvbnNBY3RvciksIFtyYW5nZURlY29yYXRpb25zQWN0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByYW5nZURlY29yYXRpb25zQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSByZWFkIG9ubHlcIixcbiAgICAgIHJlYWRPbmx5XG4gICAgfSk7XG4gIH0sIFtyYW5nZURlY29yYXRpb25zQWN0b3IsIHJlYWRPbmx5XSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmFuZ2VEZWNvcmF0aW9uc0FjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJyYW5nZSBkZWNvcmF0aW9ucyB1cGRhdGVkXCIsXG4gICAgICByYW5nZURlY29yYXRpb25zOiByYW5nZURlY29yYXRpb25zID8/IFtdXG4gICAgfSk7XG4gIH0sIFtyYW5nZURlY29yYXRpb25zQWN0b3IsIHJhbmdlRGVjb3JhdGlvbnNdKSwgdXNlTWVtbygoKSA9PiByZWFkT25seSA/IHNsYXRlRWRpdG9yIDogY3JlYXRlV2l0aEhvdGtleXMoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5cykoc2xhdGVFZGl0b3IpLCBbZWRpdG9yQWN0b3IsIGhvdGtleXMsIHBvcnRhYmxlVGV4dEVkaXRvciwgcmVhZE9ubHksIHNsYXRlRWRpdG9yXSk7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnQgPSB1c2VDYWxsYmFjaygoZVByb3BzKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFJlbmRlckVsZW1lbnQsIHsgLi4uZVByb3BzLCByZWFkT25seSwgcmVuZGVyQmxvY2ssIHJlbmRlckNoaWxkLCByZW5kZXJMaXN0SXRlbSwgcmVuZGVyU3R5bGUsIHNwZWxsQ2hlY2sgfSksIFtzcGVsbENoZWNrLCByZWFkT25seSwgcmVuZGVyQmxvY2ssIHJlbmRlckNoaWxkLCByZW5kZXJMaXN0SXRlbSwgcmVuZGVyU3R5bGVdKSwgcmVuZGVyTGVhZiA9IHVzZUNhbGxiYWNrKChsZWFmUHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyTGVhZiwgeyAuLi5sZWFmUHJvcHMsIHJlYWRPbmx5LCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZW5kZXJQbGFjZWhvbGRlciB9KSwgW3JlYWRPbmx5LCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZW5kZXJQbGFjZWhvbGRlcl0pLCByZW5kZXJUZXh0ID0gdXNlQ2FsbGJhY2soKHByb3BzXzApID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVuZGVyVGV4dCwgeyAuLi5wcm9wc18wIH0pLCBbXSksIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHByb3BzU2VsZWN0aW9uKSB7XG4gICAgICBkZWJ1ZyhgU2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShwcm9wc1NlbGVjdGlvbil9YCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gbm9ybWFsaXplU2VsZWN0aW9uKHByb3BzU2VsZWN0aW9uLCBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvci5jaGlsZHJlbiwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lKSk7XG4gICAgICBpZiAobm9ybWFsaXplZFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBkZWJ1ZyhgTm9ybWFsaXplZCBzZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZWxlY3Rpb24pfWApO1xuICAgICAgICBjb25zdCBzbGF0ZVJhbmdlID0gdG9TbGF0ZVJhbmdlKG5vcm1hbGl6ZWRTZWxlY3Rpb24sIHNsYXRlRWRpdG9yKTtcbiAgICAgICAgc2xhdGVSYW5nZSAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHNsYXRlUmFuZ2UpLCBzbGF0ZUVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG8pID0+IG8udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHx8IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm90aWZ5LnNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogbm9ybWFsaXplZFNlbGVjdGlvblxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZWRpdG9yQWN0b3IsIHByb3BzU2VsZWN0aW9uLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9uUmVhZHkgPSBlZGl0b3JBY3Rvci5vbihcInJlYWR5XCIsICgpID0+IHtcbiAgICAgIHJhbmdlRGVjb3JhdGlvbnNBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJyZWFkeVwiXG4gICAgICB9KSwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcygpO1xuICAgIH0pLCBvbkludmFsaWRWYWx1ZSA9IGVkaXRvckFjdG9yLm9uKFwiaW52YWxpZCB2YWx1ZVwiLCAoKSA9PiB7XG4gICAgICBzZXRIYXNJbnZhbGlkVmFsdWUoITApO1xuICAgIH0pLCBvblZhbHVlQ2hhbmdlZCA9IGVkaXRvckFjdG9yLm9uKFwidmFsdWUgY2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICBzZXRIYXNJbnZhbGlkVmFsdWUoITEpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvblJlYWR5LnVuc3Vic2NyaWJlKCksIG9uSW52YWxpZFZhbHVlLnVuc3Vic2NyaWJlKCksIG9uVmFsdWVDaGFuZ2VkLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW3JhbmdlRGVjb3JhdGlvbnNBY3RvciwgZWRpdG9yQWN0b3IsIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1NlbGVjdGlvbiAmJiAhaGFzSW52YWxpZFZhbHVlICYmIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgfSwgW2hhc0ludmFsaWRWYWx1ZSwgcHJvcHNTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKTtcbiAgY29uc3QgaGFuZGxlQ29weSA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgIGlmIChvbkNvcHkpXG4gICAgICBvbkNvcHkoZXZlbnQpICE9PSB2b2lkIDAgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlIGlmIChldmVudC5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNsYXRlRWRpdG9yLnNlbGVjdGlvbiA/IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgICAgcmFuZ2U6IHNsYXRlRWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSkgOiB2b2lkIDAsIHBvc2l0aW9uID0gc2VsZWN0aW9uID8ge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gOiB2b2lkIDA7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHBvc2l0aW9uIGZvciBjb3B5IGV2ZW50XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJjbGlwYm9hcmQuY29weVwiLFxuICAgICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IGV2ZW50Lm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbb25Db3B5LCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKSwgaGFuZGxlQ3V0ID0gdXNlQ2FsbGJhY2soKGV2ZW50XzApID0+IHtcbiAgICBpZiAob25DdXQpXG4gICAgICBvbkN1dChldmVudF8wKSAhPT0gdm9pZCAwICYmIGV2ZW50XzAucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlIGlmIChldmVudF8wLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgIGV2ZW50XzAuc3RvcFByb3BhZ2F0aW9uKCksIGV2ZW50XzAucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbl8wID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNlbGVjdGlvbiwgcG9zaXRpb25fMCA9IHNlbGVjdGlvbl8wID8ge1xuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbl8wXG4gICAgICB9IDogdm9pZCAwO1xuICAgICAgaWYgKCFwb3NpdGlvbl8wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHBvc2l0aW9uIGZvciBjdXQgZXZlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImNsaXBib2FyZC5jdXRcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8wLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl8wXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8wXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtvbkN1dCwgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZVBhc3RlID0gdXNlQ2FsbGJhY2soKGV2ZW50XzEpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGZyb21TbGF0ZVZhbHVlKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChzbGF0ZUVkaXRvcikpLCBwYXRoID0gKHNsYXRlRWRpdG9yLnNlbGVjdGlvbiA/IHNsYXRlUmFuZ2VUb1NlbGVjdGlvbih7XG4gICAgICBzY2hlbWE6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgcmFuZ2U6IHNsYXRlRWRpdG9yLnNlbGVjdGlvblxuICAgIH0pIDogbnVsbCk/LmZvY3VzLnBhdGggfHwgW10sIG9uUGFzdGVSZXN1bHQgPSBvblBhc3RlPy4oe1xuICAgICAgZXZlbnQ6IGV2ZW50XzEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHBhdGgsXG4gICAgICBzY2hlbWFUeXBlczogcG9ydGFibGVUZXh0RWRpdG9yLnNjaGVtYVR5cGVzXG4gICAgfSk7XG4gICAgaWYgKG9uUGFzdGVSZXN1bHQgfHwgIXNsYXRlRWRpdG9yLnNlbGVjdGlvbilcbiAgICAgIGV2ZW50XzEucHJldmVudERlZmF1bHQoKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibm90aWZ5LmxvYWRpbmdcIlxuICAgICAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHRfMSkgPT4ge1xuICAgICAgICBpZiAoZGVidWcoXCJDdXN0b20gcGFzdGUgZnVuY3Rpb24gZnJvbSBjbGllbnQgcmVzb2x2ZWRcIiwgcmVzdWx0XzEpLCAhcmVzdWx0XzEgfHwgIXJlc3VsdF8xLmluc2VydCkge1xuICAgICAgICAgIGRlYnVnKFwiTm8gcmVzdWx0IGZyb20gY3VzdG9tIHBhc3RlIGhhbmRsZXIsIHBhc3Rpbmcgbm9ybWFsbHlcIik7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uXzEgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2VsZWN0aW9uLCBwb3NpdGlvbl8xID0gc2VsZWN0aW9uXzEgPyB7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbl8xXG4gICAgICAgICAgfSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uXzEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHBvc2l0aW9uIGZvciBwYXN0ZSBldmVudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiY2xpcGJvYXJkLnBhc3RlXCIsXG4gICAgICAgICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8xLmNsaXBib2FyZERhdGFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXzFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XzFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHJlc3VsdF8xLmluc2VydCA/IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcImluc2VydC5ibG9ja3NcIixcbiAgICAgICAgICAgIGJsb2NrczogcGFyc2VCbG9ja3Moe1xuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBibG9ja3M6IHJlc3VsdF8xLmluc2VydCxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hLZXlzOiAhMCxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkczogITBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yXG4gICAgICAgIH0pIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHRfMSk7XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IChjb25zb2xlLndhcm4oZXJyb3IpLCBlcnJvcikpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGlmeS5kb25lIGxvYWRpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKGV2ZW50XzEubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgZXZlbnRfMS5wcmV2ZW50RGVmYXVsdCgpLCBldmVudF8xLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uXzIgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2VsZWN0aW9uLCBwb3NpdGlvbl8yID0gc2VsZWN0aW9uXzIgPyB7XG4gICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uXzJcbiAgICAgIH0gOiB2b2lkIDA7XG4gICAgICBpZiAoIXBvc2l0aW9uXzIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgcG9zaXRpb24gZm9yIHBhc3RlIGV2ZW50XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJjbGlwYm9hcmQucGFzdGVcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8xLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl8yXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8xXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVidWcoXCJObyByZXN1bHQgZnJvbSBjdXN0b20gcGFzdGUgaGFuZGxlciwgcGFzdGluZyBub3JtYWxseVwiKTtcbiAgfSwgW2VkaXRvckFjdG9yLCBvblBhc3RlLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZU9uRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnRfMikgPT4ge1xuICAgIGlmIChvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnRfMiksICFldmVudF8yLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25fMyA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgIHNlbGVjdGlvbl8zID09PSBudWxsICYmIChUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgRWRpdG9yLnN0YXJ0KHNsYXRlRWRpdG9yLCBbXSkpLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibm90aWZ5LmZvY3VzZWRcIixcbiAgICAgICAgZXZlbnQ6IGV2ZW50XzJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgc2VsZWN0aW9uXzMgPT09IG5ld1NlbGVjdGlvbiAmJiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJub3RpZnkuc2VsZWN0aW9uXCIsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uXzNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvckFjdG9yLCBvbkZvY3VzLCBzbGF0ZUVkaXRvciwgcG9ydGFibGVUZXh0RWRpdG9yXSksIGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGV2ZW50XzMpID0+IHtcbiAgICBpZiAob25DbGljayAmJiBvbkNsaWNrKGV2ZW50XzMpLCBldmVudF8zLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzMuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3NpdGlvbl8zID0gZ2V0RXZlbnRQb3NpdGlvbih7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgZXZlbnQ6IGV2ZW50XzMubmF0aXZlRXZlbnRcbiAgICB9KTtcbiAgICBwb3NpdGlvbl8zICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcIm1vdXNlLmNsaWNrXCIsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl8zXG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8zXG4gICAgfSk7XG4gIH0sIFtvbkNsaWNrLCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKSwgaGFuZGxlT25CbHVyID0gdXNlQ2FsbGJhY2soKGV2ZW50XzQpID0+IHtcbiAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50XzQpLCBldmVudF80LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5vdGlmeS5ibHVycmVkXCIsXG4gICAgICBldmVudDogZXZlbnRfNFxuICAgIH0pO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uQmx1cl0pLCBoYW5kbGVPbkJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soKGV2ZW50XzUpID0+IHtcbiAgICBvbkJlZm9yZUlucHV0ICYmIG9uQmVmb3JlSW5wdXQoZXZlbnRfNSk7XG4gIH0sIFtvbkJlZm9yZUlucHV0XSksIHZhbGlkYXRlU2VsZWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Qoc2xhdGVFZGl0b3IpLCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IHJvb3Q7XG4gICAgaWYgKHJlZi5jdXJyZW50ICE9PSBhY3RpdmVFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhzbGF0ZUVkaXRvcikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24gfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdET01SYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdET01SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2Uoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAobmV3RE9NUmFuZ2Uuc3RhcnRPZmZzZXQgIT09IGV4aXN0aW5nRE9NUmFuZ2Uuc3RhcnRPZmZzZXQgfHwgbmV3RE9NUmFuZ2UuZW5kT2Zmc2V0ICE9PSBleGlzdGluZ0RPTVJhbmdlLmVuZE9mZnNldCkgJiYgKGRlYnVnKFwiRE9NIHJhbmdlIG91dCBvZiBzeW5jLCB2YWxpZGF0aW5nIHNlbGVjdGlvblwiKSwgZG9tU2VsZWN0aW9uPy5yZW1vdmVBbGxSYW5nZXMoKSwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKG5ld0RPTVJhbmdlKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBkZWJ1ZyhcIkNvdWxkIG5vdCByZXNvbHZlIHNlbGVjdGlvbiwgc2VsZWN0aW5nIHRvcCBkb2N1bWVudFwiKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIFswLCAwXSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9LCBbcmVmLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlZGl0YWJsZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih2YWxpZGF0ZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGVkaXRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogITEsXG4gICAgICAgIGF0dHJpYnV0ZXM6ICExLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiAhMSxcbiAgICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgICAgc3VidHJlZTogITBcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt2YWxpZGF0ZVNlbGVjdGlvbiwgZWRpdGFibGVFbGVtZW50XSk7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjaygoZXZlbnRfNikgPT4ge1xuICAgIHByb3BzLm9uS2V5RG93biAmJiBwcm9wcy5vbktleURvd24oZXZlbnRfNiksIGV2ZW50XzYuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgc2xhdGVFZGl0b3IucHRlV2l0aEhvdEtleXMoZXZlbnRfNiksIGV2ZW50XzYuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwia2V5Ym9hcmQua2V5ZG93blwiLFxuICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgIGtleTogZXZlbnRfNi5rZXksXG4gICAgICAgICAgY29kZTogZXZlbnRfNi5jb2RlLFxuICAgICAgICAgIGFsdEtleTogZXZlbnRfNi5hbHRLZXksXG4gICAgICAgICAgY3RybEtleTogZXZlbnRfNi5jdHJsS2V5LFxuICAgICAgICAgIG1ldGFLZXk6IGV2ZW50XzYubWV0YUtleSxcbiAgICAgICAgICBzaGlmdEtleTogZXZlbnRfNi5zaGlmdEtleVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF82XG4gICAgfSk7XG4gIH0sIFtwcm9wcywgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZUtleVVwID0gdXNlQ2FsbGJhY2soKGV2ZW50XzcpID0+IHtcbiAgICBwcm9wcy5vbktleVVwICYmIHByb3BzLm9uS2V5VXAoZXZlbnRfNyksIGV2ZW50XzcuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFwia2V5Ym9hcmQua2V5dXBcIixcbiAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICBrZXk6IGV2ZW50Xzcua2V5LFxuICAgICAgICAgIGNvZGU6IGV2ZW50XzcuY29kZSxcbiAgICAgICAgICBhbHRLZXk6IGV2ZW50XzcuYWx0S2V5LFxuICAgICAgICAgIGN0cmxLZXk6IGV2ZW50XzcuY3RybEtleSxcbiAgICAgICAgICBtZXRhS2V5OiBldmVudF83Lm1ldGFLZXksXG4gICAgICAgICAgc2hpZnRLZXk6IGV2ZW50Xzcuc2hpZnRLZXlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRfN1xuICAgIH0pO1xuICB9LCBbcHJvcHMsIGVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvcl0pLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9PT0gbnVsbCA/IG5vb3AgOiAoX2VkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocG9ydGFibGVUZXh0RWRpdG9yLCBkb21SYW5nZSk7XG4gICAgICB9O1xuICB9LCBbcG9ydGFibGVUZXh0RWRpdG9yLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvciksIHNldEVkaXRhYmxlRWxlbWVudChyZWYuY3VycmVudCk7XG4gIH0sIFtzbGF0ZUVkaXRvciwgcmVmXSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgd2luZG93XzAgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coc2xhdGVFZGl0b3IpLCBvbkRyYWdFbmRfMCA9ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImRyYWdlbmRcIlxuICAgICAgfSk7XG4gICAgfSwgb25Ecm9wXzAgPSAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJkcm9wXCJcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdpbmRvd18wLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIG9uRHJhZ0VuZF8wKSwgd2luZG93XzAuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgb25Ecm9wXzApLCAoKSA9PiB7XG4gICAgICB3aW5kb3dfMC5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCBvbkRyYWdFbmRfMCksIHdpbmRvd18wLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIG9uRHJvcF8wKTtcbiAgICB9O1xuICB9LCBbc2xhdGVFZGl0b3IsIGVkaXRvckFjdG9yXSk7XG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IHVzZUNhbGxiYWNrKChldmVudF84KSA9PiB7XG4gICAgaWYgKG9uRHJhZ1N0YXJ0Py4oZXZlbnRfOCksIGV2ZW50XzguaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnRfOC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvc2l0aW9uXzQgPSBnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfOC5uYXRpdmVFdmVudFxuICAgIH0pO1xuICAgIGlmICghcG9zaXRpb25fNCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgcG9zaXRpb24gZm9yIGRyYWdzdGFydCBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc25hcHNob3QgPSBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICBlZGl0b3JBY3RvclNuYXBzaG90OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogc2xhdGVFZGl0b3JcbiAgICB9KSwgZHJhZ1NlbGVjdGlvbiA9IGdldERyYWdTZWxlY3Rpb24oe1xuICAgICAgZXZlbnRTZWxlY3Rpb246IHBvc2l0aW9uXzQuc2VsZWN0aW9uLFxuICAgICAgc25hcHNob3RcbiAgICB9KSwgc2VsZWN0aW5nRW50aXJlQmxvY2tzID0gaXNTZWxlY3RpbmdFbnRpcmVCbG9ja3Moe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICAuLi5zbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KSwgZHJhZ0dob3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZHJhZ2dlZERvbU5vZGVzID0gZ2V0U2VsZWN0aW9uRG9tTm9kZXMoe1xuICAgICAgc25hcHNob3Q6IHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbGF0ZUVkaXRvclxuICAgIH0pO1xuICAgIGlmIChzZWxlY3RpbmdFbnRpcmVCbG9ja3MpIHtcbiAgICAgIGNvbnN0IGNsb25lZEJsb2NrTm9kZXMgPSBkcmFnZ2VkRG9tTm9kZXMuYmxvY2tOb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuY2xvbmVOb2RlKCEwKSk7XG4gICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNsb25lZEJsb2NrTm9kZXMpXG4gICAgICAgIGJsb2NrIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKGJsb2NrLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiKSwgZHJhZ0dob3N0LmFwcGVuZENoaWxkKGJsb2NrKTtcbiAgICAgIGNvbnN0IGN1c3RvbUdob3N0ID0gZHJhZ0dob3N0LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wdC1kcmFnLWdob3N0LWVsZW1lbnRdXCIpO1xuICAgICAgaWYgKGN1c3RvbUdob3N0ICYmIGRyYWdHaG9zdC5yZXBsYWNlQ2hpbGRyZW4oY3VzdG9tR2hvc3QpLCBkcmFnR2hvc3Quc2V0QXR0cmlidXRlKFwiZGF0YS1kcmFnZ2VkXCIsIFwiXCIpLCBkcmFnR2hvc3Quc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGRyYWdHaG9zdC5zdHlsZS5sZWZ0ID0gXCItOTk5OTlweFwiLCBkcmFnR2hvc3Quc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0dob3N0KSwgY3VzdG9tR2hvc3QpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tR2hvc3RSZWN0ID0gY3VzdG9tR2hvc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSBldmVudF84LmNsaWVudFggLSBjdXN0b21HaG9zdFJlY3QubGVmdCwgeSA9IGV2ZW50XzguY2xpZW50WSAtIGN1c3RvbUdob3N0UmVjdC50b3A7XG4gICAgICAgIGRyYWdHaG9zdC5zdHlsZS53aWR0aCA9IGAke2N1c3RvbUdob3N0UmVjdC53aWR0aH1weGAsIGRyYWdHaG9zdC5zdHlsZS5oZWlnaHQgPSBgJHtjdXN0b21HaG9zdFJlY3QuaGVpZ2h0fXB4YCwgZXZlbnRfOC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdHaG9zdCwgeCwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBibG9ja3NEb21SZWN0ID0gZ2V0Q29tcG91bmRDbGllbnRSZWN0KGRyYWdnZWREb21Ob2Rlcy5ibG9ja05vZGVzKSwgeF8wID0gZXZlbnRfOC5jbGllbnRYIC0gYmxvY2tzRG9tUmVjdC5sZWZ0LCB5XzAgPSBldmVudF84LmNsaWVudFkgLSBibG9ja3NEb21SZWN0LnRvcDtcbiAgICAgICAgZHJhZ0dob3N0LnN0eWxlLndpZHRoID0gYCR7YmxvY2tzRG9tUmVjdC53aWR0aH1weGAsIGRyYWdHaG9zdC5zdHlsZS5oZWlnaHQgPSBgJHtibG9ja3NEb21SZWN0LmhlaWdodH1weGAsIGV2ZW50XzguZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnR2hvc3QsIHhfMCwgeV8wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2xvbmVkQ2hpbGROb2RlcyA9IGRyYWdnZWREb21Ob2Rlcy5jaGlsZE5vZGVzLm1hcCgobm9kZV8wKSA9PiBub2RlXzAuY2xvbmVOb2RlKCEwKSk7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNsb25lZENoaWxkTm9kZXMpXG4gICAgICAgIGRyYWdHaG9zdC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBkcmFnR2hvc3Quc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGRyYWdHaG9zdC5zdHlsZS5sZWZ0ID0gXCItOTk5OTlweFwiLCBkcmFnR2hvc3Quc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0dob3N0KTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuRG9tUmVjdCA9IGdldENvbXBvdW5kQ2xpZW50UmVjdChkcmFnZ2VkRG9tTm9kZXMuY2hpbGROb2RlcyksIHhfMSA9IGV2ZW50XzguY2xpZW50WCAtIGNoaWxkcmVuRG9tUmVjdC5sZWZ0LCB5XzEgPSBldmVudF84LmNsaWVudFkgLSBjaGlsZHJlbkRvbVJlY3QudG9wO1xuICAgICAgZHJhZ0dob3N0LnN0eWxlLndpZHRoID0gYCR7Y2hpbGRyZW5Eb21SZWN0LndpZHRofXB4YCwgZHJhZ0dob3N0LnN0eWxlLmhlaWdodCA9IGAke2NoaWxkcmVuRG9tUmVjdC5oZWlnaHR9cHhgLCBldmVudF84LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ0dob3N0LCB4XzEsIHlfMSk7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICAgICAgYXQ6IGlzU2VsZWN0aW9uQ29sbGFwc2VkJDEoZHJhZ1NlbGVjdGlvbikgPyBkcmFnU2VsZWN0aW9uIDoge1xuICAgICAgICAgIGFuY2hvcjogZ2V0U2VsZWN0aW9uRW5kUG9pbnQoZHJhZ1NlbGVjdGlvbiksXG4gICAgICAgICAgZm9jdXM6IGdldFNlbGVjdGlvbkVuZFBvaW50KGRyYWdTZWxlY3Rpb24pLFxuICAgICAgICAgIGJhY2t3YXJkOiAhMVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCIsXG4gICAgICBvcmlnaW46IHtcbiAgICAgICAgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uXG4gICAgICB9LFxuICAgICAgZ2hvc3Q6IGRyYWdHaG9zdFxuICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJkcmFnLmRyYWdzdGFydFwiLFxuICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfOC5kYXRhVHJhbnNmZXJcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgICB9KSwgITA7XG4gIH0sIFtvbkRyYWdTdGFydCwgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZURyYWcgPSB1c2VDYWxsYmFjaygoZXZlbnRfOSkgPT4ge1xuICAgIGlmIChvbkRyYWc/LihldmVudF85KSwgIShldmVudF85LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzkuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB8fCAhZ2V0RXZlbnRQb3NpdGlvbih7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgZXZlbnQ6IGV2ZW50XzkubmF0aXZlRXZlbnRcbiAgICB9KSkpXG4gICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZHJhZy5kcmFnXCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfOS5kYXRhVHJhbnNmZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgICAgIH0pLCAhMDtcbiAgfSwgW29uRHJhZywgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZURyYWdFbmQgPSB1c2VDYWxsYmFjaygoZXZlbnRfMTApID0+IHtcbiAgICBpZiAob25EcmFnRW5kPy4oZXZlbnRfMTApLCAhKGV2ZW50XzEwLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50XzEwLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpKVxuICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRyYWcuZHJhZ2VuZFwiLFxuICAgICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IGV2ZW50XzEwLmRhdGFUcmFuc2ZlclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfSksICEwO1xuICB9LCBbb25EcmFnRW5kLCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKSwgaGFuZGxlRHJhZ0VudGVyID0gdXNlQ2FsbGJhY2soKGV2ZW50XzExKSA9PiB7XG4gICAgaWYgKG9uRHJhZ0VudGVyPy4oZXZlbnRfMTEpLCBldmVudF8xMS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudF8xMS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvc2l0aW9uXzYgPSBnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfMTEubmF0aXZlRXZlbnRcbiAgICB9KTtcbiAgICBpZiAocG9zaXRpb25fNilcbiAgICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkcmFnLmRyYWdlbnRlclwiLFxuICAgICAgICAgIG9yaWdpbkV2ZW50OiB7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IGV2ZW50XzExLmRhdGFUcmFuc2ZlclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXzZcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvclxuICAgICAgfSksICEwO1xuICB9LCBbb25EcmFnRW50ZXIsIGVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvcl0pLCBoYW5kbGVEcmFnT3ZlciA9IHVzZUNhbGxiYWNrKChldmVudF8xMikgPT4ge1xuICAgIGlmIChvbkRyYWdPdmVyPy4oZXZlbnRfMTIpLCBldmVudF8xMi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudF8xMi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvc2l0aW9uXzcgPSBnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfMTIubmF0aXZlRXZlbnRcbiAgICB9KTtcbiAgICBpZiAocG9zaXRpb25fNylcbiAgICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkcmFnLmRyYWdvdmVyXCIsXG4gICAgICAgICAgb3JpZ2luRXZlbnQ6IHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfMTIuZGF0YVRyYW5zZmVyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25fN1xuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRfMTJcbiAgICAgIH0pLCAhMDtcbiAgfSwgW29uRHJhZ092ZXIsIGVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvcl0pLCBoYW5kbGVEcm9wID0gdXNlQ2FsbGJhY2soKGV2ZW50XzEzKSA9PiB7XG4gICAgaWYgKG9uRHJvcD8uKGV2ZW50XzEzKSwgZXZlbnRfMTMuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnRfMTMuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3NpdGlvbl84ID0gZ2V0RXZlbnRQb3NpdGlvbih7XG4gICAgICBlZGl0b3JBY3RvcixcbiAgICAgIHNsYXRlRWRpdG9yLFxuICAgICAgZXZlbnQ6IGV2ZW50XzEzLm5hdGl2ZUV2ZW50XG4gICAgfSk7XG4gICAgaWYgKCFwb3NpdGlvbl84KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBwb3NpdGlvbiBmb3IgZHJvcCBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcImRyYWcuZHJvcFwiLFxuICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgIGRhdGFUcmFuc2ZlcjogZXZlbnRfMTMuZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbl84XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF8xM1xuICAgIH0pLCAhMDtcbiAgfSwgW29uRHJvcCwgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZURyYWdMZWF2ZSA9IHVzZUNhbGxiYWNrKChldmVudF8xNCkgPT4ge1xuICAgIGlmIChvbkRyYWdMZWF2ZT8uKGV2ZW50XzE0KSwgIShldmVudF8xNC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudF8xNC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHx8ICFnZXRFdmVudFBvc2l0aW9uKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBldmVudDogZXZlbnRfMTQubmF0aXZlRXZlbnRcbiAgICB9KSkpXG4gICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZHJhZy5kcmFnbGVhdmVcIixcbiAgICAgICAgICBvcmlnaW5FdmVudDoge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiBldmVudF8xNC5kYXRhVHJhbnNmZXJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3JcbiAgICAgIH0pLCAhMDtcbiAgfSwgW29uRHJhZ0xlYXZlLCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKTtcbiAgcmV0dXJuIHBvcnRhYmxlVGV4dEVkaXRvciA/IGhhc0ludmFsaWRWYWx1ZSA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIEVkaXRhYmxlLFxuICAgIHtcbiAgICAgIC4uLnJlc3RQcm9wcyxcbiAgICAgIFwiZGF0YS1yZWFkLW9ubHlcIjogcmVhZE9ubHksXG4gICAgICBhdXRvRm9jdXM6ICExLFxuICAgICAgY2xhc3NOYW1lOiByZXN0UHJvcHMuY2xhc3NOYW1lIHx8IFwicHQtZWRpdGFibGVcIixcbiAgICAgIGRlY29yYXRlLFxuICAgICAgb25CbHVyOiBoYW5kbGVPbkJsdXIsXG4gICAgICBvbkNvcHk6IGhhbmRsZUNvcHksXG4gICAgICBvbkN1dDogaGFuZGxlQ3V0LFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBvbkRPTUJlZm9yZUlucHV0OiBoYW5kbGVPbkJlZm9yZUlucHV0LFxuICAgICAgb25EcmFnU3RhcnQ6IGhhbmRsZURyYWdTdGFydCxcbiAgICAgIG9uRHJhZzogaGFuZGxlRHJhZyxcbiAgICAgIG9uRHJhZ0VuZDogaGFuZGxlRHJhZ0VuZCxcbiAgICAgIG9uRHJhZ0VudGVyOiBoYW5kbGVEcmFnRW50ZXIsXG4gICAgICBvbkRyYWdPdmVyOiBoYW5kbGVEcmFnT3ZlcixcbiAgICAgIG9uRHJvcDogaGFuZGxlRHJvcCxcbiAgICAgIG9uRHJhZ0xlYXZlOiBoYW5kbGVEcmFnTGVhdmUsXG4gICAgICBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLFxuICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgICBvblBhc3RlOiBoYW5kbGVQYXN0ZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHZvaWQgMCxcbiAgICAgIHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJMZWFmLFxuICAgICAgcmVuZGVyVGV4dCxcbiAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3OiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGVcbiAgICB9XG4gICkgOiBudWxsO1xufSk7XG5Qb3J0YWJsZVRleHRFZGl0YWJsZS5kaXNwbGF5TmFtZSA9IFwiRm9yd2FyZFJlZihQb3J0YWJsZVRleHRFZGl0YWJsZSlcIjtcbmZ1bmN0aW9uIHVzZUNvbnN0YW50KGZhY3RvcnkpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICByZXR1cm4gcmVmLmN1cnJlbnQgfHwgKHJlZi5jdXJyZW50ID0ge1xuICAgIGNvbnN0YW50OiBmYWN0b3J5KClcbiAgfSksIHJlZi5jdXJyZW50LmNvbnN0YW50O1xufVxuZnVuY3Rpb24gRWRpdG9yUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoMzEpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzLmluaXRpYWxDb25maWcgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxFZGl0b3IgPSBjcmVhdGVJbnRlcm5hbEVkaXRvcihwcm9wcy5pbml0aWFsQ29uZmlnKSwgcG9ydGFibGVUZXh0RWRpdG9yID0gbmV3IFBvcnRhYmxlVGV4dEVkaXRvcih7XG4gICAgICBlZGl0b3I6IGludGVybmFsRWRpdG9yLmVkaXRvclxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcm5hbEVkaXRvcixcbiAgICAgIHBvcnRhYmxlVGV4dEVkaXRvclxuICAgIH07XG4gIH0sICRbMF0gPSBwcm9wcy5pbml0aWFsQ29uZmlnLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCB7XG4gICAgaW50ZXJuYWxFZGl0b3I6IGludGVybmFsRWRpdG9yXzAsXG4gICAgcG9ydGFibGVUZXh0RWRpdG9yOiBwb3J0YWJsZVRleHRFZGl0b3JfMFxuICB9ID0gdXNlQ29uc3RhbnQodDApO1xuICBsZXQgdDE7XG4gICRbMl0gIT09IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLmVkaXRvckFjdG9yIHx8ICRbM10gIT09IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLm11dGF0aW9uQWN0b3IgfHwgJFs0XSAhPT0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuc3luY0FjdG9yIHx8ICRbNV0gIT09IGludGVybmFsRWRpdG9yXzAuc3Vic2NyaXB0aW9ucyA/ICh0MSA9ICgpID0+IHtcbiAgICBjb25zdCB1bnN1YnNjcmliZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgaW50ZXJuYWxFZGl0b3JfMC5zdWJzY3JpcHRpb25zKVxuICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuZWRpdG9yQWN0b3Iuc3RhcnQoKSwgaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMubXV0YXRpb25BY3Rvci5zdGFydCgpLCBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5zeW5jQWN0b3Iuc3RhcnQoKSwgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCB1bnN1YnNjcmliZSBvZiB1bnN1YnNjcmliZXJzKVxuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgc3RvcEFjdG9yKGludGVybmFsRWRpdG9yXzAuYWN0b3JzLmVkaXRvckFjdG9yKSwgc3RvcEFjdG9yKGludGVybmFsRWRpdG9yXzAuYWN0b3JzLm11dGF0aW9uQWN0b3IpLCBzdG9wQWN0b3IoaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuc3luY0FjdG9yKTtcbiAgICB9O1xuICB9LCAkWzJdID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuZWRpdG9yQWN0b3IsICRbM10gPSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5tdXRhdGlvbkFjdG9yLCAkWzRdID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuc3luY0FjdG9yLCAkWzVdID0gaW50ZXJuYWxFZGl0b3JfMC5zdWJzY3JpcHRpb25zLCAkWzZdID0gdDEpIDogdDEgPSAkWzZdO1xuICBsZXQgdDI7XG4gICRbN10gIT09IGludGVybmFsRWRpdG9yXzAgPyAodDIgPSBbaW50ZXJuYWxFZGl0b3JfMF0sICRbN10gPSBpbnRlcm5hbEVkaXRvcl8wLCAkWzhdID0gdDIpIDogdDIgPSAkWzhdLCB1c2VFZmZlY3QodDEsIHQyKTtcbiAgbGV0IHQzO1xuICAkWzldICE9PSBwb3J0YWJsZVRleHRFZGl0b3JfMC5jaGFuZ2UkID8gKHQzID0gKGNoYW5nZSkgPT4ge1xuICAgIHBvcnRhYmxlVGV4dEVkaXRvcl8wLmNoYW5nZSQubmV4dChjaGFuZ2UpO1xuICB9LCAkWzldID0gcG9ydGFibGVUZXh0RWRpdG9yXzAuY2hhbmdlJCwgJFsxMF0gPSB0MykgOiB0MyA9ICRbMTBdO1xuICBsZXQgdDQ7XG4gICRbMTFdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciB8fCAkWzEyXSAhPT0gdDMgPyAodDQgPSAvKiBAX19QVVJFX18gKi8ganN4KFJvdXRlRXZlbnRzVG9DaGFuZ2VzLCB7IGVkaXRvckFjdG9yOiBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3Rvciwgb25DaGFuZ2U6IHQzIH0pLCAkWzExXSA9IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLmVkaXRvckFjdG9yLCAkWzEyXSA9IHQzLCAkWzEzXSA9IHQ0KSA6IHQ0ID0gJFsxM107XG4gIGxldCB0NTtcbiAgJFsxNF0gIT09IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLmVkaXRvckFjdG9yIHx8ICRbMTVdICE9PSBwcm9wcy5jaGlsZHJlbiA/ICh0NSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIsIHsgZWRpdG9yQWN0b3I6IGludGVybmFsRWRpdG9yXzAuYWN0b3JzLmVkaXRvckFjdG9yLCBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSksICRbMTRdID0gaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuZWRpdG9yQWN0b3IsICRbMTVdID0gcHJvcHMuY2hpbGRyZW4sICRbMTZdID0gdDUpIDogdDUgPSAkWzE2XTtcbiAgbGV0IHQ2O1xuICAkWzE3XSAhPT0gcG9ydGFibGVUZXh0RWRpdG9yXzAgfHwgJFsxOF0gIT09IHQ1ID8gKHQ2ID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwb3J0YWJsZVRleHRFZGl0b3JfMCwgY2hpbGRyZW46IHQ1IH0pLCAkWzE3XSA9IHBvcnRhYmxlVGV4dEVkaXRvcl8wLCAkWzE4XSA9IHQ1LCAkWzE5XSA9IHQ2KSA6IHQ2ID0gJFsxOV07XG4gIGxldCB0NztcbiAgJFsyMF0gIT09IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUgfHwgJFsyMV0gIT09IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSB8fCAkWzIyXSAhPT0gdDYgPyAodDcgPSAvKiBAX19QVVJFX18gKi8ganN4KFNsYXRlLCB7IGVkaXRvcjogaW50ZXJuYWxFZGl0b3JfMC5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlLCBpbml0aWFsVmFsdWU6IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsIGNoaWxkcmVuOiB0NiB9KSwgJFsyMF0gPSBpbnRlcm5hbEVkaXRvcl8wLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCAkWzIxXSA9IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSwgJFsyMl0gPSB0NiwgJFsyM10gPSB0NykgOiB0NyA9ICRbMjNdO1xuICBsZXQgdDg7XG4gICRbMjRdICE9PSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciB8fCAkWzI1XSAhPT0gdDcgPyAodDggPSAvKiBAX19QVVJFX18gKi8ganN4KEVkaXRvckFjdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogaW50ZXJuYWxFZGl0b3JfMC5hY3RvcnMuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiB0NyB9KSwgJFsyNF0gPSBpbnRlcm5hbEVkaXRvcl8wLmFjdG9ycy5lZGl0b3JBY3RvciwgJFsyNV0gPSB0NywgJFsyNl0gPSB0OCkgOiB0OCA9ICRbMjZdO1xuICBsZXQgdDk7XG4gIHJldHVybiAkWzI3XSAhPT0gaW50ZXJuYWxFZGl0b3JfMC5lZGl0b3IgfHwgJFsyOF0gIT09IHQ0IHx8ICRbMjldICE9PSB0OCA/ICh0OSA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGludGVybmFsRWRpdG9yXzAuZWRpdG9yLCBjaGlsZHJlbjogW1xuICAgIHQ0LFxuICAgIHQ4XG4gIF0gfSksICRbMjddID0gaW50ZXJuYWxFZGl0b3JfMC5lZGl0b3IsICRbMjhdID0gdDQsICRbMjldID0gdDgsICRbMzBdID0gdDkpIDogdDkgPSAkWzMwXSwgdDk7XG59XG5leHBvcnQge1xuICBFZGl0b3JFdmVudExpc3RlbmVyLFxuICBFZGl0b3JQcm92aWRlcixcbiAgUG9ydGFibGVUZXh0RWRpdGFibGUsXG4gIFBvcnRhYmxlVGV4dEVkaXRvcixcbiAgZGVmaW5lU2NoZW1hLFxuICBkZWZhdWx0S2V5R2VuZXJhdG9yIGFzIGtleUdlbmVyYXRvcixcbiAgdXNlRWRpdG9yLFxuICB1c2VFZGl0b3JTZWxlY3RvcixcbiAgdXNlUG9ydGFibGVUZXh0RWRpdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/plugins/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/plugins/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BehaviorPlugin: () => (/* binding */ BehaviorPlugin),\n/* harmony export */   DecoratorShortcutPlugin: () => (/* binding */ DecoratorShortcutPlugin),\n/* harmony export */   EditorRefPlugin: () => (/* binding */ EditorRefPlugin),\n/* harmony export */   EventListenerPlugin: () => (/* binding */ EventListenerPlugin),\n/* harmony export */   MarkdownPlugin: () => (/* binding */ MarkdownPlugin),\n/* harmony export */   OneLinePlugin: () => (/* binding */ OneLinePlugin)\n/* harmony export */ });\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_chunks-es/use-editor.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-b47a3833.development.esm.js\");\n/* harmony import */ var _chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../_chunks-es/util.slice-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js\");\n/* harmony import */ var _chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../_chunks-es/util.child-selection-point-to-block-offset.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js\");\n/* harmony import */ var _chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_chunks-es/selector.is-selection-expanded.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js\");\n/* harmony import */ var _chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../_chunks-es/selector.get-text-before.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\");\n/* harmony import */ var _behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../behaviors/index.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/behaviors/index.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _chunks_es_util_merge_text_blocks_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../_chunks-es/util.merge-text-blocks.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction BehaviorPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  return $[0] !== editor || $[1] !== props.behaviors ? (t0 = () => {\n    const unregisterBehaviors = props.behaviors.map((behavior) => editor.registerBehavior({\n      behavior\n    }));\n    return () => {\n      unregisterBehaviors.forEach(_temp);\n    };\n  }, t1 = [editor, props.behaviors], $[0] = editor, $[1] = props.behaviors, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction _temp(unregister) {\n  return unregister();\n}\nfunction createPairRegex(char, amount) {\n  const prePrefix = `(?<!\\\\${char})`, prefix = `\\\\${char}`.repeat(Math.max(amount, 1)), postPrefix = \"(?!\\\\s)\", content = `([^${char}\\\\n]+?)`, preSuffix = \"(?<!\\\\s)\", suffix = `\\\\${char}`.repeat(Math.max(amount, 1)), postSuffix = `(?!\\\\${char})`;\n  return `${prePrefix}${prefix}${postPrefix}${content}${preSuffix}${suffix}${postSuffix}`;\n}\nfunction createDecoratorPairBehavior(config) {\n  config.pair.amount < 1 && console.warn(\"The amount of characters in the pair should be greater than 0\");\n  const pairRegex = createPairRegex(config.pair.char, config.pair.amount), regEx = new RegExp(`(${pairRegex})$`);\n  return (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (config.pair.amount < 1)\n        return !1;\n      const decorator = config.decorator({\n        schema: snapshot.context.schema\n      });\n      if (decorator === void 0)\n        return !1;\n      const focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), selectionStartPoint = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getSelectionStartPoint)(snapshot), selectionStartOffset = selectionStartPoint ? (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: {\n          schema: snapshot.context.schema,\n          value: snapshot.context.value\n        },\n        selectionPoint: selectionStartPoint\n      }) : void 0;\n      if (!focusTextBlock || !selectionStartOffset)\n        return !1;\n      const newText = `${(0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_8__.getBlockTextBefore)(snapshot)}${event.text}`, textToDecorate = newText.match(regEx)?.at(0);\n      if (textToDecorate === void 0)\n        return !1;\n      const prefixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length = 4\n          offset: newText.length - textToDecorate.length\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar**\".length - \"**bar**\".length + \"*\".length * 2 = 6\n          offset: newText.length - textToDecorate.length + config.pair.char.length * config.pair.amount\n        }\n      }, suffixOffsets = {\n        anchor: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length - 2 = 9\n          offset: selectionStartOffset.offset + event.text.length - config.pair.char.length * config.pair.amount\n        },\n        focus: {\n          path: focusTextBlock.path,\n          // Example: \"foo **bar*|\" (10) + \"*\".length = 11\n          offset: selectionStartOffset.offset + event.text.length\n        }\n      };\n      if (prefixOffsets.focus.offset - prefixOffsets.anchor.offset > 1) {\n        const prefixSelection = (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__.blockOffsetsToSelection)({\n          context: snapshot.context,\n          offsets: prefixOffsets\n        }), inlineObjectBeforePrefixFocus = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)({\n          context: {\n            ...snapshot.context,\n            selection: prefixSelection ? {\n              anchor: prefixSelection.focus,\n              focus: prefixSelection.focus\n            } : null\n          }\n        }), inlineObjectBeforePrefixFocusOffset = inlineObjectBeforePrefixFocus ? (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__.childSelectionPointToBlockOffset)({\n          context: {\n            schema: snapshot.context.schema,\n            value: snapshot.context.value\n          },\n          selectionPoint: {\n            path: inlineObjectBeforePrefixFocus.path,\n            offset: 0\n          }\n        }) : void 0;\n        if (inlineObjectBeforePrefixFocusOffset && inlineObjectBeforePrefixFocusOffset.offset > prefixOffsets.anchor.offset && inlineObjectBeforePrefixFocusOffset.offset < prefixOffsets.focus.offset)\n          return !1;\n      }\n      if (suffixOffsets.focus.offset - suffixOffsets.anchor.offset > 1) {\n        const previousInlineObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), previousInlineObjectOffset = previousInlineObject ? (0,_chunks_es_util_child_selection_point_to_block_offset_js__WEBPACK_IMPORTED_MODULE_9__.childSelectionPointToBlockOffset)({\n          context: {\n            schema: snapshot.context.schema,\n            value: snapshot.context.value\n          },\n          selectionPoint: {\n            path: previousInlineObject.path,\n            offset: 0\n          }\n        }) : void 0;\n        if (previousInlineObjectOffset && previousInlineObjectOffset.offset > suffixOffsets.anchor.offset && previousInlineObjectOffset.offset < suffixOffsets.focus.offset)\n          return !1;\n      }\n      return {\n        prefixOffsets,\n        suffixOffsets,\n        decorator\n      };\n    },\n    actions: [\n      // Insert the text as usual in its own undo step\n      ({\n        event\n      }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)(event)],\n      (_, {\n        prefixOffsets,\n        suffixOffsets,\n        decorator\n      }) => [\n        // Decorate the text between the prefix and suffix\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"decorator.add\",\n          decorator,\n          at: {\n            anchor: prefixOffsets.focus,\n            focus: suffixOffsets.anchor\n          }\n        }),\n        // Delete the suffix\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"delete.text\",\n          at: suffixOffsets\n        }),\n        // Delete the prefix\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"delete.text\",\n          at: prefixOffsets\n        }),\n        // Toggle the decorator off so the next inserted text isn't emphasized\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n          type: \"decorator.remove\",\n          decorator\n        }),\n        (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.effect)(() => {\n          config.onDecorate({\n            ...suffixOffsets.anchor,\n            offset: suffixOffsets.anchor.offset - (prefixOffsets.focus.offset - prefixOffsets.anchor.offset)\n          });\n        })\n      ]\n    ]\n  });\n}\nfunction DecoratorShortcutPlugin(config) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(4), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0;\n  return $[0] !== config.decorator || $[1] !== config.pair || $[2] !== editor ? (t0 = {\n    input: {\n      editor,\n      decorator: config.decorator,\n      pair: config.pair\n    }\n  }, $[0] = config.decorator, $[1] = config.pair, $[2] = editor, $[3] = t0) : t0 = $[3], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_10__.useActorRef)(decoratorPairMachine, t0), null;\n}\nconst emphasisListener = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: createDecoratorPairBehavior({\n    decorator: input.decorator,\n    pair: input.pair,\n    onDecorate: (offset) => {\n      sendBack({\n        type: \"emphasis.add\",\n        blockOffset: offset\n      });\n    }\n  })\n}), selectionListenerCallback = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"select\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (!event.at)\n        return {\n          blockOffsets: void 0\n        };\n      const anchor = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: event.at.anchor\n      }), focus = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: event.at.focus\n      });\n      return !anchor || !focus ? {\n        blockOffsets: void 0\n      } : {\n        blockOffsets: {\n          anchor,\n          focus\n        }\n      };\n    },\n    actions: [({\n      event\n    }, {\n      blockOffsets\n    }) => [{\n      type: \"effect\",\n      effect: () => {\n        sendBack({\n          type: \"selection\",\n          blockOffsets\n        });\n      }\n    }, (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.forward)(event)]]\n  })\n}), deleteBackwardListenerCallback = ({\n  sendBack,\n  input\n}) => input.editor.registerBehavior({\n  behavior: (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"delete.backward\",\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"history.undo\"\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.effect)(() => {\n      sendBack({\n        type: \"delete.backward\"\n      });\n    })]]\n  })\n}), decoratorPairMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_11__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {}\n  },\n  actors: {\n    \"emphasis listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.fromCallback)(emphasisListener),\n    \"delete.backward listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.fromCallback)(deleteBackwardListenerCallback),\n    \"selection listener\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.fromCallback)(selectionListenerCallback)\n  }\n}).createMachine({\n  id: \"decorator pair\",\n  context: ({\n    input\n  }) => ({\n    decorator: input.decorator,\n    editor: input.editor,\n    pair: input.pair\n  }),\n  initial: \"idle\",\n  states: {\n    idle: {\n      invoke: [{\n        src: \"emphasis listener\",\n        input: ({\n          context\n        }) => ({\n          decorator: context.decorator,\n          editor: context.editor,\n          pair: context.pair\n        })\n      }],\n      on: {\n        \"emphasis.add\": {\n          target: \"emphasis added\",\n          actions: (0,xstate__WEBPACK_IMPORTED_MODULE_13__.a)({\n            offsetAfterEmphasis: ({\n              event\n            }) => event.blockOffset\n          })\n        }\n      }\n    },\n    \"emphasis added\": {\n      exit: [(0,xstate__WEBPACK_IMPORTED_MODULE_13__.a)({\n        offsetAfterEmphasis: void 0\n      })],\n      invoke: [{\n        src: \"selection listener\",\n        input: ({\n          context\n        }) => ({\n          editor: context.editor\n        })\n      }, {\n        src: \"delete.backward listener\",\n        input: ({\n          context\n        }) => ({\n          editor: context.editor\n        })\n      }],\n      on: {\n        selection: {\n          target: \"idle\",\n          guard: ({\n            context,\n            event\n          }) => !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n            anchor: context.offsetAfterEmphasis,\n            focus: context.offsetAfterEmphasis\n          }, event.blockOffsets)\n        },\n        \"delete.backward\": {\n          target: \"idle\"\n        }\n      }\n    }\n  }\n}), EditorRefPlugin = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((_, ref) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(2), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)(), portableTextEditorRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(editor);\n  let t0, t1;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = () => portableTextEditorRef.current, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, t0, t1), null;\n});\nEditorRefPlugin.displayName = \"EditorRefPlugin\";\nfunction EventListenerPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(5), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_14__.useEffectEvent)(props.on);\n  let t0;\n  $[0] !== editor || $[1] !== on ? (t0 = () => {\n    const subscription = editor.on(\"*\", on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];\n  let t1;\n  return $[3] !== editor ? (t1 = [editor], $[3] = editor, $[4] = t1) : t1 = $[4], (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1), null;\n}\nfunction createMarkdownBehaviors(config) {\n  const automaticBlockquoteOnSpace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), blockOffset = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (previousInlineObject || !blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.getTextBlockText)(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = config.blockquoteStyle?.(snapshot.context);\n      return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {\n        focusTextBlock,\n        style: blockquoteStyle\n      } : !1;\n    },\n    actions: [() => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.text\",\n      text: \" \"\n    })], (_, {\n      focusTextBlock,\n      style\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        style\n      },\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: {\n        anchor: {\n          path: focusTextBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusTextBlock.path,\n          offset: 2\n        }\n      }\n    })]]\n  }), automaticHr = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const hrCharacter = event.text === \"-\" ? \"-\" : event.text === \"*\" ? \"*\" : event.text === \"_\" ? \"_\" : void 0;\n      if (hrCharacter === void 0)\n        return !1;\n      const hrObject = config.horizontalRuleObject?.(snapshot.context), focusBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot);\n      if (!hrObject || !focusBlock || !selectionCollapsed)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), textBefore = (0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_8__.getBlockTextBefore)(snapshot), hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3\n        }\n      };\n      return !previousInlineObject && textBefore === `${hrCharacter}${hrCharacter}` ? {\n        hrObject,\n        focusBlock,\n        hrCharacter,\n        hrBlockOffsets\n      } : !1;\n    },\n    actions: [(_, {\n      hrCharacter\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.text\",\n      text: hrCharacter\n    })], (_, {\n      hrObject,\n      hrBlockOffsets\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      placement: \"before\",\n      block: {\n        _type: hrObject.name,\n        ...hrObject.value ?? {}\n      }\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: hrBlockOffsets\n    })]]\n  }), automaticHrOnPaste = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"clipboard.paste\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const text = event.originEvent.dataTransfer.getData(\"text/plain\"), hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/, hrCharacters = text.match(hrRegExp)?.[0], hrObject = config.horizontalRuleObject?.(snapshot.context), focusBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusBlock)(snapshot);\n      return !hrCharacters || !hrObject || !focusBlock ? !1 : {\n        hrCharacters,\n        hrObject,\n        focusBlock\n      };\n    },\n    actions: [(_, {\n      hrCharacters\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.text\",\n      text: hrCharacters\n    })], ({\n      snapshot\n    }, {\n      hrObject,\n      focusBlock\n    }) => (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.isTextBlock)(snapshot.context, focusBlock.node) ? [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: {\n        _type: snapshot.context.schema.block.name,\n        children: focusBlock.node.children\n      },\n      placement: \"after\"\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: {\n        _type: hrObject.name,\n        ...hrObject.value ?? {}\n      },\n      placement: \"after\"\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.block\",\n      at: focusBlock.path\n    })] : [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: {\n        _type: hrObject.name,\n        ...hrObject.value ?? {}\n      },\n      placement: \"after\"\n    })]]\n  }), automaticHeadingOnSpace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), blockText = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.getTextBlockText)(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0, caretAtTheEndOfHeading = blockOffset.offset === level;\n      if (previousInlineObject || !caretAtTheEndOfHeading)\n        return !1;\n      const style = level !== void 0 ? config.headingStyle?.({\n        schema: snapshot.context.schema,\n        level\n      }) : void 0;\n      return level !== void 0 && style !== void 0 ? {\n        focusTextBlock,\n        style,\n        level\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)(event)], (_, {\n      focusTextBlock,\n      style,\n      level\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        style\n      },\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: {\n        anchor: {\n          path: focusTextBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusTextBlock.path,\n          offset: level + 1\n        }\n      }\n    })]]\n  }), clearStyleOnBackspace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"delete.backward\",\n    guard: ({\n      snapshot\n    }) => {\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0, defaultStyle = config.defaultStyle?.(snapshot.context);\n      return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {\n        defaultStyle,\n        focusTextBlock\n      } : !1;\n    },\n    actions: [(_, {\n      defaultStyle,\n      focusTextBlock\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        style: defaultStyle\n      },\n      at: focusTextBlock.path\n    })]]\n  }), automaticListOnSpace = (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionCollapsed)(snapshot), focusTextBlock = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot), focusSpan = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusSpan)(snapshot);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const previousInlineObject = (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getPreviousInlineObject)(snapshot), blockOffset = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.spanSelectionPointToBlockOffset)({\n        context: snapshot.context,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: snapshot.context.selection?.focus.offset ?? 0\n        }\n      });\n      if (previousInlineObject || !blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_slice_blocks_js__WEBPACK_IMPORTED_MODULE_7__.getTextBlockText)(focusTextBlock.node), defaultStyle = config.defaultStyle?.(snapshot.context), looksLikeUnorderedList = /^(-|\\*)/.test(blockText), unorderedListStyle = config.unorderedListStyle?.(snapshot.context), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;\n      if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0)\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle\n        };\n      const looksLikeOrderedList = /^1\\./.test(blockText), orderedListStyle = config.orderedListStyle?.(snapshot.context), caretAtTheEndOfOrderedList = blockOffset.offset === 2;\n      return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {\n        focusTextBlock,\n        listItem: orderedListStyle,\n        listItemLength: 2,\n        style: defaultStyle\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)(event)], (_, {\n      focusTextBlock,\n      style,\n      listItem,\n      listItemLength\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"block.set\",\n      props: {\n        listItem,\n        level: 1,\n        style\n      },\n      at: focusTextBlock.path\n    }), (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete.text\",\n      at: {\n        anchor: {\n          path: focusTextBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusTextBlock.path,\n          offset: listItemLength + 1\n        }\n      }\n    })]]\n  });\n  return [automaticBlockquoteOnSpace, automaticHeadingOnSpace, automaticHr, automaticHrOnPaste, clearStyleOnBackspace, automaticListOnSpace];\n}\nfunction MarkdownPlugin(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(17), editor = (0,_chunks_es_use_editor_js__WEBPACK_IMPORTED_MODULE_4__.useEditor)();\n  let t0, t1;\n  $[0] !== editor || $[1] !== props.config ? (t0 = () => {\n    const unregisterBehaviors = createMarkdownBehaviors(props.config).map((behavior) => editor.registerBehavior({\n      behavior\n    }));\n    return () => {\n      for (const unregisterBehavior of unregisterBehaviors)\n        unregisterBehavior();\n    };\n  }, t1 = [editor, props.config], $[0] = editor, $[1] = props.config, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(t0, t1);\n  let t2;\n  $[4] !== props.config.boldDecorator ? (t2 = props.config.boldDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.boldDecorator, pair: {\n      char: \"*\",\n      amount: 2\n    } }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.boldDecorator, pair: {\n      char: \"_\",\n      amount: 2\n    } })\n  ] }) : null, $[4] = props.config.boldDecorator, $[5] = t2) : t2 = $[5];\n  let t3;\n  $[6] !== props.config.codeDecorator ? (t3 = props.config.codeDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.codeDecorator, pair: {\n    char: \"`\",\n    amount: 1\n  } }) : null, $[6] = props.config.codeDecorator, $[7] = t3) : t3 = $[7];\n  let t4;\n  $[8] !== props.config.italicDecorator ? (t4 = props.config.italicDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.italicDecorator, pair: {\n      char: \"*\",\n      amount: 1\n    } }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.italicDecorator, pair: {\n      char: \"_\",\n      amount: 1\n    } })\n  ] }) : null, $[8] = props.config.italicDecorator, $[9] = t4) : t4 = $[9];\n  let t5;\n  $[10] !== props.config.strikeThroughDecorator ? (t5 = props.config.strikeThroughDecorator ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DecoratorShortcutPlugin, { decorator: props.config.strikeThroughDecorator, pair: {\n    char: \"~\",\n    amount: 2\n  } }) : null, $[10] = props.config.strikeThroughDecorator, $[11] = t5) : t5 = $[11];\n  let t6;\n  return $[12] !== t2 || $[13] !== t3 || $[14] !== t4 || $[15] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n    t2,\n    t3,\n    t4,\n    t5\n  ] }), $[12] = t2, $[13] = t3, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16], t6;\n}\nconst oneLineBehaviors = [\n  /**\n   * Hitting Enter on an expanded selection should just delete that selection\n   * without causing a line break.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.break\",\n    guard: ({\n      snapshot\n    }) => snapshot.context.selection && (0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.isSelectionExpanded)(snapshot) ? {\n      selection: snapshot.context.selection\n    } : !1,\n    actions: [(_, {\n      selection\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"delete\",\n      at: selection\n    })]]\n  }),\n  /**\n   * All other cases of `insert.break` should be aborted.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.break\",\n    actions: []\n  }),\n  /**\n   * `insert.block` `before` or `after` is not allowed in a one-line editor.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      event\n    }) => event.placement === \"before\" || event.placement === \"after\",\n    actions: []\n  }),\n  /**\n   * An ordinary `insert.block` is acceptable if it's a text block. In that\n   * case it will get merged into the existing text block.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.block\",\n    guard: ({\n      snapshot,\n      event\n    }) => !(!(0,_chunks_es_selector_is_selection_expanded_js__WEBPACK_IMPORTED_MODULE_6__.getFocusTextBlock)(snapshot) || !(0,_chunks_es_util_merge_text_blocks_js__WEBPACK_IMPORTED_MODULE_15__.isTextBlock)(snapshot.context, event.block)),\n    actions: [({\n      event\n    }) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.execute)({\n      type: \"insert.block\",\n      block: event.block,\n      placement: \"auto\",\n      select: \"end\"\n    })]]\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all\n   * end up with a falsy guard.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.block\",\n    actions: []\n  }),\n  /**\n   * If multiple blocks are inserted, then the non-text blocks are filtered out\n   * and the text blocks are merged into one block\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.blocks\",\n    guard: ({\n      snapshot,\n      event\n    }) => {\n      const textBlocks = event.blocks.filter((block) => (0,_chunks_es_util_merge_text_blocks_js__WEBPACK_IMPORTED_MODULE_15__.isTextBlock)(snapshot.context, block));\n      return textBlocks.length === 0 ? !1 : textBlocks.reduce((targetBlock, incomingBlock) => (0,_chunks_es_util_merge_text_blocks_js__WEBPACK_IMPORTED_MODULE_15__.mergeTextBlocks)({\n        context: snapshot.context,\n        targetBlock,\n        incomingBlock\n      }));\n    },\n    actions: [\n      // `insert.block` is raised so the Behavior above can handle the\n      // insertion\n      (_, block) => [(0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.raise)({\n        type: \"insert.block\",\n        block,\n        placement: \"auto\"\n      })]\n    ]\n  }),\n  /**\n   * Fallback Behavior to avoid `insert.blocks` in case the Behavior above\n   * ends up with a falsy guard.\n   */\n  (0,_behaviors_index_js__WEBPACK_IMPORTED_MODULE_5__.defineBehavior)({\n    on: \"insert.blocks\",\n    actions: []\n  })\n];\nfunction OneLinePlugin() {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_0__.c)(1);\n  let t0;\n  return $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(BehaviorPlugin, { behaviors: oneLineBehaviors }), $[0] = t0) : t0 = $[0], t0;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL3BsdWdpbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNGO0FBQ2U7QUFDWjtBQUNKO0FBQ2E7QUFDK0Q7QUFDb0I7QUFDcUU7QUFDOUg7QUFDUztBQUN0QztBQUNNO0FBQ2dEO0FBQ3hHO0FBQ0EsWUFBWSx5REFBQyxjQUFjLG1FQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUhBQXlILGdEQUFTO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxrQkFBa0IsS0FBSyx1RUFBdUUsS0FBSyxnREFBZ0QsS0FBSyxvREFBb0QsS0FBSztBQUNuUCxZQUFZLFVBQVUsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFdBQVc7QUFDeEY7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFVBQVU7QUFDNUcsU0FBUyxtRUFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCLCtGQUFpQixrQ0FBa0Msb0dBQXNCLHlEQUF5RCxnR0FBK0I7QUFDOUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIsMEZBQWtCLFdBQVcsRUFBRSxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUhBQXVCO0FBQ3ZEO0FBQ0E7QUFD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QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1DQUFtQyxpR0FBbUI7QUFDM0Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUssTUFBTSw0REFBTztBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1FQUFjO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1FQUFjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxRQUFRLCtGQUFpQixlQUFlLGtGQUFhO0FBQzFEO0FBQ0E7QUFDQSxLQUFLLE1BQU0sNERBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtRUFBYztBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3REFBd0Qsa0ZBQWE7QUFDckUsOEZBQThGLHNGQUFlO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUVBQWM7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSx5REFBQztBQUNiO0FBQ0Esa0ZBQWtGLHNEQUFHLG1CQUFtQiw2QkFBNkI7QUFDckk7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFudGVjLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9wbHVnaW5zL2luZGV4LmpzPzNlODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyB9IGZyb20gXCJyZWFjdC1jb21waWxlci1ydW50aW1lXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZGl0b3IgfSBmcm9tIFwiLi4vX2NodW5rcy1lcy91c2UtZWRpdG9yLmpzXCI7XG5pbXBvcnQgeyB1c2VBY3RvclJlZiB9IGZyb20gXCJAeHN0YXRlL3JlYWN0XCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB7IHNldHVwLCBmcm9tQ2FsbGJhY2ssIGFzc2lnbiB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQsIGdldFRleHRCbG9ja1RleHQsIGlzVGV4dEJsb2NrIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvdXRpbC5zbGljZS1ibG9ja3MuanNcIjtcbmltcG9ydCB7IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uLCBjaGlsZFNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL3V0aWwuY2hpbGQtc2VsZWN0aW9uLXBvaW50LXRvLWJsb2NrLW9mZnNldC5qc1wiO1xuaW1wb3J0IHsgZ2V0Rm9jdXNUZXh0QmxvY2ssIGdldFNlbGVjdGlvblN0YXJ0UG9pbnQsIGdldFByZXZpb3VzSW5saW5lT2JqZWN0LCBpc1NlbGVjdGlvbkNvbGxhcHNlZCwgZ2V0Rm9jdXNTcGFuLCBnZXRGb2N1c0Jsb2NrLCBpc1NlbGVjdGlvbkV4cGFuZGVkIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWV4cGFuZGVkLmpzXCI7XG5pbXBvcnQgeyBnZXRCbG9ja1RleHRCZWZvcmUgfSBmcm9tIFwiLi4vX2NodW5rcy1lcy9zZWxlY3Rvci5nZXQtdGV4dC1iZWZvcmUuanNcIjtcbmltcG9ydCB7IGRlZmluZUJlaGF2aW9yLCBleGVjdXRlLCBlZmZlY3QsIGZvcndhcmQsIHJhaXNlIH0gZnJvbSBcIi4uL2JlaGF2aW9ycy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0RXZlbnQgfSBmcm9tIFwidXNlLWVmZmVjdC1ldmVudFwiO1xuaW1wb3J0IHsganN4cywgRnJhZ21lbnQsIGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgaXNUZXh0QmxvY2sgYXMgaXNUZXh0QmxvY2skMSwgbWVyZ2VUZXh0QmxvY2tzIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvdXRpbC5tZXJnZS10ZXh0LWJsb2Nrcy5qc1wiO1xuZnVuY3Rpb24gQmVoYXZpb3JQbHVnaW4ocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCksIGVkaXRvciA9IHVzZUVkaXRvcigpO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IHByb3BzLmJlaGF2aW9ycyA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCB1bnJlZ2lzdGVyQmVoYXZpb3JzID0gcHJvcHMuYmVoYXZpb3JzLm1hcCgoYmVoYXZpb3IpID0+IGVkaXRvci5yZWdpc3RlckJlaGF2aW9yKHtcbiAgICAgIGJlaGF2aW9yXG4gICAgfSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyQmVoYXZpb3JzLmZvckVhY2goX3RlbXApO1xuICAgIH07XG4gIH0sIHQxID0gW2VkaXRvciwgcHJvcHMuYmVoYXZpb3JzXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHByb3BzLmJlaGF2aW9ycywgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBfdGVtcCh1bnJlZ2lzdGVyKSB7XG4gIHJldHVybiB1bnJlZ2lzdGVyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlyUmVnZXgoY2hhciwgYW1vdW50KSB7XG4gIGNvbnN0IHByZVByZWZpeCA9IGAoPzwhXFxcXCR7Y2hhcn0pYCwgcHJlZml4ID0gYFxcXFwke2NoYXJ9YC5yZXBlYXQoTWF0aC5tYXgoYW1vdW50LCAxKSksIHBvc3RQcmVmaXggPSBcIig/IVxcXFxzKVwiLCBjb250ZW50ID0gYChbXiR7Y2hhcn1cXFxcbl0rPylgLCBwcmVTdWZmaXggPSBcIig/PCFcXFxccylcIiwgc3VmZml4ID0gYFxcXFwke2NoYXJ9YC5yZXBlYXQoTWF0aC5tYXgoYW1vdW50LCAxKSksIHBvc3RTdWZmaXggPSBgKD8hXFxcXCR7Y2hhcn0pYDtcbiAgcmV0dXJuIGAke3ByZVByZWZpeH0ke3ByZWZpeH0ke3Bvc3RQcmVmaXh9JHtjb250ZW50fSR7cHJlU3VmZml4fSR7c3VmZml4fSR7cG9zdFN1ZmZpeH1gO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yUGFpckJlaGF2aW9yKGNvbmZpZykge1xuICBjb25maWcucGFpci5hbW91bnQgPCAxICYmIGNvbnNvbGUud2FybihcIlRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyBpbiB0aGUgcGFpciBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gIGNvbnN0IHBhaXJSZWdleCA9IGNyZWF0ZVBhaXJSZWdleChjb25maWcucGFpci5jaGFyLCBjb25maWcucGFpci5hbW91bnQpLCByZWdFeCA9IG5ldyBSZWdFeHAoYCgke3BhaXJSZWdleH0pJGApO1xuICByZXR1cm4gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGNvbmZpZy5wYWlyLmFtb3VudCA8IDEpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IGNvbmZpZy5kZWNvcmF0b3Ioe1xuICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmIChkZWNvcmF0b3IgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIHNlbGVjdGlvblN0YXJ0UG9pbnQgPSBnZXRTZWxlY3Rpb25TdGFydFBvaW50KHNuYXBzaG90KSwgc2VsZWN0aW9uU3RhcnRPZmZzZXQgPSBzZWxlY3Rpb25TdGFydFBvaW50ID8gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgIHZhbHVlOiBzbmFwc2hvdC5jb250ZXh0LnZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiBzZWxlY3Rpb25TdGFydFBvaW50XG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICAgIGlmICghZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvblN0YXJ0T2Zmc2V0KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gYCR7Z2V0QmxvY2tUZXh0QmVmb3JlKHNuYXBzaG90KX0ke2V2ZW50LnRleHR9YCwgdGV4dFRvRGVjb3JhdGUgPSBuZXdUZXh0Lm1hdGNoKHJlZ0V4KT8uYXQoMCk7XG4gICAgICBpZiAodGV4dFRvRGVjb3JhdGUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJlZml4T2Zmc2V0cyA9IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICAvLyBFeGFtcGxlOiBcImZvbyAqKmJhcioqXCIubGVuZ3RoIC0gXCIqKmJhcioqXCIubGVuZ3RoID0gNFxuICAgICAgICAgIG9mZnNldDogbmV3VGV4dC5sZW5ndGggLSB0ZXh0VG9EZWNvcmF0ZS5sZW5ndGhcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwiZm9vICoqYmFyKipcIi5sZW5ndGggLSBcIioqYmFyKipcIi5sZW5ndGggKyBcIipcIi5sZW5ndGggKiAyID0gNlxuICAgICAgICAgIG9mZnNldDogbmV3VGV4dC5sZW5ndGggLSB0ZXh0VG9EZWNvcmF0ZS5sZW5ndGggKyBjb25maWcucGFpci5jaGFyLmxlbmd0aCAqIGNvbmZpZy5wYWlyLmFtb3VudFxuICAgICAgICB9XG4gICAgICB9LCBzdWZmaXhPZmZzZXRzID0ge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwiZm9vICoqYmFyKnxcIiAoMTApICsgXCIqXCIubGVuZ3RoIC0gMiA9IDlcbiAgICAgICAgICBvZmZzZXQ6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0Lm9mZnNldCArIGV2ZW50LnRleHQubGVuZ3RoIC0gY29uZmlnLnBhaXIuY2hhci5sZW5ndGggKiBjb25maWcucGFpci5hbW91bnRcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwiZm9vICoqYmFyKnxcIiAoMTApICsgXCIqXCIubGVuZ3RoID0gMTFcbiAgICAgICAgICBvZmZzZXQ6IHNlbGVjdGlvblN0YXJ0T2Zmc2V0Lm9mZnNldCArIGV2ZW50LnRleHQubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAocHJlZml4T2Zmc2V0cy5mb2N1cy5vZmZzZXQgLSBwcmVmaXhPZmZzZXRzLmFuY2hvci5vZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeFNlbGVjdGlvbiA9IGJsb2NrT2Zmc2V0c1RvU2VsZWN0aW9uKHtcbiAgICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIG9mZnNldHM6IHByZWZpeE9mZnNldHNcbiAgICAgICAgfSksIGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IHByZWZpeFNlbGVjdGlvbiA/IHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBwcmVmaXhTZWxlY3Rpb24uZm9jdXMsXG4gICAgICAgICAgICAgIGZvY3VzOiBwcmVmaXhTZWxlY3Rpb24uZm9jdXNcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgaW5saW5lT2JqZWN0QmVmb3JlUHJlZml4Rm9jdXNPZmZzZXQgPSBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1cyA/IGNoaWxkU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBzY2hlbWE6IHNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICAgICAgdmFsdWU6IHNuYXBzaG90LmNvbnRleHQudmFsdWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1cy5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzT2Zmc2V0ICYmIGlubGluZU9iamVjdEJlZm9yZVByZWZpeEZvY3VzT2Zmc2V0Lm9mZnNldCA+IHByZWZpeE9mZnNldHMuYW5jaG9yLm9mZnNldCAmJiBpbmxpbmVPYmplY3RCZWZvcmVQcmVmaXhGb2N1c09mZnNldC5vZmZzZXQgPCBwcmVmaXhPZmZzZXRzLmZvY3VzLm9mZnNldClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICBpZiAoc3VmZml4T2Zmc2V0cy5mb2N1cy5vZmZzZXQgLSBzdWZmaXhPZmZzZXRzLmFuY2hvci5vZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBwcmV2aW91c0lubGluZU9iamVjdE9mZnNldCA9IHByZXZpb3VzSW5saW5lT2JqZWN0ID8gY2hpbGRTZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHNjaGVtYTogc25hcHNob3QuY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgICB2YWx1ZTogc25hcHNob3QuY29udGV4dC52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IHtcbiAgICAgICAgICAgIHBhdGg6IHByZXZpb3VzSW5saW5lT2JqZWN0LnBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICBpZiAocHJldmlvdXNJbmxpbmVPYmplY3RPZmZzZXQgJiYgcHJldmlvdXNJbmxpbmVPYmplY3RPZmZzZXQub2Zmc2V0ID4gc3VmZml4T2Zmc2V0cy5hbmNob3Iub2Zmc2V0ICYmIHByZXZpb3VzSW5saW5lT2JqZWN0T2Zmc2V0Lm9mZnNldCA8IHN1ZmZpeE9mZnNldHMuZm9jdXMub2Zmc2V0KVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeE9mZnNldHMsXG4gICAgICAgIHN1ZmZpeE9mZnNldHMsXG4gICAgICAgIGRlY29yYXRvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFtcbiAgICAgIC8vIEluc2VydCB0aGUgdGV4dCBhcyB1c3VhbCBpbiBpdHMgb3duIHVuZG8gc3RlcFxuICAgICAgKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IFtleGVjdXRlKGV2ZW50KV0sXG4gICAgICAoXywge1xuICAgICAgICBwcmVmaXhPZmZzZXRzLFxuICAgICAgICBzdWZmaXhPZmZzZXRzLFxuICAgICAgICBkZWNvcmF0b3JcbiAgICAgIH0pID0+IFtcbiAgICAgICAgLy8gRGVjb3JhdGUgdGhlIHRleHQgYmV0d2VlbiB0aGUgcHJlZml4IGFuZCBzdWZmaXhcbiAgICAgICAgZXhlY3V0ZSh7XG4gICAgICAgICAgdHlwZTogXCJkZWNvcmF0b3IuYWRkXCIsXG4gICAgICAgICAgZGVjb3JhdG9yLFxuICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICBhbmNob3I6IHByZWZpeE9mZnNldHMuZm9jdXMsXG4gICAgICAgICAgICBmb2N1czogc3VmZml4T2Zmc2V0cy5hbmNob3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBEZWxldGUgdGhlIHN1ZmZpeFxuICAgICAgICBleGVjdXRlKHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICAgICAgYXQ6IHN1ZmZpeE9mZnNldHNcbiAgICAgICAgfSksXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcHJlZml4XG4gICAgICAgIGV4ZWN1dGUoe1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgICAgICBhdDogcHJlZml4T2Zmc2V0c1xuICAgICAgICB9KSxcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBkZWNvcmF0b3Igb2ZmIHNvIHRoZSBuZXh0IGluc2VydGVkIHRleHQgaXNuJ3QgZW1waGFzaXplZFxuICAgICAgICBleGVjdXRlKHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci5yZW1vdmVcIixcbiAgICAgICAgICBkZWNvcmF0b3JcbiAgICAgICAgfSksXG4gICAgICAgIGVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgY29uZmlnLm9uRGVjb3JhdGUoe1xuICAgICAgICAgICAgLi4uc3VmZml4T2Zmc2V0cy5hbmNob3IsXG4gICAgICAgICAgICBvZmZzZXQ6IHN1ZmZpeE9mZnNldHMuYW5jaG9yLm9mZnNldCAtIChwcmVmaXhPZmZzZXRzLmZvY3VzLm9mZnNldCAtIHByZWZpeE9mZnNldHMuYW5jaG9yLm9mZnNldClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdXG4gIH0pO1xufVxuZnVuY3Rpb24gRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4oY29uZmlnKSB7XG4gIGNvbnN0ICQgPSBjKDQpLCBlZGl0b3IgPSB1c2VFZGl0b3IoKTtcbiAgbGV0IHQwO1xuICByZXR1cm4gJFswXSAhPT0gY29uZmlnLmRlY29yYXRvciB8fCAkWzFdICE9PSBjb25maWcucGFpciB8fCAkWzJdICE9PSBlZGl0b3IgPyAodDAgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIGVkaXRvcixcbiAgICAgIGRlY29yYXRvcjogY29uZmlnLmRlY29yYXRvcixcbiAgICAgIHBhaXI6IGNvbmZpZy5wYWlyXG4gICAgfVxuICB9LCAkWzBdID0gY29uZmlnLmRlY29yYXRvciwgJFsxXSA9IGNvbmZpZy5wYWlyLCAkWzJdID0gZWRpdG9yLCAkWzNdID0gdDApIDogdDAgPSAkWzNdLCB1c2VBY3RvclJlZihkZWNvcmF0b3JQYWlyTWFjaGluZSwgdDApLCBudWxsO1xufVxuY29uc3QgZW1waGFzaXNMaXN0ZW5lciA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4gaW5wdXQuZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICBiZWhhdmlvcjogY3JlYXRlRGVjb3JhdG9yUGFpckJlaGF2aW9yKHtcbiAgICBkZWNvcmF0b3I6IGlucHV0LmRlY29yYXRvcixcbiAgICBwYWlyOiBpbnB1dC5wYWlyLFxuICAgIG9uRGVjb3JhdGU6IChvZmZzZXQpID0+IHtcbiAgICAgIHNlbmRCYWNrKHtcbiAgICAgICAgdHlwZTogXCJlbXBoYXNpcy5hZGRcIixcbiAgICAgICAgYmxvY2tPZmZzZXQ6IG9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICB9KVxufSksIHNlbGVjdGlvbkxpc3RlbmVyQ2FsbGJhY2sgPSAoe1xuICBzZW5kQmFjayxcbiAgaW5wdXRcbn0pID0+IGlucHV0LmVkaXRvci5yZWdpc3RlckJlaGF2aW9yKHtcbiAgYmVoYXZpb3I6IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJzZWxlY3RcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LmF0KVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJsb2NrT2Zmc2V0czogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICBjb25zdCBhbmNob3IgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IGV2ZW50LmF0LmFuY2hvclxuICAgICAgfSksIGZvY3VzID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiBldmVudC5hdC5mb2N1c1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIWFuY2hvciB8fCAhZm9jdXMgPyB7XG4gICAgICAgIGJsb2NrT2Zmc2V0czogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICBibG9ja09mZnNldHM6IHtcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgZm9jdXNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9LCB7XG4gICAgICBibG9ja09mZnNldHNcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICBzZW5kQmFjayh7XG4gICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICBibG9ja09mZnNldHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZm9yd2FyZChldmVudCldXVxuICB9KVxufSksIGRlbGV0ZUJhY2t3YXJkTGlzdGVuZXJDYWxsYmFjayA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4gaW5wdXQuZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICBiZWhhdmlvcjogZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImhpc3RvcnkudW5kb1wiXG4gICAgfSksIGVmZmVjdCgoKSA9PiB7XG4gICAgICBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLmJhY2t3YXJkXCJcbiAgICAgIH0pO1xuICAgIH0pXV1cbiAgfSlcbn0pLCBkZWNvcmF0b3JQYWlyTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBpbnB1dDoge30sXG4gICAgZXZlbnRzOiB7fVxuICB9LFxuICBhY3RvcnM6IHtcbiAgICBcImVtcGhhc2lzIGxpc3RlbmVyXCI6IGZyb21DYWxsYmFjayhlbXBoYXNpc0xpc3RlbmVyKSxcbiAgICBcImRlbGV0ZS5iYWNrd2FyZCBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soZGVsZXRlQmFja3dhcmRMaXN0ZW5lckNhbGxiYWNrKSxcbiAgICBcInNlbGVjdGlvbiBsaXN0ZW5lclwiOiBmcm9tQ2FsbGJhY2soc2VsZWN0aW9uTGlzdGVuZXJDYWxsYmFjaylcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcImRlY29yYXRvciBwYWlyXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBkZWNvcmF0b3I6IGlucHV0LmRlY29yYXRvcixcbiAgICBlZGl0b3I6IGlucHV0LmVkaXRvcixcbiAgICBwYWlyOiBpbnB1dC5wYWlyXG4gIH0pLFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgc3RhdGVzOiB7XG4gICAgaWRsZToge1xuICAgICAgaW52b2tlOiBbe1xuICAgICAgICBzcmM6IFwiZW1waGFzaXMgbGlzdGVuZXJcIixcbiAgICAgICAgaW5wdXQ6ICh7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgIGRlY29yYXRvcjogY29udGV4dC5kZWNvcmF0b3IsXG4gICAgICAgICAgZWRpdG9yOiBjb250ZXh0LmVkaXRvcixcbiAgICAgICAgICBwYWlyOiBjb250ZXh0LnBhaXJcbiAgICAgICAgfSlcbiAgICAgIH1dLFxuICAgICAgb246IHtcbiAgICAgICAgXCJlbXBoYXNpcy5hZGRcIjoge1xuICAgICAgICAgIHRhcmdldDogXCJlbXBoYXNpcyBhZGRlZFwiLFxuICAgICAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgICAgICBvZmZzZXRBZnRlckVtcGhhc2lzOiAoe1xuICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgfSkgPT4gZXZlbnQuYmxvY2tPZmZzZXRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImVtcGhhc2lzIGFkZGVkXCI6IHtcbiAgICAgIGV4aXQ6IFthc3NpZ24oe1xuICAgICAgICBvZmZzZXRBZnRlckVtcGhhc2lzOiB2b2lkIDBcbiAgICAgIH0pXSxcbiAgICAgIGludm9rZTogW3tcbiAgICAgICAgc3JjOiBcInNlbGVjdGlvbiBsaXN0ZW5lclwiLFxuICAgICAgICBpbnB1dDogKHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgZWRpdG9yOiBjb250ZXh0LmVkaXRvclxuICAgICAgICB9KVxuICAgICAgfSwge1xuICAgICAgICBzcmM6IFwiZGVsZXRlLmJhY2t3YXJkIGxpc3RlbmVyXCIsXG4gICAgICAgIGlucHV0OiAoe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICBlZGl0b3I6IGNvbnRleHQuZWRpdG9yXG4gICAgICAgIH0pXG4gICAgICB9XSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIHRhcmdldDogXCJpZGxlXCIsXG4gICAgICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9KSA9PiAhaXNFcXVhbCh7XG4gICAgICAgICAgICBhbmNob3I6IGNvbnRleHQub2Zmc2V0QWZ0ZXJFbXBoYXNpcyxcbiAgICAgICAgICAgIGZvY3VzOiBjb250ZXh0Lm9mZnNldEFmdGVyRW1waGFzaXNcbiAgICAgICAgICB9LCBldmVudC5ibG9ja09mZnNldHMpXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlLmJhY2t3YXJkXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLCBFZGl0b3JSZWZQbHVnaW4gPSBSZWFjdC5mb3J3YXJkUmVmKChfLCByZWYpID0+IHtcbiAgY29uc3QgJCA9IGMoMiksIGVkaXRvciA9IHVzZUVkaXRvcigpLCBwb3J0YWJsZVRleHRFZGl0b3JSZWYgPSBSZWFjdC51c2VSZWYoZWRpdG9yKTtcbiAgbGV0IHQwLCB0MTtcbiAgcmV0dXJuICRbMF0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQwID0gKCkgPT4gcG9ydGFibGVUZXh0RWRpdG9yUmVmLmN1cnJlbnQsIHQxID0gW10sICRbMF0gPSB0MCwgJFsxXSA9IHQxKSA6ICh0MCA9ICRbMF0sIHQxID0gJFsxXSksIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCB0MCwgdDEpLCBudWxsO1xufSk7XG5FZGl0b3JSZWZQbHVnaW4uZGlzcGxheU5hbWUgPSBcIkVkaXRvclJlZlBsdWdpblwiO1xuZnVuY3Rpb24gRXZlbnRMaXN0ZW5lclBsdWdpbihwcm9wcykge1xuICBjb25zdCAkID0gYyg1KSwgZWRpdG9yID0gdXNlRWRpdG9yKCksIG9uID0gdXNlRWZmZWN0RXZlbnQocHJvcHMub24pO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBvbiA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBlZGl0b3Iub24oXCIqXCIsIG9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IG9uLCAkWzJdID0gdDApIDogdDAgPSAkWzJdO1xuICBsZXQgdDE7XG4gIHJldHVybiAkWzNdICE9PSBlZGl0b3IgPyAodDEgPSBbZWRpdG9yXSwgJFszXSA9IGVkaXRvciwgJFs0XSA9IHQxKSA6IHQxID0gJFs0XSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkJlaGF2aW9ycyhjb25maWcpIHtcbiAgY29uc3QgYXV0b21hdGljQmxvY2txdW90ZU9uU3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmxpbmVPYmplY3QgPSBnZXRQcmV2aW91c0lubGluZU9iamVjdChzbmFwc2hvdCksIGJsb2NrT2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzVGV4dEJsb2NrLm5vZGUuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogZm9jdXNTcGFuLm5vZGUuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldCA/PyAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXZpb3VzSW5saW5lT2JqZWN0IHx8ICFibG9ja09mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChmb2N1c1RleHRCbG9jay5ub2RlKSwgY2FyZXRBdFRoZUVuZE9mUXVvdGUgPSBibG9ja09mZnNldC5vZmZzZXQgPT09IDEsIGxvb2tzTGlrZU1hcmtkb3duUXVvdGUgPSAvXj4vLnRlc3QoYmxvY2tUZXh0KSwgYmxvY2txdW90ZVN0eWxlID0gY29uZmlnLmJsb2NrcXVvdGVTdHlsZT8uKHNuYXBzaG90LmNvbnRleHQpO1xuICAgICAgcmV0dXJuIGNhcmV0QXRUaGVFbmRPZlF1b3RlICYmIGxvb2tzTGlrZU1hcmtkb3duUXVvdGUgJiYgYmxvY2txdW90ZVN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBzdHlsZTogYmxvY2txdW90ZVN0eWxlXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW2V4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgdGV4dDogXCIgXCJcbiAgICB9KV0sIChfLCB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHN0eWxlXG4gICAgfSkgPT4gW2V4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJibG9jay51bnNldFwiLFxuICAgICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0pLCBleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSksIGV4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgYXQ6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSldXVxuICB9KSwgYXV0b21hdGljSHIgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBockNoYXJhY3RlciA9IGV2ZW50LnRleHQgPT09IFwiLVwiID8gXCItXCIgOiBldmVudC50ZXh0ID09PSBcIipcIiA/IFwiKlwiIDogZXZlbnQudGV4dCA9PT0gXCJfXCIgPyBcIl9cIiA6IHZvaWQgMDtcbiAgICAgIGlmIChockNoYXJhY3RlciA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBock9iamVjdCA9IGNvbmZpZy5ob3Jpem9udGFsUnVsZU9iamVjdD8uKHNuYXBzaG90LmNvbnRleHQpLCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZChzbmFwc2hvdCk7XG4gICAgICBpZiAoIWhyT2JqZWN0IHx8ICFmb2N1c0Jsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCB0ZXh0QmVmb3JlID0gZ2V0QmxvY2tUZXh0QmVmb3JlKHNuYXBzaG90KSwgaHJCbG9ja09mZnNldHMgPSB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gIXByZXZpb3VzSW5saW5lT2JqZWN0ICYmIHRleHRCZWZvcmUgPT09IGAke2hyQ2hhcmFjdGVyfSR7aHJDaGFyYWN0ZXJ9YCA/IHtcbiAgICAgICAgaHJPYmplY3QsXG4gICAgICAgIGZvY3VzQmxvY2ssXG4gICAgICAgIGhyQ2hhcmFjdGVyLFxuICAgICAgICBockJsb2NrT2Zmc2V0c1xuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBockNoYXJhY3RlclxuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgIHRleHQ6IGhyQ2hhcmFjdGVyXG4gICAgfSldLCAoXywge1xuICAgICAgaHJPYmplY3QsXG4gICAgICBockJsb2NrT2Zmc2V0c1xuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCIsXG4gICAgICBibG9jazoge1xuICAgICAgICBfdHlwZTogaHJPYmplY3QubmFtZSxcbiAgICAgICAgLi4uaHJPYmplY3QudmFsdWUgPz8ge31cbiAgICAgIH1cbiAgICB9KSwgZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICBhdDogaHJCbG9ja09mZnNldHNcbiAgICB9KV1dXG4gIH0pLCBhdXRvbWF0aWNIck9uUGFzdGUgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiY2xpcGJvYXJkLnBhc3RlXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgdGV4dCA9IGV2ZW50Lm9yaWdpbkV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgaHJSZWdFeHAgPSAvXigtLS0pJHwoX19fKSR8KFxcKlxcKlxcKikkLywgaHJDaGFyYWN0ZXJzID0gdGV4dC5tYXRjaChoclJlZ0V4cCk/LlswXSwgaHJPYmplY3QgPSBjb25maWcuaG9yaXpvbnRhbFJ1bGVPYmplY3Q/LihzbmFwc2hvdC5jb250ZXh0KSwgZm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2soc25hcHNob3QpO1xuICAgICAgcmV0dXJuICFockNoYXJhY3RlcnMgfHwgIWhyT2JqZWN0IHx8ICFmb2N1c0Jsb2NrID8gITEgOiB7XG4gICAgICAgIGhyQ2hhcmFjdGVycyxcbiAgICAgICAgaHJPYmplY3QsXG4gICAgICAgIGZvY3VzQmxvY2tcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGhyQ2hhcmFjdGVyc1xuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgIHRleHQ6IGhyQ2hhcmFjdGVyc1xuICAgIH0pXSwgKHtcbiAgICAgIHNuYXBzaG90XG4gICAgfSwge1xuICAgICAgaHJPYmplY3QsXG4gICAgICBmb2N1c0Jsb2NrXG4gICAgfSkgPT4gaXNUZXh0QmxvY2soc25hcHNob3QuY29udGV4dCwgZm9jdXNCbG9jay5ub2RlKSA/IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICBibG9jazoge1xuICAgICAgICBfdHlwZTogc25hcHNob3QuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSxcbiAgICAgICAgY2hpbGRyZW46IGZvY3VzQmxvY2subm9kZS5jaGlsZHJlblxuICAgICAgfSxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gICAgfSksIGV4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2tcIixcbiAgICAgIGJsb2NrOiB7XG4gICAgICAgIF90eXBlOiBock9iamVjdC5uYW1lLFxuICAgICAgICAuLi5ock9iamVjdC52YWx1ZSA/PyB7fVxuICAgICAgfSxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gICAgfSksIGV4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICAgIGF0OiBmb2N1c0Jsb2NrLnBhdGhcbiAgICB9KV0gOiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9ja1wiLFxuICAgICAgYmxvY2s6IHtcbiAgICAgICAgX3R5cGU6IGhyT2JqZWN0Lm5hbWUsXG4gICAgICAgIC4uLmhyT2JqZWN0LnZhbHVlID8/IHt9XG4gICAgICB9LFxuICAgICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgICB9KV1dXG4gIH0pLCBhdXRvbWF0aWNIZWFkaW5nT25TcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChldmVudC50ZXh0ICE9PSBcIiBcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KTtcbiAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBibG9ja09mZnNldCA9IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDoge1xuICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1RleHRCbG9jay5ub2RlLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzU3Bhbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPz8gMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghYmxvY2tPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHByZXZpb3VzSW5saW5lT2JqZWN0ID0gZ2V0UHJldmlvdXNJbmxpbmVPYmplY3Qoc25hcHNob3QpLCBibG9ja1RleHQgPSBnZXRUZXh0QmxvY2tUZXh0KGZvY3VzVGV4dEJsb2NrLm5vZGUpLCBtYXJrZG93bkhlYWRpbmdTZWFyY2ggPSAvXiMrLy5leGVjKGJsb2NrVGV4dCksIGxldmVsID0gbWFya2Rvd25IZWFkaW5nU2VhcmNoID8gbWFya2Rvd25IZWFkaW5nU2VhcmNoWzBdLmxlbmd0aCA6IHZvaWQgMCwgY2FyZXRBdFRoZUVuZE9mSGVhZGluZyA9IGJsb2NrT2Zmc2V0Lm9mZnNldCA9PT0gbGV2ZWw7XG4gICAgICBpZiAocHJldmlvdXNJbmxpbmVPYmplY3QgfHwgIWNhcmV0QXRUaGVFbmRPZkhlYWRpbmcpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHN0eWxlID0gbGV2ZWwgIT09IHZvaWQgMCA/IGNvbmZpZy5oZWFkaW5nU3R5bGU/Lih7XG4gICAgICAgIHNjaGVtYTogc25hcHNob3QuY29udGV4dC5zY2hlbWEsXG4gICAgICAgIGxldmVsXG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBsZXZlbCAhPT0gdm9pZCAwICYmIHN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgbGV2ZWxcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbZXhlY3V0ZShldmVudCldLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZSxcbiAgICAgIGxldmVsXG4gICAgfSkgPT4gW2V4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJibG9jay51bnNldFwiLFxuICAgICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0pLCBleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSksIGV4ZWN1dGUoe1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgYXQ6IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogbGV2ZWwgKyAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KV1dXG4gIH0pLCBjbGVhclN0eWxlT25CYWNrc3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHNuYXBzaG90KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhzbmFwc2hvdCksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3BhbihzbmFwc2hvdCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYXRUaGVCZWdpbm5pbmdPZkJMb2NrID0gZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIHNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAsIGRlZmF1bHRTdHlsZSA9IGNvbmZpZy5kZWZhdWx0U3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KTtcbiAgICAgIHJldHVybiBhdFRoZUJlZ2lubmluZ09mQkxvY2sgJiYgZGVmYXVsdFN0eWxlICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUuc3R5bGUgIT09IGRlZmF1bHRTdHlsZSA/IHtcbiAgICAgICAgZGVmYXVsdFN0eWxlLFxuICAgICAgICBmb2N1c1RleHRCbG9ja1xuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBkZWZhdWx0U3R5bGUsXG4gICAgICBmb2N1c1RleHRCbG9ja1xuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgICB9LFxuICAgICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9KV1dXG4gIH0pLCBhdXRvbWF0aWNMaXN0T25TcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3QsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChldmVudC50ZXh0ICE9PSBcIiBcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoc25hcHNob3QpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHNuYXBzaG90KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHNuYXBzaG90KTtcbiAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBwcmV2aW91c0lubGluZU9iamVjdCA9IGdldFByZXZpb3VzSW5saW5lT2JqZWN0KHNuYXBzaG90KSwgYmxvY2tPZmZzZXQgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IHtcbiAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgX2tleTogZm9jdXNUZXh0QmxvY2subm9kZS5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1NwYW4ubm9kZS5fa2V5XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgb2Zmc2V0OiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID8/IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocHJldmlvdXNJbmxpbmVPYmplY3QgfHwgIWJsb2NrT2Zmc2V0KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBibG9ja1RleHQgPSBnZXRUZXh0QmxvY2tUZXh0KGZvY3VzVGV4dEJsb2NrLm5vZGUpLCBkZWZhdWx0U3R5bGUgPSBjb25maWcuZGVmYXVsdFN0eWxlPy4oc25hcHNob3QuY29udGV4dCksIGxvb2tzTGlrZVVub3JkZXJlZExpc3QgPSAvXigtfFxcKikvLnRlc3QoYmxvY2tUZXh0KSwgdW5vcmRlcmVkTGlzdFN0eWxlID0gY29uZmlnLnVub3JkZXJlZExpc3RTdHlsZT8uKHNuYXBzaG90LmNvbnRleHQpLCBjYXJldEF0VGhlRW5kT2ZVbm9yZGVyZWRMaXN0ID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAxO1xuICAgICAgaWYgKGRlZmF1bHRTdHlsZSAmJiBjYXJldEF0VGhlRW5kT2ZVbm9yZGVyZWRMaXN0ICYmIGxvb2tzTGlrZVVub3JkZXJlZExpc3QgJiYgdW5vcmRlcmVkTGlzdFN0eWxlICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgICAgbGlzdEl0ZW06IHVub3JkZXJlZExpc3RTdHlsZSxcbiAgICAgICAgICBsaXN0SXRlbUxlbmd0aDogMSxcbiAgICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgICAgIH07XG4gICAgICBjb25zdCBsb29rc0xpa2VPcmRlcmVkTGlzdCA9IC9eMVxcLi8udGVzdChibG9ja1RleHQpLCBvcmRlcmVkTGlzdFN0eWxlID0gY29uZmlnLm9yZGVyZWRMaXN0U3R5bGU/LihzbmFwc2hvdC5jb250ZXh0KSwgY2FyZXRBdFRoZUVuZE9mT3JkZXJlZExpc3QgPSBibG9ja09mZnNldC5vZmZzZXQgPT09IDI7XG4gICAgICByZXR1cm4gZGVmYXVsdFN0eWxlICYmIGNhcmV0QXRUaGVFbmRPZk9yZGVyZWRMaXN0ICYmIGxvb2tzTGlrZU9yZGVyZWRMaXN0ICYmIG9yZGVyZWRMaXN0U3R5bGUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgIGxpc3RJdGVtOiBvcmRlcmVkTGlzdFN0eWxlLFxuICAgICAgICBsaXN0SXRlbUxlbmd0aDogMixcbiAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtleGVjdXRlKGV2ZW50KV0sIChfLCB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHN0eWxlLFxuICAgICAgbGlzdEl0ZW0sXG4gICAgICBsaXN0SXRlbUxlbmd0aFxuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiYmxvY2suc2V0XCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICBsaXN0SXRlbSxcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9KSwgZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICBhdDoge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBsaXN0SXRlbUxlbmd0aCArIDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXV1cbiAgfSk7XG4gIHJldHVybiBbYXV0b21hdGljQmxvY2txdW90ZU9uU3BhY2UsIGF1dG9tYXRpY0hlYWRpbmdPblNwYWNlLCBhdXRvbWF0aWNIciwgYXV0b21hdGljSHJPblBhc3RlLCBjbGVhclN0eWxlT25CYWNrc3BhY2UsIGF1dG9tYXRpY0xpc3RPblNwYWNlXTtcbn1cbmZ1bmN0aW9uIE1hcmtkb3duUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDE3KSwgZWRpdG9yID0gdXNlRWRpdG9yKCk7XG4gIGxldCB0MCwgdDE7XG4gICRbMF0gIT09IGVkaXRvciB8fCAkWzFdICE9PSBwcm9wcy5jb25maWcgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3QgdW5yZWdpc3RlckJlaGF2aW9ycyA9IGNyZWF0ZU1hcmtkb3duQmVoYXZpb3JzKHByb3BzLmNvbmZpZykubWFwKChiZWhhdmlvcikgPT4gZWRpdG9yLnJlZ2lzdGVyQmVoYXZpb3Ioe1xuICAgICAgYmVoYXZpb3JcbiAgICB9KSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdW5yZWdpc3RlckJlaGF2aW9yIG9mIHVucmVnaXN0ZXJCZWhhdmlvcnMpXG4gICAgICAgIHVucmVnaXN0ZXJCZWhhdmlvcigpO1xuICAgIH07XG4gIH0sIHQxID0gW2VkaXRvciwgcHJvcHMuY29uZmlnXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IHByb3BzLmNvbmZpZywgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSk7XG4gIGxldCB0MjtcbiAgJFs0XSAhPT0gcHJvcHMuY29uZmlnLmJvbGREZWNvcmF0b3IgPyAodDIgPSBwcm9wcy5jb25maWcuYm9sZERlY29yYXRvciA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5ib2xkRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIipcIixcbiAgICAgIGFtb3VudDogMlxuICAgIH0gfSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5ib2xkRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIl9cIixcbiAgICAgIGFtb3VudDogMlxuICAgIH0gfSlcbiAgXSB9KSA6IG51bGwsICRbNF0gPSBwcm9wcy5jb25maWcuYm9sZERlY29yYXRvciwgJFs1XSA9IHQyKSA6IHQyID0gJFs1XTtcbiAgbGV0IHQzO1xuICAkWzZdICE9PSBwcm9wcy5jb25maWcuY29kZURlY29yYXRvciA/ICh0MyA9IHByb3BzLmNvbmZpZy5jb2RlRGVjb3JhdG9yID8gLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5jb2RlRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgY2hhcjogXCJgXCIsXG4gICAgYW1vdW50OiAxXG4gIH0gfSkgOiBudWxsLCAkWzZdID0gcHJvcHMuY29uZmlnLmNvZGVEZWNvcmF0b3IsICRbN10gPSB0MykgOiB0MyA9ICRbN107XG4gIGxldCB0NDtcbiAgJFs4XSAhPT0gcHJvcHMuY29uZmlnLml0YWxpY0RlY29yYXRvciA/ICh0NCA9IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IgPyAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVjb3JhdG9yU2hvcnRjdXRQbHVnaW4sIHsgZGVjb3JhdG9yOiBwcm9wcy5jb25maWcuaXRhbGljRGVjb3JhdG9yLCBwYWlyOiB7XG4gICAgICBjaGFyOiBcIipcIixcbiAgICAgIGFtb3VudDogMVxuICAgIH0gfSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbiwgeyBkZWNvcmF0b3I6IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IsIHBhaXI6IHtcbiAgICAgIGNoYXI6IFwiX1wiLFxuICAgICAgYW1vdW50OiAxXG4gICAgfSB9KVxuICBdIH0pIDogbnVsbCwgJFs4XSA9IHByb3BzLmNvbmZpZy5pdGFsaWNEZWNvcmF0b3IsICRbOV0gPSB0NCkgOiB0NCA9ICRbOV07XG4gIGxldCB0NTtcbiAgJFsxMF0gIT09IHByb3BzLmNvbmZpZy5zdHJpa2VUaHJvdWdoRGVjb3JhdG9yID8gKHQ1ID0gcHJvcHMuY29uZmlnLnN0cmlrZVRocm91Z2hEZWNvcmF0b3IgPyAvKiBAX19QVVJFX18gKi8ganN4KERlY29yYXRvclNob3J0Y3V0UGx1Z2luLCB7IGRlY29yYXRvcjogcHJvcHMuY29uZmlnLnN0cmlrZVRocm91Z2hEZWNvcmF0b3IsIHBhaXI6IHtcbiAgICBjaGFyOiBcIn5cIixcbiAgICBhbW91bnQ6IDJcbiAgfSB9KSA6IG51bGwsICRbMTBdID0gcHJvcHMuY29uZmlnLnN0cmlrZVRocm91Z2hEZWNvcmF0b3IsICRbMTFdID0gdDUpIDogdDUgPSAkWzExXTtcbiAgbGV0IHQ2O1xuICByZXR1cm4gJFsxMl0gIT09IHQyIHx8ICRbMTNdICE9PSB0MyB8fCAkWzE0XSAhPT0gdDQgfHwgJFsxNV0gIT09IHQ1ID8gKHQ2ID0gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICB0MixcbiAgICB0MyxcbiAgICB0NCxcbiAgICB0NVxuICBdIH0pLCAkWzEyXSA9IHQyLCAkWzEzXSA9IHQzLCAkWzE0XSA9IHQ0LCAkWzE1XSA9IHQ1LCAkWzE2XSA9IHQ2KSA6IHQ2ID0gJFsxNl0sIHQ2O1xufVxuY29uc3Qgb25lTGluZUJlaGF2aW9ycyA9IFtcbiAgLyoqXG4gICAqIEhpdHRpbmcgRW50ZXIgb24gYW4gZXhwYW5kZWQgc2VsZWN0aW9uIHNob3VsZCBqdXN0IGRlbGV0ZSB0aGF0IHNlbGVjdGlvblxuICAgKiB3aXRob3V0IGNhdXNpbmcgYSBsaW5lIGJyZWFrLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5icmVha1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbiAmJiBpc1NlbGVjdGlvbkV4cGFuZGVkKHNuYXBzaG90KSA/IHtcbiAgICAgIHNlbGVjdGlvbjogc25hcHNob3QuY29udGV4dC5zZWxlY3Rpb25cbiAgICB9IDogITEsXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9KSA9PiBbZXhlY3V0ZSh7XG4gICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgYXQ6IHNlbGVjdGlvblxuICAgIH0pXV1cbiAgfSksXG4gIC8qKlxuICAgKiBBbGwgb3RoZXIgY2FzZXMgb2YgYGluc2VydC5icmVha2Agc2hvdWxkIGJlIGFib3J0ZWQuXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gICAgYWN0aW9uczogW11cbiAgfSksXG4gIC8qKlxuICAgKiBgaW5zZXJ0LmJsb2NrYCBgYmVmb3JlYCBvciBgYWZ0ZXJgIGlzIG5vdCBhbGxvd2VkIGluIGEgb25lLWxpbmUgZWRpdG9yLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja1wiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBldmVudC5wbGFjZW1lbnQgPT09IFwiYmVmb3JlXCIgfHwgZXZlbnQucGxhY2VtZW50ID09PSBcImFmdGVyXCIsXG4gICAgYWN0aW9uczogW11cbiAgfSksXG4gIC8qKlxuICAgKiBBbiBvcmRpbmFyeSBgaW5zZXJ0LmJsb2NrYCBpcyBhY2NlcHRhYmxlIGlmIGl0J3MgYSB0ZXh0IGJsb2NrLiBJbiB0aGF0XG4gICAqIGNhc2UgaXQgd2lsbCBnZXQgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIHRleHQgYmxvY2suXG4gICAqL1xuICBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBzbmFwc2hvdCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gISghZ2V0Rm9jdXNUZXh0QmxvY2soc25hcHNob3QpIHx8ICFpc1RleHRCbG9jayQxKHNuYXBzaG90LmNvbnRleHQsIGV2ZW50LmJsb2NrKSksXG4gICAgYWN0aW9uczogWyh7XG4gICAgICBldmVudFxuICAgIH0pID0+IFtleGVjdXRlKHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICBibG9jazogZXZlbnQuYmxvY2ssXG4gICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiLFxuICAgICAgc2VsZWN0OiBcImVuZFwiXG4gICAgfSldXVxuICB9KSxcbiAgLyoqXG4gICAqIEZhbGxiYWNrIEJlaGF2aW9yIHRvIGF2b2lkIGBpbnNlcnQuYmxvY2tgIGluIGNhc2UgdGhlIEJlaGF2aW9ycyBhYm92ZSBhbGxcbiAgICogZW5kIHVwIHdpdGggYSBmYWxzeSBndWFyZC5cbiAgICovXG4gIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQuYmxvY2tcIixcbiAgICBhY3Rpb25zOiBbXVxuICB9KSxcbiAgLyoqXG4gICAqIElmIG11bHRpcGxlIGJsb2NrcyBhcmUgaW5zZXJ0ZWQsIHRoZW4gdGhlIG5vbi10ZXh0IGJsb2NrcyBhcmUgZmlsdGVyZWQgb3V0XG4gICAqIGFuZCB0aGUgdGV4dCBibG9ja3MgYXJlIG1lcmdlZCBpbnRvIG9uZSBibG9ja1xuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgICBndWFyZDogKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2tzID0gZXZlbnQuYmxvY2tzLmZpbHRlcigoYmxvY2spID0+IGlzVGV4dEJsb2NrJDEoc25hcHNob3QuY29udGV4dCwgYmxvY2spKTtcbiAgICAgIHJldHVybiB0ZXh0QmxvY2tzLmxlbmd0aCA9PT0gMCA/ICExIDogdGV4dEJsb2Nrcy5yZWR1Y2UoKHRhcmdldEJsb2NrLCBpbmNvbWluZ0Jsb2NrKSA9PiBtZXJnZVRleHRCbG9ja3Moe1xuICAgICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICB0YXJnZXRCbG9jayxcbiAgICAgICAgaW5jb21pbmdCbG9ja1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgYWN0aW9uczogW1xuICAgICAgLy8gYGluc2VydC5ibG9ja2AgaXMgcmFpc2VkIHNvIHRoZSBCZWhhdmlvciBhYm92ZSBjYW4gaGFuZGxlIHRoZVxuICAgICAgLy8gaW5zZXJ0aW9uXG4gICAgICAoXywgYmxvY2spID0+IFtyYWlzZSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrXCIsXG4gICAgICAgIGJsb2NrLFxuICAgICAgICBwbGFjZW1lbnQ6IFwiYXV0b1wiXG4gICAgICB9KV1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogRmFsbGJhY2sgQmVoYXZpb3IgdG8gYXZvaWQgYGluc2VydC5ibG9ja3NgIGluIGNhc2UgdGhlIEJlaGF2aW9yIGFib3ZlXG4gICAqIGVuZHMgdXAgd2l0aCBhIGZhbHN5IGd1YXJkLlxuICAgKi9cbiAgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC5ibG9ja3NcIixcbiAgICBhY3Rpb25zOiBbXVxuICB9KVxuXTtcbmZ1bmN0aW9uIE9uZUxpbmVQbHVnaW4oKSB7XG4gIGNvbnN0ICQgPSBjKDEpO1xuICBsZXQgdDA7XG4gIHJldHVybiAkWzBdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goQmVoYXZpb3JQbHVnaW4sIHsgYmVoYXZpb3JzOiBvbmVMaW5lQmVoYXZpb3JzIH0pLCAkWzBdID0gdDApIDogdDAgPSAkWzBdLCB0MDtcbn1cbmV4cG9ydCB7XG4gIEJlaGF2aW9yUGx1Z2luLFxuICBEZWNvcmF0b3JTaG9ydGN1dFBsdWdpbixcbiAgRWRpdG9yUmVmUGx1Z2luLFxuICBFdmVudExpc3RlbmVyUGx1Z2luLFxuICBNYXJrZG93blBsdWdpbixcbiAgT25lTGluZVBsdWdpblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/plugins/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`\n    );\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(\n  Object.prototype.hasOwnProperty\n);\nfunction move(arr, from, to) {\n  const nextValue = arr.slice(), val = nextValue[from];\n  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    } else if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"move\") {\n        if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\"))\n          throw new Error(\n            `Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(\n              patch.value\n            )}`\n          );\n        return move(nextValue, patch.value.from, patch.value.to);\n      }\n    }\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`\n        );\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = _apply(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction apply$2(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value))\n        throw new Error(\"Cannot set value of an object to a non-object\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"setIfMissing\")\n        return value === void 0 ? patch.value : value;\n    }\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instad got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n    ...patch,\n    path: tail\n  }), nextValue);\n}\nconst OPERATIONS$1 = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  inc(currentValue, nextValue) {\n    return currentValue + nextValue;\n  },\n  dec(currentValue, nextValue) {\n    return currentValue - nextValue;\n  }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  diffMatchPatch(currentValue, nextValue) {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  const func = OPERATIONS[patch.type];\n  if (func)\n    return func(value, patch.value);\n  throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n  return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVMsb0JBQW9CLFFBQVEsS0FBSyxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsdURBQXVELDJDQUFJO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxjQUFjLDBEQUEwRCwyQkFBMkIsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0VBQVksQ0FBQyxvRUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVyxjQUFjLHNCQUFzQiwyQkFBMkIsc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFRLGdDQUFnQywrQ0FBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYW50ZWMvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanM/MDNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNPYmplY3QgZnJvbSBcImxvZGFzaC9pc09iamVjdC5qc1wiO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gXCJsb2Rhc2gvaXNTdHJpbmcuanNcIjtcbmltcG9ydCBmaW5kSW5kZXggZnJvbSBcImxvZGFzaC9maW5kSW5kZXguanNcIjtcbmltcG9ydCBjbG9uZSBmcm9tIFwibG9kYXNoL2Nsb25lLmpzXCI7XG5pbXBvcnQgb21pdCBmcm9tIFwibG9kYXNoL29taXQuanNcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2hlcywgcGFyc2VQYXRjaCwgbWFrZVBhdGNoZXMsIHN0cmluZ2lmeVBhdGNoZXMgfSBmcm9tIFwiQHNhbml0eS9kaWZmLW1hdGNoLXBhdGNoXCI7XG5jb25zdCBCRUZPUkUgPSBcImJlZm9yZVwiLCBBRlRFUiA9IFwiYWZ0ZXJcIjtcbmZ1bmN0aW9uIGluc2VydCQxKGFycmF5LCBwb3NpdGlvbiwgaW5kZXgsIC4uLmFyZ3MpIHtcbiAgaWYgKHBvc2l0aW9uICE9PSBCRUZPUkUgJiYgcG9zaXRpb24gIT09IEFGVEVSKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHBvc2l0aW9uIFwiJHtwb3NpdGlvbn1cIiwgbXVzdCBiZSBlaXRoZXIgJHtCRUZPUkV9IG9yICR7QUZURVJ9YFxuICAgICk7XG4gIGNvbnN0IGl0ZW1zID0gZmxhdHRlbiguLi5hcmdzKTtcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gaXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aCwgaWR4ID0gTWF0aC5hYnMoKGxlbiArIGluZGV4KSAlIGxlbikgJSBsZW4sIG5vcm1hbGl6ZWRJZHggPSBwb3NpdGlvbiA9PT0gXCJhZnRlclwiID8gaWR4ICsgMSA6IGlkeCwgY29weSA9IGFycmF5LnNsaWNlKCk7XG4gIHJldHVybiBjb3B5LnNwbGljZShub3JtYWxpemVkSWR4LCAwLCAuLi5mbGF0dGVuKGl0ZW1zKSksIGNvcHk7XG59XG5mdW5jdGlvbiBmbGF0dGVuKC4uLnZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzLnJlZHVjZSgocHJldiwgaXRlbSkgPT4gcHJldi5jb25jYXQoaXRlbSksIFtdKTtcbn1cbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbC5iaW5kKFxuICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4pO1xuZnVuY3Rpb24gbW92ZShhcnIsIGZyb20sIHRvKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IGFyci5zbGljZSgpLCB2YWwgPSBuZXh0VmFsdWVbZnJvbV07XG4gIHJldHVybiBuZXh0VmFsdWUuc3BsaWNlKGZyb20sIDEpLCBuZXh0VmFsdWUuc3BsaWNlKHRvLCAwLCB2YWwpLCBuZXh0VmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kVGFyZ2V0SW5kZXgoYXJyYXksIHBhdGhTZWdtZW50KSB7XG4gIGlmICh0eXBlb2YgcGF0aFNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gcGF0aFNlZ21lbnQ7XG4gIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KGFycmF5LCBwYXRoU2VnbWVudCk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAhMSA6IGluZGV4O1xufVxuZnVuY3Rpb24gYXBwbHkkMyh2YWx1ZSwgcGF0Y2gpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0SWZNaXNzaW5nXCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gYXJyYXkgdG8gYSBub24tYXJyYXlcIik7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHBhdGNoLnZhbHVlIDogdmFsdWU7XG4gICAgfSBlbHNlIGlmIChwYXRjaC50eXBlID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIGFycmF5IHRvIGEgbm9uLWFycmF5XCIpO1xuICAgICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgaWYgKCFwYXRjaC52YWx1ZSB8fCAhaGFzT3duKHBhdGNoLnZhbHVlLCBcImZyb21cIikgfHwgIWhhc093bihwYXRjaC52YWx1ZSwgXCJ0b1wiKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBvZiAnbW92ZScgcGF0Y2guIEV4cGVjdGVkIGEgdmFsdWUgd2l0aCBcImZyb21cIiBhbmQgXCJ0b1wiIGluZGV4ZXMsIGluc3RlYWQgZ290OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBwYXRjaC52YWx1ZVxuICAgICAgICAgICAgKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1vdmUobmV4dFZhbHVlLCBwYXRjaC52YWx1ZS5mcm9tLCBwYXRjaC52YWx1ZS50byk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSBvcGVyYXRpb246ICR7cGF0Y2gudHlwZX1gKTtcbiAgfVxuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBwYXRjaC5wYXRoLCBpbmRleCA9IGZpbmRUYXJnZXRJbmRleCh2YWx1ZSwgaGVhZCk7XG4gIGlmIChpbmRleCA9PT0gITEpXG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgaWYgKHRhaWwubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb24sIGl0ZW1zIH0gPSBwYXRjaDtcbiAgICAgIHJldHVybiBpbnNlcnQkMSh2YWx1ZSwgcG9zaXRpb24sIGluZGV4LCBpdGVtcyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBhcnJheSBpbmRleCB0byBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgXCIke2luZGV4fVwiYFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZS5zcGxpY2UoaW5kZXgsIDEpLCBuZXh0VmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0VmFsdWVbaW5kZXhdID0gX2FwcGx5KG5leHRWYWx1ZVtpbmRleF0sIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiB0YWlsXG4gIH0pLCBuZXh0VmFsdWU7XG59XG5mdW5jdGlvbiBhcHBseSQyKHZhbHVlLCBwYXRjaCkge1xuICBjb25zdCBuZXh0VmFsdWUgPSBjbG9uZSh2YWx1ZSk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBvYmplY3QgdG8gYSBub24tb2JqZWN0XCIpO1xuICAgICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRJZk1pc3NpbmdcIilcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBwYXRjaC52YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb2JqZWN0IG9wZXJhdGlvbjogJHtwYXRjaC50eXBlfWApO1xuICB9XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGNoLnBhdGg7XG4gIGlmICh0eXBlb2YgaGVhZCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZmllbGQgbmFtZSB0byBiZSBhIHN0cmluZywgaW5zdGFkIGdvdDogJHtoZWFkfWApO1xuICByZXR1cm4gdGFpbC5sZW5ndGggPT09IDAgJiYgcGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiID8gb21pdChuZXh0VmFsdWUsIGhlYWQpIDogKG5leHRWYWx1ZVtoZWFkXSA9IF9hcHBseShuZXh0VmFsdWVbaGVhZF0sIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiB0YWlsXG4gIH0pLCBuZXh0VmFsdWUpO1xufVxuY29uc3QgT1BFUkFUSU9OUyQxID0ge1xuICByZXBsYWNlKF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldChfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXRJZk1pc3NpbmcoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSB2b2lkIDAgPyBuZXh0VmFsdWUgOiBjdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVuc2V0KF9jdXJyZW50VmFsdWUsIF9uZXh0VmFsdWUpIHtcbiAgfSxcbiAgaW5jKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSArIG5leHRWYWx1ZTtcbiAgfSxcbiAgZGVjKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSAtIG5leHRWYWx1ZTtcbiAgfVxufSwgU1VQUE9SVEVEX1BBVENIX1RZUEVTJDEgPSBPYmplY3Qua2V5cyhPUEVSQVRJT05TJDEpO1xuZnVuY3Rpb24gYXBwbHkkMSh2YWx1ZSwgcGF0Y2gpIHtcbiAgaWYgKCFTVVBQT1JURURfUEFUQ0hfVFlQRVMkMS5pbmNsdWRlcyhwYXRjaC50eXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgcGF0Y2ggb2YgdW5zdXBwb3J0ZWQgdHlwZTogXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBwYXRjaC50eXBlXG4gICAgICApfVwiIGZvciBwcmltaXRpdmVzLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgYXBwbHkgZGVlcCBvcGVyYXRpb25zIG9uIHByaW1pdGl2ZSB2YWx1ZXMuIFJlY2VpdmVkIHBhdGNoIHdpdGggdHlwZSBcIiR7cGF0Y2gudHlwZX1cIiBhbmQgcGF0aCBcIiR7cGF0Y2gucGF0aC5tYXAoKHBhdGgpID0+IEpTT04uc3RyaW5naWZ5KHBhdGgpKS5qb2luKFwiLlwiKX0gdGhhdCB0YXJnZXRlZCB0aGUgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cImBcbiAgICApO1xuICByZXR1cm4gT1BFUkFUSU9OUyQxW3BhdGNoLnR5cGVdKHZhbHVlLCBwYXRjaC52YWx1ZSk7XG59XG5jb25zdCBPUEVSQVRJT05TID0ge1xuICByZXBsYWNlKF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldChfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXRJZk1pc3NpbmcoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSB2b2lkIDAgPyBuZXh0VmFsdWUgOiBjdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVuc2V0KF9jdXJyZW50VmFsdWUsIF9uZXh0VmFsdWUpIHtcbiAgfSxcbiAgZGlmZk1hdGNoUGF0Y2goY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICBjb25zdCBbcmVzdWx0XSA9IGFwcGx5UGF0Y2hlcyhwYXJzZVBhdGNoKG5leHRWYWx1ZSksIGN1cnJlbnRWYWx1ZSwge1xuICAgICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMFxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0sIFNVUFBPUlRFRF9QQVRDSF9UWVBFUyA9IE9iamVjdC5rZXlzKE9QRVJBVElPTlMpO1xuZnVuY3Rpb24gYXBwbHkodmFsdWUsIHBhdGNoKSB7XG4gIGlmICghU1VQUE9SVEVEX1BBVENIX1RZUEVTLmluY2x1ZGVzKHBhdGNoLnR5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHN0cmluZy4gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IGFwcGx5IGRlZXAgb3BlcmF0aW9ucyBvbiBzdHJpbmcgdmFsdWVzLiBSZWNlaXZlZCBwYXRjaCB3aXRoIHR5cGUgXCIke3BhdGNoLnR5cGV9XCIgYW5kIHBhdGggXCIke3BhdGNoLnBhdGguam9pbihcIi5cIil9IHRoYXQgdGFyZ2V0ZWQgdGhlIHZhbHVlIFwiJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XCJgXG4gICAgKTtcbiAgY29uc3QgZnVuYyA9IE9QRVJBVElPTlNbcGF0Y2gudHlwZV07XG4gIGlmIChmdW5jKVxuICAgIHJldHVybiBmdW5jKHZhbHVlLCBwYXRjaC52YWx1ZSk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcGF0Y2ggdHlwZVwiKTtcbn1cbmZ1bmN0aW9uIGFwcGx5QWxsKHZhbHVlLCBwYXRjaGVzKSB7XG4gIHJldHVybiBwYXRjaGVzLnJlZHVjZShfYXBwbHksIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2godmFsdWUsIHBhdGNoKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGFwcGx5JDModmFsdWUsIHBhdGNoKSA6IGlzU3RyaW5nKHZhbHVlKSA/IGFwcGx5KHZhbHVlLCBwYXRjaCkgOiBpc09iamVjdCh2YWx1ZSkgPyBhcHBseSQyKHZhbHVlLCBwYXRjaCkgOiBhcHBseSQxKHZhbHVlLCBwYXRjaCk7XG59XG5mdW5jdGlvbiBfYXBwbHkodmFsdWUsIHBhdGNoKSB7XG4gIHJldHVybiBhcHBseVBhdGNoKHZhbHVlLCBwYXRjaCk7XG59XG5mdW5jdGlvbiBzZXRJZk1pc3NpbmcodmFsdWUsIHBhdGggPSBbXSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2V0SWZNaXNzaW5nXCIsXG4gICAgcGF0aCxcbiAgICB2YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goY3VycmVudFZhbHVlLCBuZXh0VmFsdWUsIHBhdGggPSBbXSkge1xuICBjb25zdCBwYXRjaGVzID0gbWFrZVBhdGNoZXMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpLCBwYXRjaCA9IHN0cmluZ2lmeVBhdGNoZXMocGF0Y2hlcyk7XG4gIHJldHVybiB7IHR5cGU6IFwiZGlmZk1hdGNoUGF0Y2hcIiwgcGF0aCwgdmFsdWU6IHBhdGNoIH07XG59XG5mdW5jdGlvbiBpbnNlcnQoaXRlbXMsIHBvc2l0aW9uLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIHBhdGgsXG4gICAgcG9zaXRpb24sXG4gICAgaXRlbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldCh2YWx1ZSwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7IHR5cGU6IFwic2V0XCIsIHBhdGgsIHZhbHVlIH07XG59XG5mdW5jdGlvbiB1bnNldChwYXRoID0gW10pIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJ1bnNldFwiLCBwYXRoIH07XG59XG5mdW5jdGlvbiBwcmVmaXhQYXRoKHBhdGNoLCBzZWdtZW50KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogW3NlZ21lbnQsIC4uLnBhdGNoLnBhdGhdXG4gIH07XG59XG5leHBvcnQge1xuICBhcHBseUFsbCxcbiAgZGlmZk1hdGNoUGF0Y2gsXG4gIGluc2VydCxcbiAgcHJlZml4UGF0aCxcbiAgc2V0LFxuICBzZXRJZk1pc3NpbmcsXG4gIHVuc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value?.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsa0NBQWtDLHFEQUFxRDtBQUNyVCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4Qiw2QkFBNkIsZUFBZTtBQUNwSTtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3JlYWN0L2Rpc3QvaW5kZXguanM/NGMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfZXhjbHVkZWQgPSBbXCJibG9ja1wiLCBcImxpc3RcIiwgXCJsaXN0SXRlbVwiLCBcIm1hcmtzXCIsIFwidHlwZXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJsaXN0SXRlbVwiXSxcbiAgX2V4Y2x1ZGVkMyA9IFtcIl9rZXlcIl07XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7IGlmIChudWxsID09IGUpIHJldHVybiB7fTsgdmFyIG8sIHIsIGkgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyBmb3IgKHIgPSAwOyByIDwgcy5sZW5ndGg7IHIrKykgbyA9IHNbcl0sIHQuaW5jbHVkZXMobykgfHwge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pOyB9IHJldHVybiBpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7IGlmIChudWxsID09IHIpIHJldHVybiB7fTsgdmFyIHQgPSB7fTsgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkgeyBpZiAoZS5pbmNsdWRlcyhuKSkgY29udGludWU7IHRbbl0gPSByW25dOyB9IHJldHVybiB0OyB9XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBuZXN0TGlzdHMsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIHNwYW5Ub1BsYWluVGV4dCwgYnVpbGRNYXJrc1RyZWUgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB0b1BsYWluVGV4dCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGRlZmF1bHRMaXN0cyA9IHtcbiAgICBudW1iZXI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcIm9sXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgYnVsbGV0OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0sXG4gIERlZmF1bHRMaXN0SXRlbSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwibGlcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBsaW5rID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICB2YWx1ZVxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJhXCIsIHtcbiAgICBocmVmOiB2YWx1ZT8uaHJlZixcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgdW5kZXJsaW5lU3R5bGUgPSB7XG4gICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCJcbiAgfSxcbiAgZGVmYXVsdE1hcmtzID0ge1xuICAgIGVtOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJlbVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIHN0cm9uZzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3Ryb25nXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgY29kZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiY29kZVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIHVuZGVybGluZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgICBzdHlsZTogdW5kZXJsaW5lU3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIFwic3RyaWtlLXRocm91Z2hcIjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiZGVsXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgbGlua1xuICB9LFxuICBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBgW0Bwb3J0YWJsZXRleHQvcmVhY3RdIFVua25vd24gJHt0eXBlfSwgc3BlY2lmeSBhIGNvbXBvbmVudCBmb3IgaXQgaW4gdGhlIFxcYGNvbXBvbmVudHMuJHtwcm9wfVxcYCBwcm9wYCxcbiAgdW5rbm93blR5cGVXYXJuaW5nID0gdHlwZU5hbWUgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHR5cGUgXCIke3R5cGVOYW1lfVwiYCwgXCJ0eXBlc1wiKSxcbiAgdW5rbm93bk1hcmtXYXJuaW5nID0gbWFya1R5cGUgPT4gZ2V0VGVtcGxhdGUoYG1hcmsgdHlwZSBcIiR7bWFya1R5cGV9XCJgLCBcIm1hcmtzXCIpLFxuICB1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcgPSBibG9ja1N0eWxlID0+IGdldFRlbXBsYXRlKGBibG9jayBzdHlsZSBcIiR7YmxvY2tTdHlsZX1cImAsIFwiYmxvY2tcIiksXG4gIHVua25vd25MaXN0U3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKGBsaXN0IHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RcIiksXG4gIHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBpdGVtIHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RJdGVtXCIpO1xuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufVxuY29uc3QgaGlkZGVuID0ge1xuICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gIH0sXG4gIERlZmF1bHRVbmtub3duVHlwZSA9ICh7XG4gICAgdmFsdWUsXG4gICAgaXNJbmxpbmVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHdhcm5pbmcgPSB1bmtub3duVHlwZVdhcm5pbmcodmFsdWUuX3R5cGUpO1xuICAgIHJldHVybiBpc0lubGluZSA/IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IGhpZGRlbixcbiAgICAgIGNoaWxkcmVuOiB3YXJuaW5nXG4gICAgfSkgOiAvKiBAX19QVVJFX18gKi9qc3goXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IGhpZGRlbixcbiAgICAgIGNoaWxkcmVuOiB3YXJuaW5nXG4gICAgfSk7XG4gIH0sXG4gIERlZmF1bHRVbmtub3duTWFyayA9ICh7XG4gICAgbWFya1R5cGUsXG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgdW5rbm93bl9fcHRfX21hcmtfXyR7bWFya1R5cGV9YCxcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJwXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25MaXN0ID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duTGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdEhhcmRCcmVhayA9ICgpID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJyXCIsIHt9KSxcbiAgZGVmYXVsdEJsb2NrU3R5bGVzID0ge1xuICAgIG5vcm1hbDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGJsb2NrcXVvdGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJsb2NrcXVvdGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDFcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDJcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDNcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDRcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDZcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9LFxuICBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgICB0eXBlczoge30sXG4gICAgYmxvY2s6IGRlZmF1bHRCbG9ja1N0eWxlcyxcbiAgICBtYXJrczogZGVmYXVsdE1hcmtzLFxuICAgIGxpc3Q6IGRlZmF1bHRMaXN0cyxcbiAgICBsaXN0SXRlbTogRGVmYXVsdExpc3RJdGVtLFxuICAgIGhhcmRCcmVhazogRGVmYXVsdEhhcmRCcmVhayxcbiAgICB1bmtub3duVHlwZTogRGVmYXVsdFVua25vd25UeXBlLFxuICAgIHVua25vd25NYXJrOiBEZWZhdWx0VW5rbm93bk1hcmssXG4gICAgdW5rbm93bkxpc3Q6IERlZmF1bHRVbmtub3duTGlzdCxcbiAgICB1bmtub3duTGlzdEl0ZW06IERlZmF1bHRVbmtub3duTGlzdEl0ZW0sXG4gICAgdW5rbm93bkJsb2NrU3R5bGU6IERlZmF1bHRVbmtub3duQmxvY2tTdHlsZVxuICB9O1xuZnVuY3Rpb24gbWVyZ2VDb21wb25lbnRzKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gIGNvbnN0IHtcbiAgICAgIGJsb2NrLFxuICAgICAgbGlzdCxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbWFya3MsXG4gICAgICB0eXBlc1xuICAgIH0gPSBvdmVycmlkZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdmVycmlkZXMsIF9leGNsdWRlZCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudCksIHt9LCB7XG4gICAgYmxvY2s6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImJsb2NrXCIpLFxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXG4gICAgbGlzdEl0ZW06IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RJdGVtXCIpLFxuICAgIG1hcmtzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJtYXJrc1wiKSxcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIilcbiAgfSwgcmVzdCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gb3ZlcnJpZGVzW2tleV0sXG4gICAgcGFyZW50VmFsID0gcGFyZW50W2tleV07XG4gIHJldHVybiB0eXBlb2Ygb3ZlcnJpZGUgPT0gXCJmdW5jdGlvblwiIHx8IG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT0gXCJmdW5jdGlvblwiID8gb3ZlcnJpZGUgOiBvdmVycmlkZSA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50VmFsKSwgb3ZlcnJpZGUpIDogcGFyZW50VmFsO1xufVxuZnVuY3Rpb24gUG9ydGFibGVUZXh0KHtcbiAgdmFsdWU6IGlucHV0LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRPdmVycmlkZXMsXG4gIGxpc3ROZXN0aW5nTW9kZSxcbiAgb25NaXNzaW5nQ29tcG9uZW50OiBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciA9IHByaW50V2FybmluZ1xufSkge1xuICBjb25zdCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50ID0gbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgfHwgbm9vcCxcbiAgICBibG9ja3MgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XSxcbiAgICBuZXN0ZWQgPSBuZXN0TGlzdHMoYmxvY2tzLCBsaXN0TmVzdGluZ01vZGUgfHwgTElTVF9ORVNUX01PREVfSFRNTCksXG4gICAgY29tcG9uZW50cyA9IHVzZU1lbW8oKCkgPT4gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHMsIFtjb21wb25lbnRPdmVycmlkZXNdKSxcbiAgICByZW5kZXJOb2RlID0gdXNlTWVtbygoKSA9PiBnZXROb2RlUmVuZGVyZXIoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCksIFtjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50XSksXG4gICAgcmVuZGVyZWQgPSBuZXN0ZWQubWFwKChub2RlLCBpbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IHJlbmRlcmVkXG4gIH0pO1xufVxuY29uc3QgZ2V0Tm9kZVJlbmRlcmVyID0gKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpID0+IHtcbiAgZnVuY3Rpb24gcmVuZGVyTm9kZShvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmVcbiAgICAgIH0gPSBvcHRpb25zLFxuICAgICAga2V5ID0gbm9kZS5fa2V5IHx8IGBub2RlLSR7aW5kZXh9YDtcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChub2RlKSA/IHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2sobm9kZSkgPyByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4obm9kZSkgPyByZW5kZXJTcGFuKG5vZGUsIGluZGV4LCBrZXkpIDogaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSA/IHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkgPyByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSA/IHJlbmRlclRleHQobm9kZSwga2V5KSA6IHJlbmRlclVua25vd25UeXBlKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fdHlwZSBpbiBjb21wb25lbnRzLnR5cGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCB0cmVlID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHJlbmRlcmVyID0gY29tcG9uZW50cy5saXN0SXRlbSxcbiAgICAgIExpID0gKHR5cGVvZiByZW5kZXJlciA9PSBcImZ1bmN0aW9uXCIgPyByZW5kZXJlciA6IHJlbmRlcmVyW25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbTtcbiAgICBpZiAoTGkgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICB0eXBlOiBzdHlsZSxcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdEl0ZW1TdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgICAgbGlzdEl0ZW1cbiAgICAgICAgfSA9IG5vZGUsXG4gICAgICAgIGJsb2NrTm9kZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGJsb2NrTm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGksIHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQuX2tleSA/IGNoaWxkIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICAgICAgX2tleTogYGxpLSR7aW5kZXh9LSR7Y2hpbGRJbmRleH1gXG4gICAgICAgIH0pLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSksXG4gICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3QsXG4gICAgICBMaXN0ID0gKHR5cGVvZiBjb21wb25lbnQgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50IDogY29tcG9uZW50W25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0O1xuICAgIGlmIChMaXN0ID09PSBjb21wb25lbnRzLnVua25vd25MaXN0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RTdHlsZVwiLFxuICAgICAgICB0eXBlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGlzdCwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyU3Bhbihub2RlLCBfaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFya0RlZixcbiAgICAgICAgbWFya1R5cGUsXG4gICAgICAgIG1hcmtLZXlcbiAgICAgIH0gPSBub2RlLFxuICAgICAgU3BhbiA9IGNvbXBvbmVudHMubWFya3NbbWFya1R5cGVdIHx8IGNvbXBvbmVudHMudW5rbm93bk1hcmssXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICEwLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIFNwYW4gPT09IGNvbXBvbmVudHMudW5rbm93bk1hcmsgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTWFya1dhcm5pbmcobWFya1R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJtYXJrXCIsXG4gICAgICB0eXBlOiBtYXJrVHlwZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goU3Bhbiwge1xuICAgICAgdGV4dDogc3BhblRvUGxhaW5UZXh0KG5vZGUpLFxuICAgICAgdmFsdWU6IG1hcmtEZWYsXG4gICAgICBtYXJrVHlwZSxcbiAgICAgIG1hcmtLZXksXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3QgX3NlcmlhbGl6ZUJsb2NrID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBfa2V5XG4gICAgICB9ID0gX3NlcmlhbGl6ZUJsb2NrLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3NlcmlhbGl6ZUJsb2NrLCBfZXhjbHVkZWQzKSxcbiAgICAgIHN0eWxlID0gcHJvcHMubm9kZS5zdHlsZSB8fCBcIm5vcm1hbFwiLFxuICAgICAgQmxvY2sgPSAodHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50cy5ibG9jayA6IGNvbXBvbmVudHMuYmxvY2tbc3R5bGVdKSB8fCBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlO1xuICAgIHJldHVybiBCbG9jayA9PT0gY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZSAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25CbG9ja1N0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrU3R5bGVcIixcbiAgICAgIHR5cGU6IHN0eWxlXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChCbG9jaywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICB2YWx1ZTogcHJvcHMubm9kZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJUZXh0KG5vZGUsIGtleSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IGBcbmApIHtcbiAgICAgIGNvbnN0IEhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIEhhcmRCcmVhayA/IC8qIEBfX1BVUkVfXyAqL2pzeChIYXJkQnJlYWssIHt9LCBrZXkpIDogYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH07XG4gICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duVHlwZVdhcm5pbmcobm9kZS5fdHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrXCIsXG4gICAgICB0eXBlOiBub2RlLl90eXBlXG4gICAgfSk7XG4gICAgY29uc3QgVW5rbm93blR5cGUgPSBjb21wb25lbnRzLnVua25vd25UeXBlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goVW5rbm93blR5cGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgICB2YWx1ZTogbm9kZSxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9LFxuICAgICAgTm9kZSA9IGNvbXBvbmVudHMudHlwZXNbbm9kZS5fdHlwZV07XG4gICAgcmV0dXJuIE5vZGUgPyAvKiBAX19QVVJFX18gKi9qc3goTm9kZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyTm9kZTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVCbG9jayhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0gPSBvcHRpb25zLFxuICAgIGNoaWxkcmVuID0gYnVpbGRNYXJrc1RyZWUobm9kZSkubWFwKChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBfa2V5OiBub2RlLl9rZXkgfHwgYGJsb2NrLSR7aW5kZXh9YCxcbiAgICBjaGlsZHJlbixcbiAgICBpbmRleCxcbiAgICBpc0lubGluZSxcbiAgICBub2RlXG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCB7IFBvcnRhYmxlVGV4dCwgZGVmYXVsdENvbXBvbmVudHMsIG1lcmdlQ29tcG9uZW50cywgdG9QbGFpblRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/to-html/dist/pt-to-html.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@portabletext/to-html/dist/pt-to-html.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   escapeHTML: () => (/* binding */ escapeHTML),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toHTML: () => (/* binding */ toHTML),\n/* harmony export */   uriLooksSafe: () => (/* binding */ uriLooksSafe)\n/* harmony export */ });\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => `<ol>${children}</ol>`,\n    bullet: ({\n      children\n    }) => `<ul>${children}</ul>`\n  },\n  DefaultListItem = ({\n    children\n  }) => `<li>${children}</li>`,\n  allowedProtocols = [\"http\", \"https\", \"mailto\", \"tel\"],\n  charMap = {\n    \"&\": \"amp\",\n    \"<\": \"lt\",\n    \">\": \"gt\",\n    '\"': \"quot\",\n    \"'\": \"#x27\"\n  };\nfunction escapeHTML(str) {\n  return str.replace(/[&<>\"']/g, s => `&${charMap[s]};`);\n}\nfunction uriLooksSafe(uri) {\n  const url = (uri || \"\").trim(),\n    first = url.charAt(0);\n  if (first === \"#\" || first === \"/\") return !0;\n  const colonIndex = url.indexOf(\":\");\n  if (colonIndex === -1) return !0;\n  const proto = url.slice(0, colonIndex).toLowerCase();\n  if (allowedProtocols.indexOf(proto) !== -1) return !0;\n  const queryIndex = url.indexOf(\"?\");\n  if (queryIndex !== -1 && colonIndex > queryIndex) return !0;\n  const hashIndex = url.indexOf(\"#\");\n  return hashIndex !== -1 && colonIndex > hashIndex;\n}\nconst link = ({\n    children,\n    value\n  }) => {\n    const href = (value == null ? void 0 : value.href) || \"\";\n    return uriLooksSafe(href) ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children;\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => `<em>${children}</em>`,\n    strong: ({\n      children\n    }) => `<strong>${children}</strong>`,\n    code: ({\n      children\n    }) => `<code>${children}</code>`,\n    underline: ({\n      children\n    }) => `<span style=\"text-decoration:underline\">${children}</span>`,\n    \"strike-through\": ({\n      children\n    }) => `<del>${children}</del>`,\n    link\n  },\n  getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? `<span style=\"display:none\">${warning}</span>` : `<div style=\"display:none\">${warning}</div>`;\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`,\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => `<p>${children}</p>`,\n  DefaultUnknownList = ({\n    children\n  }) => `<ul>${children}</ul>`,\n  DefaultUnknownListItem = ({\n    children\n  }) => `<li>${children}</li>`,\n  DefaultHardBreak = () => \"<br/>\",\n  defaultPortableTextBlockStyles = {\n    normal: ({\n      children\n    }) => `<p>${children}</p>`,\n    blockquote: ({\n      children\n    }) => `<blockquote>${children}</blockquote>`,\n    h1: ({\n      children\n    }) => `<h1>${children}</h1>`,\n    h2: ({\n      children\n    }) => `<h2>${children}</h2>`,\n    h3: ({\n      children\n    }) => `<h3>${children}</h3>`,\n    h4: ({\n      children\n    }) => `<h4>${children}</h4>`,\n    h5: ({\n      children\n    }) => `<h5>${children}</h5>`,\n    h6: ({\n      children\n    }) => `<h6>${children}</h6>`\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultPortableTextBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction toHTML(value, options = {}) {\n  const {\n      components: componentOverrides,\n      onMissingComponent: missingComponentHandler = printWarning\n    } = options,\n    handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(value) ? value : [value],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.nestLists)(blocks, \"html\"),\n    components = componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents,\n    renderNode = getNodeRenderer(components, handleMissingComponent);\n  return nested.map((node, index) => renderNode({\n    node,\n    index,\n    isInline: !1,\n    renderNode\n  })).join(\"\");\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n      node,\n      index,\n      isInline\n    } = options;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitList)(node) ? renderList(node, index) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListItemBlock)(node) ? renderListItem(node, index) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitSpan)(node) ? renderSpan(node) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextBlock)(node) ? renderBlock(node, index, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitTextNode)(node) ? renderText(node) : renderCustomBlock(node, index, isInline);\n  }\n  function renderListItem(node, index) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      itemHandler = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return itemHandler({\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    });\n  }\n  function renderList(node, index) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      list = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (list === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return list({\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children: children.join(\"\")\n    });\n  }\n  function renderSpan(node) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), span({\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(\"\")\n    });\n  }\n  function renderBlock(node, index, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), block(_objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }));\n  }\n  function renderText(node) {\n    if (node.text === `\n`) {\n      const hardBreak = components.hardBreak;\n      return hardBreak ? hardBreak() : `\n`;\n    }\n    return escapeHTML(node.text);\n  }\n  function renderCustomBlock(value, index, isInline) {\n    const node = components.types[value._type];\n    return node || handleMissingComponent(unknownTypeWarning(value._type), {\n      nodeType: \"block\",\n      type: value._type\n    }), (node || components.unknownType)({\n      value,\n      isInline,\n      index,\n      renderNode\n    });\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(\"\"),\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=pt-to-html.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90by1odG1sL2Rpc3QvcHQtdG8taHRtbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDBDQUEwQywrQkFBK0Isb0JBQW9CLG1DQUFtQyxvQ0FBb0MsdUVBQXVFO0FBQ3pRLDBDQUEwQywwQkFBMEIsbURBQW1ELG9DQUFvQyx5Q0FBeUMsWUFBWSxjQUFjLHNDQUFzQyxxREFBcUQ7QUFDelQsK0NBQStDLDBCQUEwQixZQUFZLHVCQUF1Qiw4QkFBOEIsaUNBQWlDLGVBQWU7QUFDZ0M7QUFDMU47QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEtBQUssWUFBWSxTQUFTO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxZQUFZLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QyxpQkFBaUIsSUFBSSxTQUFTO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVksU0FBUztBQUMxQjtBQUNBO0FBQ0EsS0FBSyxnQkFBZ0IsU0FBUztBQUM5QjtBQUNBO0FBQ0EsS0FBSyxjQUFjLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEtB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUscUVBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRjtBQUNoRiIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3RvLWh0bWwvZGlzdC9wdC10by1odG1sLm1qcz8zZGFhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF9leGNsdWRlZCA9IFtcImJsb2NrXCIsIFwibGlzdFwiLCBcImxpc3RJdGVtXCIsIFwibWFya3NcIiwgXCJ0eXBlc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImxpc3RJdGVtXCJdLFxuICBfZXhjbHVkZWQzID0gW1wiX2tleVwiXTtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9OyB2YXIgbywgciwgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgdC5pbmRleE9mKG8pID49IDAgfHwge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pOyB9IHJldHVybiBpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7IGlmIChudWxsID09IHIpIHJldHVybiB7fTsgdmFyIHQgPSB7fTsgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkgeyBpZiAoZS5pbmRleE9mKG4pID49IDApIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuaW1wb3J0IHsgbmVzdExpc3RzLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBzcGFuVG9QbGFpblRleHQsIGJ1aWxkTWFya3NUcmVlIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuY29uc3QgZGVmYXVsdExpc3RzID0ge1xuICAgIG51bWJlcjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxvbD4ke2NoaWxkcmVufTwvb2w+YCxcbiAgICBidWxsZXQ6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IGA8dWw+JHtjaGlsZHJlbn08L3VsPmBcbiAgfSxcbiAgRGVmYXVsdExpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiBgPGxpPiR7Y2hpbGRyZW59PC9saT5gLFxuICBhbGxvd2VkUHJvdG9jb2xzID0gW1wiaHR0cFwiLCBcImh0dHBzXCIsIFwibWFpbHRvXCIsIFwidGVsXCJdLFxuICBjaGFyTWFwID0ge1xuICAgIFwiJlwiOiBcImFtcFwiLFxuICAgIFwiPFwiOiBcImx0XCIsXG4gICAgXCI+XCI6IFwiZ3RcIixcbiAgICAnXCInOiBcInF1b3RcIixcbiAgICBcIidcIjogXCIjeDI3XCJcbiAgfTtcbmZ1bmN0aW9uIGVzY2FwZUhUTUwoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWyY8PlwiJ10vZywgcyA9PiBgJiR7Y2hhck1hcFtzXX07YCk7XG59XG5mdW5jdGlvbiB1cmlMb29rc1NhZmUodXJpKSB7XG4gIGNvbnN0IHVybCA9ICh1cmkgfHwgXCJcIikudHJpbSgpLFxuICAgIGZpcnN0ID0gdXJsLmNoYXJBdCgwKTtcbiAgaWYgKGZpcnN0ID09PSBcIiNcIiB8fCBmaXJzdCA9PT0gXCIvXCIpIHJldHVybiAhMDtcbiAgY29uc3QgY29sb25JbmRleCA9IHVybC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSByZXR1cm4gITA7XG4gIGNvbnN0IHByb3RvID0gdXJsLnNsaWNlKDAsIGNvbG9uSW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChhbGxvd2VkUHJvdG9jb2xzLmluZGV4T2YocHJvdG8pICE9PSAtMSkgcmV0dXJuICEwO1xuICBjb25zdCBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xuICBpZiAocXVlcnlJbmRleCAhPT0gLTEgJiYgY29sb25JbmRleCA+IHF1ZXJ5SW5kZXgpIHJldHVybiAhMDtcbiAgY29uc3QgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICByZXR1cm4gaGFzaEluZGV4ICE9PSAtMSAmJiBjb2xvbkluZGV4ID4gaGFzaEluZGV4O1xufVxuY29uc3QgbGluayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgdmFsdWVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSAodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmhyZWYpIHx8IFwiXCI7XG4gICAgcmV0dXJuIHVyaUxvb2tzU2FmZShocmVmKSA/IGA8YSBocmVmPVwiJHtlc2NhcGVIVE1MKGhyZWYpfVwiPiR7Y2hpbGRyZW59PC9hPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgZGVmYXVsdE1hcmtzID0ge1xuICAgIGVtOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGVtPiR7Y2hpbGRyZW59PC9lbT5gLFxuICAgIHN0cm9uZzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gLFxuICAgIGNvZGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IGA8Y29kZT4ke2NoaWxkcmVufTwvY29kZT5gLFxuICAgIHVuZGVybGluZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxzcGFuIHN0eWxlPVwidGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZVwiPiR7Y2hpbGRyZW59PC9zcGFuPmAsXG4gICAgXCJzdHJpa2UtdGhyb3VnaFwiOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGRlbD4ke2NoaWxkcmVufTwvZGVsPmAsXG4gICAgbGlua1xuICB9LFxuICBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBgVW5rbm93biAke3R5cGV9LCBzcGVjaWZ5IGEgY29tcG9uZW50IGZvciBpdCBpbiB0aGUgXFxgY29tcG9uZW50cy4ke3Byb3B9XFxgIG9wdGlvbmAsXG4gIHVua25vd25UeXBlV2FybmluZyA9IHR5cGVOYW1lID0+IGdldFRlbXBsYXRlKGBibG9jayB0eXBlIFwiJHt0eXBlTmFtZX1cImAsIFwidHlwZXNcIiksXG4gIHVua25vd25NYXJrV2FybmluZyA9IG1hcmtUeXBlID0+IGdldFRlbXBsYXRlKGBtYXJrIHR5cGUgXCIke21hcmtUeXBlfVwiYCwgXCJtYXJrc1wiKSxcbiAgdW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nID0gYmxvY2tTdHlsZSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgc3R5bGUgXCIke2Jsb2NrU3R5bGV9XCJgLCBcImJsb2NrXCIpLFxuICB1bmtub3duTGlzdFN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0XCIpLFxuICB1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGxpc3QgaXRlbSBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0SXRlbVwiKTtcbmZ1bmN0aW9uIHByaW50V2FybmluZyhtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmNvbnN0IERlZmF1bHRVbmtub3duVHlwZSA9ICh7XG4gICAgdmFsdWUsXG4gICAgaXNJbmxpbmVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHdhcm5pbmcgPSB1bmtub3duVHlwZVdhcm5pbmcodmFsdWUuX3R5cGUpO1xuICAgIHJldHVybiBpc0lubGluZSA/IGA8c3BhbiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPiR7d2FybmluZ308L3NwYW4+YCA6IGA8ZGl2IHN0eWxlPVwiZGlzcGxheTpub25lXCI+JHt3YXJuaW5nfTwvZGl2PmA7XG4gIH0sXG4gIERlZmF1bHRVbmtub3duTWFyayA9ICh7XG4gICAgbWFya1R5cGUsXG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gYDxzcGFuIGNsYXNzPVwidW5rbm93bl9fcHRfX21hcmtfXyR7bWFya1R5cGV9XCI+JHtjaGlsZHJlbn08L3NwYW4+YCxcbiAgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiBgPHA+JHtjaGlsZHJlbn08L3A+YCxcbiAgRGVmYXVsdFVua25vd25MaXN0ID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiBgPHVsPiR7Y2hpbGRyZW59PC91bD5gLFxuICBEZWZhdWx0VW5rbm93bkxpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiBgPGxpPiR7Y2hpbGRyZW59PC9saT5gLFxuICBEZWZhdWx0SGFyZEJyZWFrID0gKCkgPT4gXCI8YnIvPlwiLFxuICBkZWZhdWx0UG9ydGFibGVUZXh0QmxvY2tTdHlsZXMgPSB7XG4gICAgbm9ybWFsOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPHA+JHtjaGlsZHJlbn08L3A+YCxcbiAgICBibG9ja3F1b3RlOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiBgPGJsb2NrcXVvdGU+JHtjaGlsZHJlbn08L2Jsb2NrcXVvdGU+YCxcbiAgICBoMTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxoMT4ke2NoaWxkcmVufTwvaDE+YCxcbiAgICBoMjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxoMj4ke2NoaWxkcmVufTwvaDI+YCxcbiAgICBoMzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxoMz4ke2NoaWxkcmVufTwvaDM+YCxcbiAgICBoNDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxoND4ke2NoaWxkcmVufTwvaDQ+YCxcbiAgICBoNTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxoNT4ke2NoaWxkcmVufTwvaDU+YCxcbiAgICBoNjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gYDxoNj4ke2NoaWxkcmVufTwvaDY+YFxuICB9LFxuICBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgICB0eXBlczoge30sXG4gICAgYmxvY2s6IGRlZmF1bHRQb3J0YWJsZVRleHRCbG9ja1N0eWxlcyxcbiAgICBtYXJrczogZGVmYXVsdE1hcmtzLFxuICAgIGxpc3Q6IGRlZmF1bHRMaXN0cyxcbiAgICBsaXN0SXRlbTogRGVmYXVsdExpc3RJdGVtLFxuICAgIGhhcmRCcmVhazogRGVmYXVsdEhhcmRCcmVhayxcbiAgICB1bmtub3duVHlwZTogRGVmYXVsdFVua25vd25UeXBlLFxuICAgIHVua25vd25NYXJrOiBEZWZhdWx0VW5rbm93bk1hcmssXG4gICAgdW5rbm93bkxpc3Q6IERlZmF1bHRVbmtub3duTGlzdCxcbiAgICB1bmtub3duTGlzdEl0ZW06IERlZmF1bHRVbmtub3duTGlzdEl0ZW0sXG4gICAgdW5rbm93bkJsb2NrU3R5bGU6IERlZmF1bHRVbmtub3duQmxvY2tTdHlsZVxuICB9O1xuZnVuY3Rpb24gbWVyZ2VDb21wb25lbnRzKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gIGNvbnN0IHtcbiAgICAgIGJsb2NrLFxuICAgICAgbGlzdCxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbWFya3MsXG4gICAgICB0eXBlc1xuICAgIH0gPSBvdmVycmlkZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdmVycmlkZXMsIF9leGNsdWRlZCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudCksIHt9LCB7XG4gICAgYmxvY2s6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImJsb2NrXCIpLFxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXG4gICAgbGlzdEl0ZW06IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RJdGVtXCIpLFxuICAgIG1hcmtzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJtYXJrc1wiKSxcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIilcbiAgfSwgcmVzdCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gb3ZlcnJpZGVzW2tleV0sXG4gICAgcGFyZW50VmFsID0gcGFyZW50W2tleV07XG4gIHJldHVybiB0eXBlb2Ygb3ZlcnJpZGUgPT0gXCJmdW5jdGlvblwiIHx8IG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT0gXCJmdW5jdGlvblwiID8gb3ZlcnJpZGUgOiBvdmVycmlkZSA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50VmFsKSwgb3ZlcnJpZGUpIDogcGFyZW50VmFsO1xufVxuZnVuY3Rpb24gdG9IVE1MKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgICAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxuICAgICAgb25NaXNzaW5nQ29tcG9uZW50OiBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciA9IHByaW50V2FybmluZ1xuICAgIH0gPSBvcHRpb25zLFxuICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQgPSBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciB8fCBub29wLFxuICAgIGJsb2NrcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdLFxuICAgIG5lc3RlZCA9IG5lc3RMaXN0cyhibG9ja3MsIFwiaHRtbFwiKSxcbiAgICBjb21wb25lbnRzID0gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHMsXG4gICAgcmVuZGVyTm9kZSA9IGdldE5vZGVSZW5kZXJlcihjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KTtcbiAgcmV0dXJuIG5lc3RlZC5tYXAoKG5vZGUsIGluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICBub2RlLFxuICAgIGluZGV4LFxuICAgIGlzSW5saW5lOiAhMSxcbiAgICByZW5kZXJOb2RlXG4gIH0pKS5qb2luKFwiXCIpO1xufVxuY29uc3QgZ2V0Tm9kZVJlbmRlcmVyID0gKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpID0+IHtcbiAgZnVuY3Rpb24gcmVuZGVyTm9kZShvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmVcbiAgICB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChub2RlKSA/IHJlbmRlckxpc3Qobm9kZSwgaW5kZXgpIDogaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKG5vZGUpID8gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0U3Bhbihub2RlKSA/IHJlbmRlclNwYW4obm9kZSkgOiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpID8gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpID8gcmVuZGVyVGV4dChub2RlKSA6IHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBpc0lubGluZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgpIHtcbiAgICBjb25zdCB0cmVlID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHJlbmRlcmVyID0gY29tcG9uZW50cy5saXN0SXRlbSxcbiAgICAgIGl0ZW1IYW5kbGVyID0gKHR5cGVvZiByZW5kZXJlciA9PSBcImZ1bmN0aW9uXCIgPyByZW5kZXJlciA6IHJlbmRlcmVyW25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbTtcbiAgICBpZiAoaXRlbUhhbmRsZXIgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICB0eXBlOiBzdHlsZSxcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdEl0ZW1TdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgICAgbGlzdEl0ZW1cbiAgICAgICAgfSA9IG5vZGUsXG4gICAgICAgIGJsb2NrTm9kZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGJsb2NrTm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtSGFuZGxlcih7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdChub2RlLCBpbmRleCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQuX2tleSA/IGNoaWxkIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICAgICAgX2tleTogYGxpLSR7aW5kZXh9LSR7Y2hpbGRJbmRleH1gXG4gICAgICAgIH0pLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSksXG4gICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3QsXG4gICAgICBsaXN0ID0gKHR5cGVvZiBjb21wb25lbnQgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50IDogY29tcG9uZW50W25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0O1xuICAgIGlmIChsaXN0ID09PSBjb21wb25lbnRzLnVua25vd25MaXN0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RTdHlsZVwiLFxuICAgICAgICB0eXBlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0KHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLmpvaW4oXCJcIilcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJTcGFuKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIG1hcmtEZWYsXG4gICAgICAgIG1hcmtUeXBlLFxuICAgICAgICBtYXJrS2V5XG4gICAgICB9ID0gbm9kZSxcbiAgICAgIHNwYW4gPSBjb21wb25lbnRzLm1hcmtzW21hcmtUeXBlXSB8fCBjb21wb25lbnRzLnVua25vd25NYXJrLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpO1xuICAgIHJldHVybiBzcGFuID09PSBjb21wb25lbnRzLnVua25vd25NYXJrICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bk1hcmtXYXJuaW5nKG1hcmtUeXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwibWFya1wiLFxuICAgICAgdHlwZTogbWFya1R5cGVcbiAgICB9KSwgc3Bhbih7XG4gICAgICB0ZXh0OiBzcGFuVG9QbGFpblRleHQobm9kZSksXG4gICAgICB2YWx1ZTogbWFya0RlZixcbiAgICAgIG1hcmtUeXBlLFxuICAgICAgbWFya0tleSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4uam9pbihcIlwiKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBpc0lubGluZSkge1xuICAgIGNvbnN0IF9zZXJpYWxpemVCbG9jayA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgX2tleVxuICAgICAgfSA9IF9zZXJpYWxpemVCbG9jayxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9zZXJpYWxpemVCbG9jaywgX2V4Y2x1ZGVkMyksXG4gICAgICBzdHlsZSA9IHByb3BzLm5vZGUuc3R5bGUgfHwgXCJub3JtYWxcIixcbiAgICAgIGJsb2NrID0gKHR5cGVvZiBjb21wb25lbnRzLmJsb2NrID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXSkgfHwgY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZTtcbiAgICByZXR1cm4gYmxvY2sgPT09IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGUgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1N0eWxlXCIsXG4gICAgICB0eXBlOiBzdHlsZVxuICAgIH0pLCBibG9jayhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgIHZhbHVlOiBwcm9wcy5ub2RlLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJUZXh0KG5vZGUpIHtcbiAgICBpZiAobm9kZS50ZXh0ID09PSBgXG5gKSB7XG4gICAgICBjb25zdCBoYXJkQnJlYWsgPSBjb21wb25lbnRzLmhhcmRCcmVhaztcbiAgICAgIHJldHVybiBoYXJkQnJlYWsgPyBoYXJkQnJlYWsoKSA6IGBcbmA7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVIVE1MKG5vZGUudGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQ3VzdG9tQmxvY2sodmFsdWUsIGluZGV4LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb25lbnRzLnR5cGVzW3ZhbHVlLl90eXBlXTtcbiAgICByZXR1cm4gbm9kZSB8fCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25UeXBlV2FybmluZyh2YWx1ZS5fdHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrXCIsXG4gICAgICB0eXBlOiB2YWx1ZS5fdHlwZVxuICAgIH0pLCAobm9kZSB8fCBjb21wb25lbnRzLnVua25vd25UeXBlKSh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgaW5kZXgsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlck5vZGU7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplQmxvY2sob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9ID0gb3B0aW9ucyxcbiAgICBjaGlsZHJlbiA9IGJ1aWxkTWFya3NUcmVlKG5vZGUpLm1hcCgoY2hpbGQsIGkpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBpc0lubGluZTogITAsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSk7XG4gIHJldHVybiB7XG4gICAgX2tleTogbm9kZS5fa2V5IHx8IGBibG9jay0ke2luZGV4fWAsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLmpvaW4oXCJcIiksXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5leHBvcnQgeyBkZWZhdWx0Q29tcG9uZW50cywgZXNjYXBlSFRNTCwgbWVyZ2VDb21wb25lbnRzLCB0b0hUTUwsIHVyaUxvb2tzU2FmZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHQtdG8taHRtbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/to-html/dist/pt-to-html.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a, _b;\n  const {\n      children\n    } = block,\n    markDefs = (_a = block.markDefs) != null ? _a : [];\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs == null ? void 0 : markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4QiwwQ0FBMEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsb0NBQW9DLHVFQUF1RTtBQUN6UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQSwySUFBMkk7QUFDM0k7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CO0FBQzVFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLE1BQU0sRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDaVM7QUFDalMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYW50ZWMvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanM/NDBjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPiBcInVcIiB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MuZXZlcnkobWFyayA9PiB0eXBlb2YgbWFyayA9PSBcInN0cmluZ1wiKSk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBBIGJsb2NrIGRvZXNuJ3QgX2hhdmVfIHRvIGJlIG5hbWVkICdibG9jaycgLSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAvLyBhbGxvd2VkIGNoaWxkIHR5cGVzIGFuZCBtYXJrcywgb25lIG1pZ2h0IG5hbWUgdGhlbSBkaWZmZXJlbnRseVxuICAgIHR5cGVvZiBub2RlLl90eXBlID09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBUb29sa2l0LXR5cGVzIGxpa2UgbmVzdGVkIHNwYW5zIGFyZSBALXByZWZpeGVkXG4gICAgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgKFxuICAgIC8vIGBtYXJrRGVmc2AgaXNuJ3QgX3JlcXVpcmVkXyBwZXIgc2F5LCBidXQgaWYgaXQncyB0aGVyZSwgaXQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICAhKFwibWFya0RlZnNcIiBpbiBub2RlKSB8fCAhbm9kZS5tYXJrRGVmcyB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpICYmXG4gICAgLy8gRXZlcnkgbWFyayBkZWZpbml0aW9uIG5lZWRzIHRvIGhhdmUgYW4gYF9rZXlgIHRvIGJlIG1hcHBhYmxlIGluIGNoaWxkIHNwYW5zXG4gICAgbm9kZS5tYXJrRGVmcy5ldmVyeShkZWYgPT4gdHlwZW9mIGRlZi5fa2V5ID09IFwic3RyaW5nXCIpKSAmJlxuICAgIC8vIGBjaGlsZHJlbmAgaXMgcmVxdWlyZWQgYW5kIG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSAmJlxuICAgIC8vIEFsbCBjaGlsZHJlbiBhcmUgb2JqZWN0cyB3aXRoIGBfdHlwZWAgKHVzdWFsbHkgc3BhbnMsIGJ1dCBjYW4gY29udGFpbiBvdGhlciBzdHVmZilcbiAgICBub2RlLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIFwiX3R5cGVcIiBpbiBjaGlsZClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykge1xuICByZXR1cm4gaXNQb3J0YWJsZVRleHRCbG9jayhibG9jaykgJiYgXCJsaXN0SXRlbVwiIGluIGJsb2NrICYmIHR5cGVvZiBibG9jay5saXN0SXRlbSA9PSBcInN0cmluZ1wiICYmICh0eXBlb2YgYmxvY2subGV2ZWwgPiBcInVcIiB8fCB0eXBlb2YgYmxvY2subGV2ZWwgPT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KGJsb2NrKSB7XG4gIHJldHVybiBibG9jay5fdHlwZSA9PT0gXCJAbGlzdFwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihzcGFuKSB7XG4gIHJldHVybiBzcGFuLl90eXBlID09PSBcIkBzcGFuXCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcIkB0ZXh0XCI7XG59XG5jb25zdCBrbm93bkRlY29yYXRvcnMgPSBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcImNvZGVcIiwgXCJ1bmRlcmxpbmVcIiwgXCJzdHJpa2UtdGhyb3VnaFwiXTtcbmZ1bmN0aW9uIHNvcnRNYXJrc0J5T2NjdXJlbmNlcyhzcGFuLCBpbmRleCwgYmxvY2tDaGlsZHJlbikge1xuICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSB8fCAhc3Bhbi5tYXJrcykgcmV0dXJuIFtdO1xuICBpZiAoIXNwYW4ubWFya3MubGVuZ3RoKSByZXR1cm4gW107XG4gIGNvbnN0IG1hcmtzID0gc3Bhbi5tYXJrcy5zbGljZSgpLFxuICAgIG9jY3VyZW5jZXMgPSB7fTtcbiAgcmV0dXJuIG1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgb2NjdXJlbmNlc1ttYXJrXSA9IDE7XG4gICAgZm9yIChsZXQgc2libGluZ0luZGV4ID0gaW5kZXggKyAxOyBzaWJsaW5nSW5kZXggPCBibG9ja0NoaWxkcmVuLmxlbmd0aDsgc2libGluZ0luZGV4KyspIHtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBibG9ja0NoaWxkcmVuW3NpYmxpbmdJbmRleF07XG4gICAgICBpZiAoc2libGluZyAmJiBpc1BvcnRhYmxlVGV4dFNwYW4oc2libGluZykgJiYgQXJyYXkuaXNBcnJheShzaWJsaW5nLm1hcmtzKSAmJiBzaWJsaW5nLm1hcmtzLmluZGV4T2YobWFyaykgIT09IC0xKSBvY2N1cmVuY2VzW21hcmtdKys7ZWxzZSBicmVhaztcbiAgICB9XG4gIH0pLCBtYXJrcy5zb3J0KChtYXJrQSwgbWFya0IpID0+IHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpIHtcbiAgY29uc3QgYU9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtBXSxcbiAgICBiT2NjdXJlbmNlcyA9IG9jY3VyZW5jZXNbbWFya0JdO1xuICBpZiAoYU9jY3VyZW5jZXMgIT09IGJPY2N1cmVuY2VzKSByZXR1cm4gYk9jY3VyZW5jZXMgLSBhT2NjdXJlbmNlcztcbiAgY29uc3QgYUtub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0EpLFxuICAgIGJLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtCKTtcbiAgcmV0dXJuIGFLbm93blBvcyAhPT0gYktub3duUG9zID8gYUtub3duUG9zIC0gYktub3duUG9zIDogbWFya0EubG9jYWxlQ29tcGFyZShtYXJrQik7XG59XG5mdW5jdGlvbiBidWlsZE1hcmtzVHJlZShibG9jaykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBibG9jayxcbiAgICBtYXJrRGVmcyA9IChfYSA9IGJsb2NrLm1hcmtEZWZzKSAhPSBudWxsID8gX2EgOiBbXTtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gW107XG4gIGNvbnN0IHNvcnRlZE1hcmtzID0gY2hpbGRyZW4ubWFwKHNvcnRNYXJrc0J5T2NjdXJlbmNlcyksXG4gICAgcm9vdE5vZGUgPSB7XG4gICAgICBfdHlwZTogXCJAc3BhblwiLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgbWFya1R5cGU6IFwiPHVua25vd24+XCJcbiAgICB9O1xuICBsZXQgbm9kZVN0YWNrID0gW3Jvb3ROb2RlXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNwYW4gPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoIXNwYW4pIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1hcmtzTmVlZGVkID0gc29ydGVkTWFya3NbaV0gfHwgW107XG4gICAgbGV0IHBvcyA9IDE7XG4gICAgaWYgKG5vZGVTdGFjay5sZW5ndGggPiAxKSBmb3IgKHBvczsgcG9zIDwgbm9kZVN0YWNrLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgIGNvbnN0IG1hcmsgPSAoKF9iID0gbm9kZVN0YWNrW3Bvc10pID09IG51bGwgPyB2b2lkIDAgOiBfYi5tYXJrS2V5KSB8fCBcIlwiLFxuICAgICAgICBpbmRleCA9IG1hcmtzTmVlZGVkLmluZGV4T2YobWFyayk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSBicmVhaztcbiAgICAgIG1hcmtzTmVlZGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIG5vZGVTdGFjayA9IG5vZGVTdGFjay5zbGljZSgwLCBwb3MpO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVTdGFja1tub2RlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IG1hcmtLZXkgb2YgbWFya3NOZWVkZWQpIHtcbiAgICAgICAgY29uc3QgbWFya0RlZiA9IG1hcmtEZWZzID09IG51bGwgPyB2b2lkIDAgOiBtYXJrRGVmcy5maW5kKGRlZiA9PiBkZWYuX2tleSA9PT0gbWFya0tleSksXG4gICAgICAgICAgbWFya1R5cGUgPSBtYXJrRGVmID8gbWFya0RlZi5fdHlwZSA6IG1hcmtLZXksXG4gICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXksXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgICAgbWFya1R5cGUsXG4gICAgICAgICAgICBtYXJrS2V5XG4gICAgICAgICAgfTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKSwgbm9kZVN0YWNrLnB1c2gobm9kZSksIGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzcGFuLnRleHQuc3BsaXQoYFxuYCk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgPSBsaW5lcy5sZW5ndGg7IGxpbmUtLSA+IDE7KSBsaW5lcy5zcGxpY2UobGluZSwgMCwgYFxuYCk7XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KGxpbmVzLm1hcCh0ZXh0ID0+ICh7XG4gICAgICAgICAgX3R5cGU6IFwiQHRleHRcIixcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pKSk7XG4gICAgICB9IGVsc2UgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIG5lc3RMaXN0cyhibG9ja3MsIG1vZGUpIHtcbiAgY29uc3QgdHJlZSA9IFtdO1xuICBsZXQgY3VycmVudExpc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKGJsb2NrKSB7XG4gICAgICBpZiAoIWlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykpIHtcbiAgICAgICAgdHJlZS5wdXNoKGJsb2NrKSwgY3VycmVudExpc3QgPSB2b2lkIDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGlzdCkge1xuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBjdXJyZW50TGlzdCkpIHtcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA+IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgY29uc3QgbGFzdExpc3RJdGVtID0gY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBuZXdMYXN0Q2hpbGQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxhc3RMaXN0SXRlbSksIHt9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLi4ubGFzdExpc3RJdGVtLmNoaWxkcmVuLCBuZXdMaXN0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBuZXdMYXN0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKG5ld0xpc3QpO1xuICAgICAgICBjdXJyZW50TGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA8IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwgYmxvY2spO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5saXN0SXRlbSAhPT0gY3VycmVudExpc3QubGlzdEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCcmFuY2ggPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCB7XG4gICAgICAgICAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGlzdEl0ZW0gPT09IGJsb2NrLmxpc3RJdGVtKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBzdGF0ZSBlbmNvdW50ZXJlZCBmb3IgYmxvY2tcIiwgYmxvY2spLCB0cmVlLnB1c2goYmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGxpc3QpIHtcbiAgcmV0dXJuIChibG9jay5sZXZlbCB8fCAxKSA9PT0gbGlzdC5sZXZlbCAmJiBibG9jay5saXN0SXRlbSA9PT0gbGlzdC5saXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGxpc3RGcm9tQmxvY2soYmxvY2ssIGluZGV4LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgX3R5cGU6IFwiQGxpc3RcIixcbiAgICBfa2V5OiBgJHtibG9jay5fa2V5IHx8IGAke2luZGV4fWB9LXBhcmVudGAsXG4gICAgbW9kZSxcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcbiAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgY2hpbGRyZW46IFtibG9ja11cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0TWF0Y2hpbmcocm9vdE5vZGUsIG1hdGNoaW5nKSB7XG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMSxcbiAgICBzdHlsZSA9IG1hdGNoaW5nLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIsXG4gICAgZmlsdGVyT25UeXBlID0gdHlwZW9mIG1hdGNoaW5nLmxpc3RJdGVtID09IFwic3RyaW5nXCI7XG4gIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KHJvb3ROb2RlKSAmJiAocm9vdE5vZGUubGV2ZWwgfHwgMSkgPT09IGxldmVsICYmIGZpbHRlck9uVHlwZSAmJiAocm9vdE5vZGUubGlzdEl0ZW0gfHwgXCJub3JtYWxcIikgPT09IHN0eWxlKSByZXR1cm4gcm9vdE5vZGU7XG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpIHJldHVybjtcbiAgY29uc3Qgbm9kZSA9IHJvb3ROb2RlLmNoaWxkcmVuW3Jvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZSAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpID8gZmluZExpc3RNYXRjaGluZyhub2RlLCBtYXRjaGluZykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzcGFuVG9QbGFpblRleHQoc3Bhbikge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBzcGFuLmNoaWxkcmVuLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUoY3VycmVudCkgPyB0ZXh0ICs9IGN1cnJlbnQudGV4dCA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oY3VycmVudCkgJiYgKHRleHQgKz0gc3BhblRvUGxhaW5UZXh0KGN1cnJlbnQpKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBsZWFkaW5nU3BhY2UgPSAvXlxccy8sXG4gIHRyYWlsaW5nU3BhY2UgPSAvXFxzJC87XG5mdW5jdGlvbiB0b1BsYWluVGV4dChibG9jaykge1xuICBjb25zdCBibG9ja3MgPSBBcnJheS5pc0FycmF5KGJsb2NrKSA/IGJsb2NrIDogW2Jsb2NrXTtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICByZXR1cm4gYmxvY2tzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BvcnRhYmxlVGV4dEJsb2NrKGN1cnJlbnQpKSByZXR1cm47XG4gICAgbGV0IHBhZCA9ICExO1xuICAgIGN1cnJlbnQuY2hpbGRyZW4uZm9yRWFjaChzcGFuID0+IHtcbiAgICAgIGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSA/ICh0ZXh0ICs9IHBhZCAmJiB0ZXh0ICYmICF0cmFpbGluZ1NwYWNlLnRlc3QodGV4dCkgJiYgIWxlYWRpbmdTcGFjZS50ZXN0KHNwYW4udGV4dCkgPyBcIiBcIiA6IFwiXCIsIHRleHQgKz0gc3Bhbi50ZXh0LCBwYWQgPSAhMSkgOiBwYWQgPSAhMDtcbiAgICB9KSwgaW5kZXggIT09IGJsb2Nrcy5sZW5ndGggLSAxICYmICh0ZXh0ICs9IGBcblxuYCk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgTElTVF9ORVNUX01PREVfSFRNTCA9IFwiaHRtbFwiLFxuICBMSVNUX05FU1RfTU9ERV9ESVJFQ1QgPSBcImRpcmVjdFwiO1xuZXhwb3J0IHsgTElTVF9ORVNUX01PREVfRElSRUNULCBMSVNUX05FU1RfTU9ERV9IVE1MLCBidWlsZE1hcmtzVHJlZSwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBuZXN0TGlzdHMsIHNvcnRNYXJrc0J5T2NjdXJlbmNlcywgc3BhblRvUGxhaW5UZXh0LCB0b1BsYWluVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;