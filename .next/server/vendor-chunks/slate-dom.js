"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-dom";
exports.ids = ["vendor-chunks/slate-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-dom/dist/index.es.js":
/*!*************************************************!*\
  !*** ./node_modules/slate-dom/dist/index.es.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   DOMEditor: () => (/* binding */ DOMEditor),\n/* harmony export */   DOMElement: () => (/* binding */ DOMElement),\n/* harmony export */   DOMNode: () => (/* binding */ DOMNode),\n/* harmony export */   DOMRange: () => (/* binding */ DOMRange),\n/* harmony export */   DOMSelection: () => (/* binding */ DOMSelection),\n/* harmony export */   DOMStaticRange: () => (/* binding */ DOMStaticRange),\n/* harmony export */   DOMText: () => (/* binding */ DOMText),\n/* harmony export */   EDITOR_TO_ELEMENT: () => (/* binding */ EDITOR_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_FORCE_RENDER: () => (/* binding */ EDITOR_TO_FORCE_RENDER),\n/* harmony export */   EDITOR_TO_KEY_TO_ELEMENT: () => (/* binding */ EDITOR_TO_KEY_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_ON_CHANGE: () => (/* binding */ EDITOR_TO_ON_CHANGE),\n/* harmony export */   EDITOR_TO_PENDING_ACTION: () => (/* binding */ EDITOR_TO_PENDING_ACTION),\n/* harmony export */   EDITOR_TO_PENDING_DIFFS: () => (/* binding */ EDITOR_TO_PENDING_DIFFS),\n/* harmony export */   EDITOR_TO_PENDING_INSERTION_MARKS: () => (/* binding */ EDITOR_TO_PENDING_INSERTION_MARKS),\n/* harmony export */   EDITOR_TO_PENDING_SELECTION: () => (/* binding */ EDITOR_TO_PENDING_SELECTION),\n/* harmony export */   EDITOR_TO_PLACEHOLDER_ELEMENT: () => (/* binding */ EDITOR_TO_PLACEHOLDER_ELEMENT),\n/* harmony export */   EDITOR_TO_SCHEDULE_FLUSH: () => (/* binding */ EDITOR_TO_SCHEDULE_FLUSH),\n/* harmony export */   EDITOR_TO_USER_MARKS: () => (/* binding */ EDITOR_TO_USER_MARKS),\n/* harmony export */   EDITOR_TO_USER_SELECTION: () => (/* binding */ EDITOR_TO_USER_SELECTION),\n/* harmony export */   EDITOR_TO_WINDOW: () => (/* binding */ EDITOR_TO_WINDOW),\n/* harmony export */   ELEMENT_TO_NODE: () => (/* binding */ ELEMENT_TO_NODE),\n/* harmony export */   HAS_BEFORE_INPUT_SUPPORT: () => (/* binding */ HAS_BEFORE_INPUT_SUPPORT),\n/* harmony export */   Hotkeys: () => (/* binding */ hotkeys),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_COMPOSING: () => (/* binding */ IS_COMPOSING),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_FIREFOX_LEGACY: () => (/* binding */ IS_FIREFOX_LEGACY),\n/* harmony export */   IS_FOCUSED: () => (/* binding */ IS_FOCUSED),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_NODE_MAP_DIRTY: () => (/* binding */ IS_NODE_MAP_DIRTY),\n/* harmony export */   IS_READ_ONLY: () => (/* binding */ IS_READ_ONLY),\n/* harmony export */   IS_UC_MOBILE: () => (/* binding */ IS_UC_MOBILE),\n/* harmony export */   IS_WEBKIT: () => (/* binding */ IS_WEBKIT),\n/* harmony export */   IS_WECHATBROWSER: () => (/* binding */ IS_WECHATBROWSER),\n/* harmony export */   Key: () => (/* binding */ Key),\n/* harmony export */   MARK_PLACEHOLDER_SYMBOL: () => (/* binding */ MARK_PLACEHOLDER_SYMBOL),\n/* harmony export */   NODE_TO_ELEMENT: () => (/* binding */ NODE_TO_ELEMENT),\n/* harmony export */   NODE_TO_INDEX: () => (/* binding */ NODE_TO_INDEX),\n/* harmony export */   NODE_TO_KEY: () => (/* binding */ NODE_TO_KEY),\n/* harmony export */   NODE_TO_PARENT: () => (/* binding */ NODE_TO_PARENT),\n/* harmony export */   PLACEHOLDER_SYMBOL: () => (/* binding */ PLACEHOLDER_SYMBOL),\n/* harmony export */   TRIPLE_CLICK: () => (/* binding */ TRIPLE_CLICK),\n/* harmony export */   applyStringDiff: () => (/* binding */ applyStringDiff),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getDefaultView: () => (/* binding */ getDefaultView),\n/* harmony export */   getSelection: () => (/* binding */ getSelection),\n/* harmony export */   hasShadowRoot: () => (/* binding */ hasShadowRoot),\n/* harmony export */   isAfter: () => (/* binding */ isAfter),\n/* harmony export */   isBefore: () => (/* binding */ isBefore),\n/* harmony export */   isDOMElement: () => (/* binding */ isDOMElement),\n/* harmony export */   isDOMNode: () => (/* binding */ isDOMNode),\n/* harmony export */   isDOMSelection: () => (/* binding */ isDOMSelection),\n/* harmony export */   isElementDecorationsEqual: () => (/* binding */ isElementDecorationsEqual),\n/* harmony export */   isPlainTextOnlyPaste: () => (/* binding */ isPlainTextOnlyPaste),\n/* harmony export */   isTextDecorationsEqual: () => (/* binding */ isTextDecorationsEqual),\n/* harmony export */   isTrackedMutation: () => (/* binding */ isTrackedMutation),\n/* harmony export */   mergeStringDiffs: () => (/* binding */ mergeStringDiffs),\n/* harmony export */   normalizeDOMPoint: () => (/* binding */ normalizeDOMPoint),\n/* harmony export */   normalizePoint: () => (/* binding */ normalizePoint),\n/* harmony export */   normalizeRange: () => (/* binding */ normalizeRange),\n/* harmony export */   normalizeStringDiff: () => (/* binding */ normalizeStringDiff),\n/* harmony export */   targetRange: () => (/* binding */ targetRange),\n/* harmony export */   verifyDiffState: () => (/* binding */ verifyDiffState),\n/* harmony export */   withDOM: () => (/* binding */ withDOM)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/is-hotkey/lib/index.js\");\n\n\n\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint;\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = domNode => {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = root => {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var {\n    document\n  } = DOMEditor.getWindow(editor);\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = () => {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\n\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nclass Key {\n  constructor() {\n    _defineProperty(this, \"id\", void 0);\n    this.id = \"\".concat(n++);\n  }\n}\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n  androidScheduleFlush: editor => {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: editor => {\n    var {\n      selection\n    } = editor;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_1__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_1__.Editor.after(editor, edge);\n      if (point) {\n        var _range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var {\n      document\n    } = DOMEditor.getWindow(editor);\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: (editor, node) => {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: (editor, node) => {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(() => {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: editor => {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n    editable: true\n  }),\n  hasRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: (editor, target) => DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n  hasTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n  insertData: (editor, data) => {\n    editor.insertData(data);\n  },\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n  insertTextData: (editor, data) => editor.insertTextData(data),\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),\n  toDOMNode: (editor, node) => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: (editor, point) => {\n    var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(editor, point.path);\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: (editor, domNode) => {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: (editor, domPoint, options) => {\n    var {\n      exactMatch,\n      suppressThrow,\n      searchDirection = 'backward'\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = node => node ? node.querySelectorAll(\n        // Exclude leaf nodes in nested editors\n        '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [...getLeafNodes(elementNode), ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)];\n          leafNode = (_leafNodes$find = _leafNodes.find(leaf => isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling), ...getLeafNodes(elementNode)];\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(leaf => isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var {\n          path: _path,\n          offset: _offset\n        } = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, DOMEditor.findPath(editor, _slateNode));\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n  toSlateRange: (editor, domRange, options) => {\n    var _focusNode$textConten;\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            }\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.next(path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, nextPath);\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(editor, {\n    match: n => slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(editor, n),\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.next(editor, {\n      at: path,\n      match: slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText\n    });\n    if (!entry || !slate__WEBPACK_IMPORTED_MODULE_1__.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path,\n    offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var {\n    diff\n  } = textDiff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'split_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Range.end(parentRange));\n  var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_1__.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left], parentRangeBoundary);\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(e, {\n        match: n => slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(e, n),\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(currentLineRange)) {\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = op => {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.common(slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          var changedPath;\n          if (slate__WEBPACK_IMPORTED_MODULE_1__.Path.isBefore(op.path, op.newPath)) {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n            changedPath = op.newPath;\n          } else {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath)));\n            changedPath = op.path;\n          }\n          var changedNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.pathRef(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_selection':\n        {\n          // FIXME: Rename to something like IS_DOM_EDITOR_DESYNCED\n          // to better reflect reality, see #5792\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var [path, key] of matches) {\n      var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var [pathRef, _key] of pathRefMatches) {\n      if (pathRef.current) {\n        var [_node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, pathRef.current);\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n    if (!selection) {\n      return;\n    }\n    var [start, end] = slate__WEBPACK_IMPORTED_MODULE_1__.Range.edges(selection);\n    var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n      at: end.path\n    });\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = data => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      for (var line of lines) {\n        if (split) {\n          slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n        e.insertText(line);\n        split = true;\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = options => {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = (e, path) => {\n  var matches = [];\n  for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_1__.Editor.levels(e, {\n    at: path\n  })) {\n    var key = DOMEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n  return matches;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(generic);\n  var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(apple);\n  var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other) => {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtZG9tL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEY7QUFDekQ7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQVE7QUFDckMseUJBQXlCLG1EQUFRO0FBQ2pDLDZCQUE2QixtREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxTQUFTLHdDQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeW5DO0FBQ3puQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JhbnRlYy8uL25vZGVfbW9kdWxlcy9zbGF0ZS1kb20vZGlzdC9pbmRleC5lcy5qcz9kZTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zZm9ybXMsIEVsZW1lbnQsIEVkaXRvciwgU2NydWJiZXIsIFJhbmdlLCBOb2RlLCBUZXh0LCBQYXRoLCBQb2ludCB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IGlzSG90a2V5IH0gZnJvbSAnaXMtaG90a2V5JztcblxuLyoqXG4gKiBUeXBlcy5cbiAqL1xuLy8gQ09NUEFUOiBUaGlzIGlzIHJlcXVpcmVkIHRvIHByZXZlbnQgVHlwZVNjcmlwdCBhbGlhc2VzIGZyb20gZG9pbmcgc29tZSB2ZXJ5XG4vLyB3ZWlyZCB0aGluZ3MgZm9yIFNsYXRlJ3MgdHlwZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGdsb2JhbHMuICgyMDE5LzExLzI3KVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNTAwMlxudmFyIERPTU5vZGUgPSBnbG9iYWxUaGlzLk5vZGU7XG52YXIgRE9NRWxlbWVudCA9IGdsb2JhbFRoaXMuRWxlbWVudDtcbnZhciBET01UZXh0ID0gZ2xvYmFsVGhpcy5UZXh0O1xudmFyIERPTVJhbmdlID0gZ2xvYmFsVGhpcy5SYW5nZTtcbnZhciBET01TZWxlY3Rpb24gPSBnbG9iYWxUaGlzLlNlbGVjdGlvbjtcbnZhciBET01TdGF0aWNSYW5nZSA9IGdsb2JhbFRoaXMuU3RhdGljUmFuZ2U7XG4vKipcbiAqIFJldHVybnMgdGhlIGhvc3Qgd2luZG93IG9mIGEgRE9NIG5vZGVcbiAqL1xudmFyIGdldERlZmF1bHRWaWV3ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3duZXJEb2N1bWVudCAmJiB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG51bGw7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxuICovXG52YXIgaXNET01Db21tZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gODtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxuICovXG52YXIgaXNET01FbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gbm9kZS5cbiAqL1xudmFyIGlzRE9NTm9kZSA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHZhbHVlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93Lk5vZGU7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIHNlbGVjdGlvbi5cbiAqL1xudmFyIGlzRE9NU2VsZWN0aW9uID0gdmFsdWUgPT4ge1xuICB2YXIgd2luZG93ID0gdmFsdWUgJiYgdmFsdWUuYW5jaG9yTm9kZSAmJiBnZXREZWZhdWx0Vmlldyh2YWx1ZS5hbmNob3JOb2RlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93LlNlbGVjdGlvbjtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxuICovXG52YXIgaXNET01UZXh0ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cbiAqL1xudmFyIGlzUGxhaW5UZXh0T25seVBhc3RlID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSAhPT0gJycgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcy5sZW5ndGggPT09IDE7XG59O1xuLyoqXG4gKiBOb3JtYWxpemUgYSBET00gcG9pbnQgc28gdGhhdCBpdCBhbHdheXMgcmVmZXJzIHRvIGEgdGV4dCBub2RlLlxuICovXG52YXIgbm9ybWFsaXplRE9NUG9pbnQgPSBkb21Qb2ludCA9PiB7XG4gIHZhciBbbm9kZSwgb2Zmc2V0XSA9IGRvbVBvaW50O1xuICAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cbiAgaWYgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlzTGFzdCA9IG9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBpc0xhc3QgPyBvZmZzZXQgLSAxIDogb2Zmc2V0O1xuICAgIFtub2RlLCBpbmRleF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgobm9kZSwgaW5kZXgsIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpO1xuICAgIC8vIElmIHRoZSBlZGl0YWJsZSBjaGlsZCBmb3VuZCBpcyBpbiBmcm9udCBvZiBpbnB1dCBvZmZzZXQsIHdlIGluc3RlYWQgc2VlayB0byBpdHMgZW5kXG4gICAgaXNMYXN0ID0gaW5kZXggPCBvZmZzZXQ7XG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIGNoaWxkcmVuLCB0cmF2ZXJzZSB1bnRpbCB3ZSBoYXZlIGEgbGVhZiBub2RlLiBMZWFmIG5vZGVzXG4gICAgLy8gY2FuIGJlIGVpdGhlciB0ZXh0IG5vZGVzLCBvciBvdGhlciB2b2lkIERPTSBub2Rlcy5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgfVxuICAgIC8vIERldGVybWluZSB0aGUgbmV3IG9mZnNldCBpbnNpZGUgdGhlIHRleHQgbm9kZS5cbiAgICBvZmZzZXQgPSBpc0xhc3QgJiYgbm9kZS50ZXh0Q29udGVudCAhPSBudWxsID8gbm9kZS50ZXh0Q29udGVudC5sZW5ndGggOiAwO1xuICB9XG4gIC8vIFJldHVybiB0aGUgbm9kZSBhbmQgb2Zmc2V0LlxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIG5lc3RlZCB3aXRoaW4gYSBzaGFkb3dSb290XG4gKi9cbnZhciBoYXNTaGFkb3dSb290ID0gbm9kZSA9PiB7XG4gIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGFuZCBpbmRleCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcbiAqIGBkaXJlY3Rpb25gLlxuICovXG52YXIgZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4ID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkTm9kZXNcbiAgfSA9IHBhcmVudDtcbiAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpbmRleF07XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciB0cmllZEZvcndhcmQgPSBmYWxzZTtcbiAgdmFyIHRyaWVkQmFja3dhcmQgPSBmYWxzZTtcbiAgLy8gV2hpbGUgdGhlIGNoaWxkIGlzIGEgY29tbWVudCBub2RlLCBvciBhbiBlbGVtZW50IG5vZGUgd2l0aCBubyBjaGlsZHJlbixcbiAgLy8ga2VlcCBpdGVyYXRpbmcgdG8gZmluZCBhIHNpYmxpbmcgbm9uLXZvaWQsIG5vbi1jb21tZW50IG5vZGUuXG4gIHdoaWxlIChpc0RPTUNvbW1lbnQoY2hpbGQpIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgaWYgKHRyaWVkRm9yd2FyZCAmJiB0cmllZEJhY2t3YXJkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGkgPj0gY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRyaWVkRm9yd2FyZCA9IHRydWU7XG4gICAgICBpID0gaW5kZXggLSAxO1xuICAgICAgZGlyZWN0aW9uID0gJ2JhY2t3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRyaWVkQmFja3dhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgaW5kZXggPSBpO1xuICAgIGkgKz0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIFtjaGlsZCwgaW5kZXhdO1xufTtcbi8qKlxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xuICogYGRpcmVjdGlvbmAuXG4gKi9cbnZhciBnZXRFZGl0YWJsZUNoaWxkID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIgW2NoaWxkXSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuLyoqXG4gKiBHZXQgYSBwbGFpbnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRlbnQgb2YgYSBub2RlLCBhY2NvdW50aW5nIGZvciBibG9ja1xuICogZWxlbWVudHMgd2hpY2ggZ2V0IGEgbmV3bGluZSBhcHBlbmRlZC5cbiAqXG4gKiBUaGUgZG9tTm9kZSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gKi9cbnZhciBnZXRQbGFpblRleHQgPSBkb21Ob2RlID0+IHtcbiAgdmFyIHRleHQgPSAnJztcbiAgaWYgKGlzRE9NVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBkb21Ob2RlLm5vZGVWYWx1ZTtcbiAgfVxuICBpZiAoaXNET01FbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgZm9yICh2YXIgY2hpbGROb2RlIG9mIEFycmF5LmZyb20oZG9tTm9kZS5jaGlsZE5vZGVzKSkge1xuICAgICAgdGV4dCArPSBnZXRQbGFpblRleHQoY2hpbGROb2RlKTtcbiAgICB9XG4gICAgdmFyIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBkaXNwbGF5ID09PSAnbGlzdCcgfHwgZG9tTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG4vKipcbiAqIEdldCB4LXNsYXRlLWZyYWdtZW50IGF0dHJpYnV0ZSBmcm9tIGRhdGEtc2xhdGUtZnJhZ21lbnRcbiAqL1xudmFyIGNhdGNoU2xhdGVGcmFnbWVudCA9IC9kYXRhLXNsYXRlLWZyYWdtZW50PVwiKC4rPylcIi9tO1xudmFyIGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUgPSBkYXRhVHJhbnNmZXIgPT4ge1xuICB2YXIgaHRtbERhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIHZhciBbLCBmcmFnbWVudF0gPSBodG1sRGF0YS5tYXRjaChjYXRjaFNsYXRlRnJhZ21lbnQpIHx8IFtdO1xuICByZXR1cm4gZnJhZ21lbnQ7XG59O1xuLyoqXG4gKiBHZXQgdGhlIGRvbSBzZWxlY3Rpb24gZnJvbSBTaGFkb3cgUm9vdCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGZyb20gdGhlIGRvY3VtZW50XG4gKi9cbnZhciBnZXRTZWxlY3Rpb24gPSByb290ID0+IHtcbiAgaWYgKHJvb3QuZ2V0U2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICByZXR1cm4gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG59O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cbiAqL1xudmFyIGlzVHJhY2tlZE11dGF0aW9uID0gKGVkaXRvciwgbXV0YXRpb24sIGJhdGNoKSA9PiB7XG4gIHZhciB7XG4gICAgdGFyZ2V0XG4gIH0gPSBtdXRhdGlvbjtcbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIge1xuICAgIGRvY3VtZW50XG4gIH0gPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHZhciBwYXJlbnRNdXRhdGlvbiA9IGJhdGNoLmZpbmQoX3JlZiA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGFkZGVkTm9kZXMsXG4gICAgICByZW1vdmVkTm9kZXNcbiAgICB9ID0gX3JlZjtcbiAgICBmb3IgKHZhciBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlID09PSB0YXJnZXQgfHwgbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgIGlmIChfbm9kZSA9PT0gdGFyZ2V0IHx8IF9ub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwYXJlbnRNdXRhdGlvbiB8fCBwYXJlbnRNdXRhdGlvbiA9PT0gbXV0YXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGFyZ2V0IGFkZC9yZW1vdmUgaXMgdHJhY2tlZC4gVHJhY2sgdGhlIG11dGF0aW9uIGlmIHdlIHRyYWNrIHRoZSBwYXJlbnQgbXV0YXRpb24uXG4gIHJldHVybiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIHBhcmVudE11dGF0aW9uLCBiYXRjaCk7XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGRlZXBlc3QgYWN0aXZlIGVsZW1lbnQgaW4gdGhlIERPTSwgY29uc2lkZXJpbmcgbmVzdGVkIHNoYWRvdyBET01zLlxuICovXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB3aGlsZSAoKF9hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudCkgIT09IG51bGwgJiYgX2FjdGl2ZUVsZW1lbnQgIT09IHZvaWQgMCAmJiBfYWN0aXZlRWxlbWVudC5zaGFkb3dSb290ICYmIChfYWN0aXZlRWxlbWVudCRzaGFkb3cgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpICE9PSBudWxsICYmIF9hY3RpdmVFbGVtZW50JHNoYWRvdyAhPT0gdm9pZCAwICYmIF9hY3RpdmVFbGVtZW50JHNoYWRvdy5hY3RpdmVFbGVtZW50KSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50LCBfYWN0aXZlRWxlbWVudCRzaGFkb3csIF9hY3RpdmVFbGVtZW50MjtcbiAgICBhY3RpdmVFbGVtZW50ID0gKF9hY3RpdmVFbGVtZW50MiA9IGFjdGl2ZUVsZW1lbnQpID09PSBudWxsIHx8IF9hY3RpdmVFbGVtZW50MiA9PT0gdm9pZCAwIHx8IChfYWN0aXZlRWxlbWVudDIgPSBfYWN0aXZlRWxlbWVudDIuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2FjdGl2ZUVsZW1lbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWN0aXZlRWxlbWVudDIuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn07XG4vKipcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBgb3RoZXJOb2RlYCBpcyBiZWZvcmUgYG5vZGVgIGluIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICovXG52YXIgaXNCZWZvcmUgPSAobm9kZSwgb3RoZXJOb2RlKSA9PiBCb29sZWFuKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIERPTU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKTtcbi8qKlxuICogQHJldHVybnMgYHRydWVgIGlmIGBvdGhlck5vZGVgIGlzIGFmdGVyIGBub2RlYCBpbiB0aGUgZG9jdW1lbnQ7IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAqL1xudmFyIGlzQWZ0ZXIgPSAobm9kZSwgb3RoZXJOb2RlKSA9PiBCb29sZWFuKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKSAmIERPTU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKTtcblxudmFyIF9uYXZpZ2F0b3IkdXNlckFnZW50JCwgX25hdmlnYXRvciR1c2VyQWdlbnQkMjtcbnZhciBJU19JT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xudmFyIElTX0FQUExFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL01hYyBPUyBYLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0FORFJPSUQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19GSVJFRk9YID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX1dFQktJVCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BcHBsZVdlYktpdCg/IS4qQ2hyb21lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBcIm1vZGVyblwiIEVkZ2Ugd2FzIHJlbGVhc2VkIGF0IDc5LnhcbnZhciBJU19FREdFX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9FZGdlP1xcLyg/OlswLTZdWzAtOV18WzAtN11bMC04XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19DSFJPTUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIE5hdGl2ZSBgYmVmb3JlSW5wdXRgIGV2ZW50cyBkb24ndCB3b3JrIHdlbGwgd2l0aCByZWFjdCBvbiBDaHJvbWUgNzVcbi8vIGFuZCBvbGRlciwgQ2hyb21lIDc2KyBjYW4gdXNlIGBiZWZvcmVJbnB1dGAgdGhvdWdoLlxudmFyIElTX0NIUk9NRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTddWzAtNV18WzAtNl1bMC05XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kgPSBJU19BTkRST0lEICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWU/XFwvKD86WzAtNV0/XFxkKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cbnZhciBJU19GSVJFRk9YX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94XFwvKD86WzAtN11bMC05XXxbMC04XVswLTZdKSg/OlxcLikpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gVUMgbW9iaWxlIGJyb3dzZXJcbnZhciBJU19VQ19NT0JJTEUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipVQ0Jyb3dzZXIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBXZWNoYXQgYnJvd3NlciAobm90IGluY2x1ZGluZyBtYWMgd2VjaGF0KVxudmFyIElTX1dFQ0hBVEJST1dTRVIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS8uKk1hY1dlY2hhdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gYXZvaWQgbG9va2JlaGluZCAoYnVnZ3kgaW4gc2FmYXJpIDwgMTYuNClcbi8vIENoZWNrIGlmIERPTSBpcyBhdmFpbGFibGUgYXMgUmVhY3QgZG9lcyBpbnRlcm5hbGx5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xudmFyIENBTl9VU0VfRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG4vLyBDaGVjayBpZiB0aGUgYnJvd3NlciBpcyBTYWZhcmkgYW5kIG9sZGVyIHRoYW4gMTdcbnR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL1ZlcnNpb25cXC8oXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKChfbmF2aWdhdG9yJHVzZXJBZ2VudCQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLykpICE9PSBudWxsICYmIF9uYXZpZ2F0b3IkdXNlckFnZW50JCAhPT0gdm9pZCAwICYmIF9uYXZpZ2F0b3IkdXNlckFnZW50JFsxXSA/IHBhcnNlSW50KChfbmF2aWdhdG9yJHVzZXJBZ2VudCQyID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhcXGQrKS8pKSA9PT0gbnVsbCB8fCBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmF2aWdhdG9yJHVzZXJBZ2VudCQyWzFdLCAxMCkgPCAxNyA6IGZhbHNlKTtcbi8vIENPTVBBVDogRmlyZWZveC9FZGdlIExlZ2FjeSBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50XG4vLyBDaHJvbWUgTGVnYWN5IGRvZXNuJ3Qgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGNvcnJlY3RseVxudmFyIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA9ICghSVNfQ0hST01FX0xFR0FDWSB8fCAhSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZKSAmJiAhSVNfRURHRV9MRUdBQ1kgJiZcbi8vIGdsb2JhbFRoaXMgaXMgdW5kZWZpbmVkIGluIG9sZGVyIGJyb3dzZXJzXG50eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5JbnB1dEV2ZW50ICYmXG4vLyBAdHMtaWdub3JlIFRoZSBgZ2V0VGFyZ2V0UmFuZ2VzYCBwcm9wZXJ0eSBpc24ndCByZWNvZ25pemVkLlxudHlwZW9mIGdsb2JhbFRoaXMuSW5wdXRFdmVudC5wcm90b3R5cGUuZ2V0VGFyZ2V0UmFuZ2VzID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBBbiBhdXRvLWluY3JlbWVudGluZyBpZGVudGlmaWVyIGZvciBrZXlzLlxuICovXG52YXIgbiA9IDA7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiBhIGtleSBzdHJpbmcuIFdlIHVzZSBhIGZ1bGwgY2xhc3MgaGVyZSBiZWNhdXNlIHdlXG4gKiB3YW50IHRvIGJlIGFibGUgdG8gdXNlIHRoZW0gYXMga2V5cyBpbiBgV2Vha01hcGAgb2JqZWN0cy5cbiAqL1xuY2xhc3MgS2V5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmlkID0gXCJcIi5jb25jYXQobisrKTtcbiAgfVxufVxuXG4vKipcbiAqIFR3byB3ZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyByZWJ1aWxkIGEgcGF0aCBnaXZlbiBhIG5vZGUuIFRoZXkgYXJlIHBvcHVsYXRlZFxuICogYXQgcmVuZGVyIHRpbWUgc3VjaCB0aGF0IGFmdGVyIGEgcmVuZGVyIG9jY3VycyB3ZSBjYW4gYWx3YXlzIGJhY2t0cmFjay5cbiAqL1xudmFyIElTX05PREVfTUFQX0RJUlRZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0lOREVYID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX1BBUkVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyB0aGF0IGFsbG93IHVzIHRvIGdvIGJldHdlZW4gU2xhdGUgbm9kZXMgYW5kIERPTSBub2Rlcy4gVGhlc2VcbiAqIGFyZSB1c2VkIHRvIHJlc29sdmUgRE9NIGV2ZW50LXJlbGF0ZWQgbG9naWMgaW50byBTbGF0ZSBhY3Rpb25zLlxuICovXG52YXIgRURJVE9SX1RPX1dJTkRPVyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFTEVNRU5UX1RPX05PREUgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19LRVkgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFdlYWsgbWFwcyBmb3Igc3RvcmluZyBlZGl0b3ItcmVsYXRlZCBzdGF0ZS5cbiAqL1xudmFyIElTX1JFQURfT05MWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfRk9DVVNFRCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfQ09NUE9TSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcCBmb3IgYXNzb2NpYXRpbmcgdGhlIGNvbnRleHQgYG9uQ2hhbmdlYCBjb250ZXh0IHdpdGggdGhlIHBsdWdpbi5cbiAqL1xudmFyIEVESVRPUl9UT19PTl9DSEFOR0UgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgZm9yIHNhdmluZyBwZW5kaW5nIHN0YXRlIG9uIGNvbXBvc2l0aW9uIHN0YWdlLlxuICovXG52YXIgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQW5kcm9pZCBpbnB1dCBoYW5kbGluZyBzcGVjaWZpYyB3ZWFrLW1hcHNcbiAqL1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19BQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFN5bWJvbHMuXG4gKi9cbnZhciBQTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ3BsYWNlaG9sZGVyJyk7XG52YXIgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ21hcmstcGxhY2Vob2xkZXInKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIERPTUVkaXRvciA9IHtcbiAgYW5kcm9pZFBlbmRpbmdEaWZmczogZWRpdG9yID0+IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpLFxuICBhbmRyb2lkU2NoZWR1bGVGbHVzaDogZWRpdG9yID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GO1xuICAgIChfRURJVE9SX1RPX1NDSEVEVUxFX0YgPSBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICB9LFxuICBibHVyOiBlZGl0b3IgPT4ge1xuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gRE9NRWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICB9LFxuICBkZXNlbGVjdDogZWRpdG9yID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgIGlmIChkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICB9XG4gIH0sXG4gIGZpbmREb2N1bWVudE9yU2hhZG93Um9vdDogZWRpdG9yID0+IHtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50O1xuICB9LFxuICBmaW5kRXZlbnRSYW5nZTogKGVkaXRvciwgZXZlbnQpID0+IHtcbiAgICBpZiAoJ25hdGl2ZUV2ZW50JyBpbiBldmVudCkge1xuICAgICAgZXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICB9XG4gICAgdmFyIHtcbiAgICAgIGNsaWVudFg6IHgsXG4gICAgICBjbGllbnRZOiB5LFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHBhdGggPSBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAvLyBJZiB0aGUgZHJvcCB0YXJnZXQgaXMgaW5zaWRlIGEgdm9pZCBub2RlLCBtb3ZlIGl0IGludG8gZWl0aGVyIHRoZVxuICAgIC8vIG5leHQgb3IgcHJldmlvdXMgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGUgdGhlIGB4YCBhbmQgYHlgXG4gICAgLy8gY29vcmRpbmF0ZXMgYXJlIGNsb3Nlc3QgdG8uXG4gICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHZhciBfcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIHJldHVybiBfcmFuZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVsc2UgcmVzb2x2ZSBhIHJhbmdlIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRoZSBkcm9wIG9jY3VyZWQuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG4gICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGRvbVJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGRvbVJhbmdlLnNldFN0YXJ0KHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICAgIGRvbVJhbmdlLnNldEVuZChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cbiAgICAvLyBSZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSB0aGUgRE9NIHJhbmdlLlxuICAgIHZhciByYW5nZSA9IERPTUVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21SYW5nZSwge1xuICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICBzdXBwcmVzc1Rocm93OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfSxcbiAgZmluZEtleTogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBrZXkgPSBOT0RFX1RPX0tFWS5nZXQobm9kZSk7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGtleSA9IG5ldyBLZXkoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9LFxuICBmaW5kUGF0aDogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIGNoaWxkID0gbm9kZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IE5PREVfVE9fUEFSRU5ULmdldChjaGlsZCk7XG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSBOT0RFX1RPX0lOREVYLmdldChjaGlsZCk7XG4gICAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBwYXRoIGZvciBTbGF0ZSBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gIH0sXG4gIGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgcmV0cmllczogNVxuICAgIH07XG4gICAgLy8gUmV0dXJuIGlmIGFscmVhZHkgZm9jdXNlZFxuICAgIGlmIChJU19GT0NVU0VELmdldChlZGl0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJldHJ5IHNldHRpbmcgZm9jdXMgaWYgdGhlIGVkaXRvciBoYXMgcGVuZGluZyBvcGVyYXRpb25zLlxuICAgIC8vIFRoZSBET00gKHNlbGVjdGlvbikgaXMgdW5zdGFibGUgd2hpbGUgY2hhbmdlcyBhcmUgYXBwbGllZC5cbiAgICAvLyBSZXRyeSB1bnRpbCByZXRyaWVzIGFyZSBleGhhdXN0ZWQgb3IgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgaWYgKG9wdGlvbnMucmV0cmllcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzZXQgZm9jdXMsIGVkaXRvciBzZWVtcyBzdHVjayB3aXRoIHBlbmRpbmcgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIERPTUVkaXRvci5mb2N1cyhlZGl0b3IsIHtcbiAgICAgICAgICByZXRyaWVzOiBvcHRpb25zLnJldHJpZXMgLSAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgMTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ICE9PSBlbCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIERPTSBzZWxlY3Rpb24gc3RhdGUgaXMgc2V0IHRvIHRoZSBlZGl0b3IncyBzZWxlY3Rpb25cbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICB2YXIgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHJvb3QpO1xuICAgICAgICB2YXIgZG9tUmFuZ2UgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSB2b2lkIDAgfHwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKGRvbVJhbmdlKTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZWxlY3Rpb24gaW4gdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQgaWYgbWlzc2luZ1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pKTtcbiAgICAgIH1cbiAgICAgIC8vIElTX0ZPQ1VTRUQgc2hvdWxkIGJlIHNldCBiZWZvcmUgY2FsbGluZyBlbC5mb2N1cygpIHRvIGVuc3VyZSB0aGF0XG4gICAgICAvLyBGb2N1c2VkQ29udGV4dCBpcyB1cGRhdGVkIHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgZWwuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFdpbmRvdzogZWRpdG9yID0+IHtcbiAgICB2YXIgd2luZG93ID0gRURJVE9SX1RPX1dJTkRPVy5nZXQoZWRpdG9yKTtcbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIGhvc3Qgd2luZG93IGVsZW1lbnQgZm9yIHRoaXMgZWRpdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3c7XG4gIH0sXG4gIGhhc0RPTU5vZGU6IGZ1bmN0aW9uIGhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGVkaXRhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWRpdG9yRWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgdGFyZ2V0RWw7XG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCByZWFkaW5nIGB0YXJnZXQubm9kZVR5cGVgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICAvLyB0YXJnZXQgaXMgb3JpZ2luYXRpbmcgZnJvbSBhbiBpbnRlcm5hbCBcInJlc3RyaWN0ZWRcIiBlbGVtZW50IChlLmcuIGFcbiAgICAvLyBzdGVwcGVyIGFycm93IG9uIGEgbnVtYmVyIGlucHV0KS4gKDIwMTgvMDUvMDQpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy8xODE5XG4gICAgdHJ5IHtcbiAgICAgIHRhcmdldEVsID0gaXNET01FbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiAhZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcIm5vZGVUeXBlXCInKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldEVsLmNsb3Nlc3QoXCJbZGF0YS1zbGF0ZS1lZGl0b3JdXCIpID09PSBlZGl0b3JFbCAmJiAoIWVkaXRhYmxlIHx8IHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID8gdHJ1ZSA6IHR5cGVvZiB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgLy8gaXNDb250ZW50RWRpdGFibGUgZXhpc3RzIG9ubHkgb24gSFRNTEVsZW1lbnQsIGFuZCBvbiBvdGhlciBub2RlcyBpdCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIC8vIHRoaXMgaXMgdGhlIGNvcmUgbG9naWMgdGhhdCBsZXRzIHlvdSBrbm93IHlvdSBnb3QgdGhlIHJpZ2h0IGVkaXRvci5zZWxlY3Rpb24gaW5zdGVhZCBvZiBudWxsIHdoZW4gZWRpdG9yIGlzIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIocmVhZE9ubHkpXG4gICAgdGFyZ2V0RWwuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJykgPT09IGVkaXRvckVsIHx8ICEhdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSk7XG4gIH0sXG4gIGhhc0VkaXRhYmxlVGFyZ2V0OiAoZWRpdG9yLCB0YXJnZXQpID0+IGlzRE9NTm9kZSh0YXJnZXQpICYmIERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgZWRpdGFibGU6IHRydWVcbiAgfSksXG4gIGhhc1JhbmdlOiAoZWRpdG9yLCByYW5nZSkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBhbmNob3IucGF0aCkgJiYgRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBmb2N1cy5wYXRoKTtcbiAgfSxcbiAgaGFzU2VsZWN0YWJsZVRhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBET01FZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHx8IERPTUVkaXRvci5pc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCksXG4gIGhhc1RhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCksXG4gIGluc2VydERhdGE6IChlZGl0b3IsIGRhdGEpID0+IHtcbiAgICBlZGl0b3IuaW5zZXJ0RGF0YShkYXRhKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnREYXRhOiAoZWRpdG9yLCBkYXRhKSA9PiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhKGRhdGEpLFxuICBpbnNlcnRUZXh0RGF0YTogKGVkaXRvciwgZGF0YSkgPT4gZWRpdG9yLmluc2VydFRleHREYXRhKGRhdGEpLFxuICBpc0NvbXBvc2luZzogZWRpdG9yID0+IHtcbiAgICByZXR1cm4gISFJU19DT01QT1NJTkcuZ2V0KGVkaXRvcik7XG4gIH0sXG4gIGlzRm9jdXNlZDogZWRpdG9yID0+ICEhSVNfRk9DVVNFRC5nZXQoZWRpdG9yKSxcbiAgaXNSZWFkT25seTogZWRpdG9yID0+ICEhSVNfUkVBRF9PTkxZLmdldChlZGl0b3IpLFxuICBpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZDogKGVkaXRvciwgdGFyZ2V0KSA9PiB7XG4gICAgaWYgKElTX1JFQURfT05MWS5nZXQoZWRpdG9yKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzbGF0ZU5vZGUgPSBET01FZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChzbGF0ZU5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICB9LFxuICBzZXRGcmFnbWVudERhdGE6IChlZGl0b3IsIGRhdGEsIG9yaWdpbkV2ZW50KSA9PiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGRhdGEsIG9yaWdpbkV2ZW50KSxcbiAgdG9ET01Ob2RlOiAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIHZhciBkb21Ob2RlID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcikgOiBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZ2V0KERPTUVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gbm9kZSBmcm9tIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbU5vZGU7XG4gIH0sXG4gIHRvRE9NUG9pbnQ6IChlZGl0b3IsIHBvaW50KSA9PiB7XG4gICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcG9pbnQucGF0aCk7XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgIHZhciBkb21Qb2ludDtcbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSB2b2lkIG5vZGUsIGZvcmNlIHRoZSBvZmZzZXQgdG8gMCwgb3RoZXJ3aXNlIHRoZSB6ZXJvXG4gICAgLy8gd2lkdGggc3BhY2luZyBjaGFyYWN0ZXIgd2lsbCByZXN1bHQgaW4gYW4gaW5jb3JyZWN0IG9mZnNldCBvZiAxXG4gICAgaWYgKEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHBvaW50XG4gICAgfSkpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGxlYWYsIHdlIG5lZWQgdG8gaXNvbGF0ZSBpdHMgY29udGVudCwgd2hpY2ggbWVhbnMgZmlsdGVyaW5nXG4gICAgLy8gdG8gaXRzIGRpcmVjdCB0ZXh0IGFuZCB6ZXJvLXdpZHRoIHNwYW5zLiAoV2UgaGF2ZSB0byBmaWx0ZXIgb3V0IGFueVxuICAgIC8vIG90aGVyIHNpYmxpbmdzIHRoYXQgbWF5IGhhdmUgYmVlbiByZW5kZXJlZCBhbG9uZ3NpZGUgdGhlbS4pXG4gICAgdmFyIHNlbGVjdG9yID0gXCJbZGF0YS1zbGF0ZS1zdHJpbmddLCBbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiO1xuICAgIHZhciB0ZXh0cyA9IEFycmF5LmZyb20oZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHQgPSB0ZXh0c1tpXTtcbiAgICAgIHZhciBkb21Ob2RlID0gdGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgaWYgKGRvbU5vZGUgPT0gbnVsbCB8fCBkb21Ob2RlLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBkb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgdmFyIGF0dHIgPSB0ZXh0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1sZW5ndGgnKTtcbiAgICAgIHZhciB0cnVlTGVuZ3RoID0gYXR0ciA9PSBudWxsID8gbGVuZ3RoIDogcGFyc2VJbnQoYXR0ciwgMTApO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgdHJ1ZUxlbmd0aDtcbiAgICAgIC8vIFByZWZlciBwdXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBtYXJrIHBsYWNlaG9sZGVyIHRvIGVuc3VyZVxuICAgICAgLy8gY29tcG9zZWQgdGV4dCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgY29ycmVjdCBtYXJrcy5cbiAgICAgIHZhciBuZXh0VGV4dCA9IHRleHRzW2kgKyAxXTtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPT09IGVuZCAmJiBuZXh0VGV4dCAhPT0gbnVsbCAmJiBuZXh0VGV4dCAhPT0gdm9pZCAwICYmIG5leHRUZXh0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgdmFyIF9uZXh0VGV4dCR0ZXh0Q29udGVudDtcbiAgICAgICAgdmFyIGRvbVRleHQgPSBuZXh0VGV4dC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICBkb21Qb2ludCA9IFtcbiAgICAgICAgLy8gQ09NUEFUOiBJZiB3ZSBkb24ndCBleHBsaWNpdHkgc2V0IHRoZSBkb20gcG9pbnQgdG8gYmUgb24gdGhlIGFjdHVhbFxuICAgICAgICAvLyBkb20gdGV4dCBlbGVtZW50LCBjaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiBiZWhpbmQgdGhlIGFjdHVhbCBkb21cbiAgICAgICAgLy8gdGV4dCBlbGVtZW50LCBjYXVzaW5nIGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGxzIG9uIGEgY29sbGFwc2VkXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byByZXR1cm4gaW5jb3JyZWN0IHplcm8gdmFsdWVzIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzgpXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzIHdoZW4gc2Nyb2xsaW5nIHRvIGl0LlxuICAgICAgICBkb21UZXh0IGluc3RhbmNlb2YgRE9NVGV4dCA/IGRvbVRleHQgOiBuZXh0VGV4dCwgKF9uZXh0VGV4dCR0ZXh0Q29udGVudCA9IG5leHRUZXh0LnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpID8gMSA6IDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIE1hdGgubWF4KDAsIHBvaW50Lm9mZnNldCAtIHN0YXJ0KSk7XG4gICAgICAgIGRvbVBvaW50ID0gW2RvbU5vZGUsIG9mZnNldF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghZG9tUG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIHBvaW50IGZyb20gU2xhdGUgcG9pbnQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocG9pbnQpKSk7XG4gICAgfVxuICAgIHJldHVybiBkb21Qb2ludDtcbiAgfSxcbiAgdG9ET01SYW5nZTogKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgdmFyIGlzQmFja3dhcmQgPSBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgICB2YXIgZG9tQW5jaG9yID0gRE9NRWRpdG9yLnRvRE9NUG9pbnQoZWRpdG9yLCBhbmNob3IpO1xuICAgIHZhciBkb21Gb2N1cyA9IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSA/IGRvbUFuY2hvciA6IERPTUVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgZm9jdXMpO1xuICAgIHZhciB3aW5kb3cgPSBET01FZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgdmFyIGRvbVJhbmdlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgdmFyIFtzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21Gb2N1cyA6IGRvbUFuY2hvcjtcbiAgICB2YXIgW2VuZE5vZGUsIGVuZE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tQW5jaG9yIDogZG9tRm9jdXM7XG4gICAgLy8gQSBzbGF0ZSBQb2ludCBhdCB6ZXJvLXdpZHRoIExlYWYgYWx3YXlzIGhhcyBhbiBvZmZzZXQgb2YgMCBidXQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBhdFxuICAgIC8vIHplcm8td2lkdGggbm9kZSBoYXMgYW4gb2Zmc2V0IG9mIDEgc28gd2UgaGF2ZSB0byBjaGVjayBpZiB3ZSBhcmUgaW4gYSB6ZXJvLXdpZHRoIG5vZGUgYW5kXG4gICAgLy8gYWRqdXN0IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuXG4gICAgdmFyIHN0YXJ0RWwgPSBpc0RPTUVsZW1lbnQoc3RhcnROb2RlKSA/IHN0YXJ0Tm9kZSA6IHN0YXJ0Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc1N0YXJ0QXRaZXJvV2lkdGggPSAhIXN0YXJ0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICB2YXIgZW5kRWwgPSBpc0RPTUVsZW1lbnQoZW5kTm9kZSkgPyBlbmROb2RlIDogZW5kTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBpc0VuZEF0WmVyb1dpZHRoID0gISFlbmRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIGRvbVJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgaXNTdGFydEF0WmVyb1dpZHRoID8gMSA6IHN0YXJ0T2Zmc2V0KTtcbiAgICBkb21SYW5nZS5zZXRFbmQoZW5kTm9kZSwgaXNFbmRBdFplcm9XaWR0aCA/IDEgOiBlbmRPZmZzZXQpO1xuICAgIHJldHVybiBkb21SYW5nZTtcbiAgfSxcbiAgdG9TbGF0ZU5vZGU6IChlZGl0b3IsIGRvbU5vZGUpID0+IHtcbiAgICB2YXIgZG9tRWwgPSBpc0RPTUVsZW1lbnQoZG9tTm9kZSkgPyBkb21Ob2RlIDogZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChkb21FbCAmJiAhZG9tRWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSkge1xuICAgICAgZG9tRWwgPSBkb21FbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtbm9kZV1cIik7XG4gICAgfVxuICAgIHZhciBub2RlID0gZG9tRWwgPyBFTEVNRU5UX1RPX05PREUuZ2V0KGRvbUVsKSA6IG51bGw7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIG5vZGUgZnJvbSBET00gbm9kZTogXCIuY29uY2F0KGRvbUVsKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICB0b1NsYXRlUG9pbnQ6IChlZGl0b3IsIGRvbVBvaW50LCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93LFxuICAgICAgc2VhcmNoRGlyZWN0aW9uID0gJ2JhY2t3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBbbmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXRdID0gZXhhY3RNYXRjaCA/IGRvbVBvaW50IDogbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpO1xuICAgIHZhciBwYXJlbnROb2RlID0gbmVhcmVzdE5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgdGV4dE5vZGUgPSBudWxsO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICB2YXIgX2RvbU5vZGUkdGV4dENvbnRlbnQsIF9kb21Ob2RlJHRleHRDb250ZW50MjtcbiAgICAgIHZhciBlZGl0b3JFbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIHBvdGVudGlhbFZvaWROb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS12b2lkPVwidHJ1ZVwiXScpO1xuICAgICAgLy8gTmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvc2VzdCB2b2lkIG5vZGUgaXMgYWN0dWFsbHkgYSB2b2lkIG5vZGVcbiAgICAgIC8vIHdpdGhpbiB0aGlzIGVkaXRvciwgYW5kIG5vdCBhIHZvaWQgbm9kZSB3aXRoaW4gc29tZSBwYXJlbnQgZWRpdG9yLiBUaGlzIGNhbiBoYXBwZW5cbiAgICAgIC8vIGlmIHRoaXMgZWRpdG9yIGlzIHdpdGhpbiBhIHZvaWQgbm9kZSBvZiBhbm90aGVyIGVkaXRvciAoXCJuZXN0ZWQgZWRpdG9yc1wiLCBsaWtlIGluXG4gICAgICAvLyB0aGUgXCJFZGl0YWJsZSBWb2lkc1wiIGV4YW1wbGUgb24gdGhlIGRvY3Mgc2l0ZSkuXG4gICAgICB2YXIgdm9pZE5vZGUgPSBwb3RlbnRpYWxWb2lkTm9kZSAmJiBlZGl0b3JFbC5jb250YWlucyhwb3RlbnRpYWxWb2lkTm9kZSkgPyBwb3RlbnRpYWxWb2lkTm9kZSA6IG51bGw7XG4gICAgICB2YXIgcG90ZW50aWFsTm9uRWRpdGFibGVOb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKTtcbiAgICAgIHZhciBub25FZGl0YWJsZU5vZGUgPSBwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUgJiYgZWRpdG9yRWwuY29udGFpbnMocG90ZW50aWFsTm9uRWRpdGFibGVOb2RlKSA/IHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSA6IG51bGw7XG4gICAgICB2YXIgbGVhZk5vZGUgPSBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLWxlYWZdJyk7XG4gICAgICB2YXIgZG9tTm9kZSA9IG51bGw7XG4gICAgICAvLyBDYWxjdWxhdGUgaG93IGZhciBpbnRvIHRoZSB0ZXh0IG5vZGUgdGhlIGBuZWFyZXN0Tm9kZWAgaXMsIHNvIHRoYXQgd2VcbiAgICAgIC8vIGNhbiBkZXRlcm1pbmUgd2hhdCB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB0ZXh0IG5vZGUgaXMuXG4gICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICBpZiAodGV4dE5vZGUpIHtcbiAgICAgICAgICB2YXIgd2luZG93ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgICAgICAgIHZhciByYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXQpO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSksIC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjb250ZW50ZWRpdGFibGU9ZmFsc2VdJykpXTtcbiAgICAgICAgICByZW1vdmFscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgY29tcG9zaW5nIGF0IHRoZSBzdGFydCBvZiBhIHRleHQgbm9kZSwgc29tZSBrZXlib2FyZHMgcHV0XG4gICAgICAgICAgICAvLyB0aGUgdGV4dCBjb250ZW50IGluc2lkZSB0aGUgemVybyB3aWR0aCBzcGFjZS5cbiAgICAgICAgICAgIGlmIChJU19BTkRST0lEICYmICFleGFjdE1hdGNoICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgJiYgZWwudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBlbC50ZXh0Q29udGV4dCAhPT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykpIHtcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIENPTVBBVDogRWRnZSBoYXMgYSBidWcgd2hlcmUgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nKCkgd2lsbFxuICAgICAgICAgIC8vIGNvbnZlcnQgXFxuIGludG8gXFxyXFxuLiBUaGUgYnVnIGNhdXNlcyBhIGxvb3Agd2hlbiBzbGF0ZS1kb21cbiAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZXBvc2l0aW9uIGl0cyBjdXJzb3IgdG8gbWF0Y2ggdGhlIG5hdGl2ZSBwb3NpdGlvbi4gVXNlXG4gICAgICAgICAgLy8gdGV4dENvbnRlbnQubGVuZ3RoIGluc3RlYWQuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAyOTExMTYvXG4gICAgICAgICAgb2Zmc2V0ID0gY29udGVudHMudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2b2lkTm9kZSkge1xuICAgICAgICAvLyBGb3Igdm9pZCBub2RlcywgdGhlIGVsZW1lbnQgd2l0aCB0aGUgb2Zmc2V0IGtleSB3aWxsIGJlIGEgY291c2luLCBub3QgYW5cbiAgICAgICAgLy8gYW5jZXN0b3IsIHNvIGZpbmQgaXQgYnkgZ29pbmcgZG93biBmcm9tIHRoZSBuZWFyZXN0IHZvaWQgcGFyZW50IGFuZCB0YWtpbmcgdGhlXG4gICAgICAgIC8vIGZpcnN0IG9uZSB0aGF0IGlzbid0IGluc2lkZSBhIG5lc3RlZCBlZGl0b3IuXG4gICAgICAgIHZhciBsZWFmTm9kZXMgPSB2b2lkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVhZk5vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gbGVhZk5vZGVzW2luZGV4XTtcbiAgICAgICAgICBpZiAoRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgbGVhZk5vZGUgPSBjdXJyZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogSW4gcmVhZC1vbmx5IGVkaXRvcnMgdGhlIGxlYWYgaXMgbm90IHJlbmRlcmVkLlxuICAgICAgICBpZiAoIWxlYWZOb2RlKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIG9mZnNldCA9IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9uRWRpdGFibGVOb2RlKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVkZ2Ugb2YgdGhlIG5lYXJlc3QgbGVhZiBpbiBgc2VhcmNoRGlyZWN0aW9uYFxuICAgICAgICB2YXIgZ2V0TGVhZk5vZGVzID0gbm9kZSA9PiBub2RlID8gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAvLyBFeGNsdWRlIGxlYWYgbm9kZXMgaW4gbmVzdGVkIGVkaXRvcnNcbiAgICAgICAgJ1tkYXRhLXNsYXRlLWxlYWZdOm5vdCg6c2NvcGUgW2RhdGEtc2xhdGUtZWRpdG9yXSBbZGF0YS1zbGF0ZS1sZWFmXSknKSA6IFtdO1xuICAgICAgICB2YXIgZWxlbWVudE5vZGUgPSBub25FZGl0YWJsZU5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cImVsZW1lbnRcIl0nKTtcbiAgICAgICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMkZmluZDtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlcyA9IFsuLi5nZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUpLCAuLi5nZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUgPT09IG51bGwgfHwgZWxlbWVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnROb2RlLm5leHRFbGVtZW50U2libGluZyldO1xuICAgICAgICAgIGxlYWZOb2RlID0gKF9sZWFmTm9kZXMkZmluZCA9IF9sZWFmTm9kZXMuZmluZChsZWFmID0+IGlzQWZ0ZXIobm9uRWRpdGFibGVOb2RlLCBsZWFmKSkpICE9PSBudWxsICYmIF9sZWFmTm9kZXMkZmluZCAhPT0gdm9pZCAwID8gX2xlYWZOb2RlcyRmaW5kIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2xlYWZOb2RlczIkZmluZExhc3Q7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMyID0gWy4uLmdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSA9PT0gbnVsbCB8fCBlbGVtZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudE5vZGUucHJldmlvdXNFbGVtZW50U2libGluZyksIC4uLmdldExlYWZOb2RlcyhlbGVtZW50Tm9kZSldO1xuICAgICAgICAgIGxlYWZOb2RlID0gKF9sZWFmTm9kZXMyJGZpbmRMYXN0ID0gX2xlYWZOb2RlczIuZmluZExhc3QobGVhZiA9PiBpc0JlZm9yZShub25FZGl0YWJsZU5vZGUsIGxlYWYpKSkgIT09IG51bGwgJiYgX2xlYWZOb2RlczIkZmluZExhc3QgIT09IHZvaWQgMCA/IF9sZWFmTm9kZXMyJGZpbmRMYXN0IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgZG9tTm9kZSA9IGxlYWZOb2RlO1xuICAgICAgICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAgIG9mZnNldCAtPSBlbC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkb21Ob2RlICYmIG9mZnNldCA9PT0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGggJiZcbiAgICAgIC8vIENPTVBBVDogQW5kcm9pZCBJTUVzIG1pZ2h0IHJlbW92ZSB0aGUgemVybyB3aWR0aCBzcGFjZSB3aGlsZSBjb21wb3NpbmcsXG4gICAgICAvLyBhbmQgd2UgZG9uJ3QgYWRkIGl0IGZvciBsaW5lLWJyZWFrcy5cbiAgICAgIElTX0FORFJPSUQgJiYgZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAneicgJiYgKF9kb21Ob2RlJHRleHRDb250ZW50ID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgJiYgKFxuICAgICAgLy8gQ09NUEFUOiBJZiB0aGUgcGFyZW50IG5vZGUgaXMgYSBTbGF0ZSB6ZXJvLXdpZHRoIHNwYWNlLCBlZGl0b3IgaXNcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHRleHQgbm9kZSBzaG91bGQgaGF2ZSBubyBjaGFyYWN0ZXJzLiBIb3dldmVyLCBkdXJpbmcgSU1FXG4gICAgICAvLyBjb21wb3NpdGlvbiB0aGUgQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UsIHNvIHN1YnRyYWN0IDEgZnJvbSB0aGUgb2Zmc2V0IHRvIGFjY291bnQgZm9yIHRoZSB6ZXJvLXdpZHRoXG4gICAgICAvLyBzcGFjZSBjaGFyYWN0ZXIuXG4gICAgICBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgfHxcbiAgICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgYHJhbmdlLmNsb25lQ29udGVudHMoKWAgcmV0dXJucyBhbiBleHRyYSB0cmFpbGluZyAnXFxuJ1xuICAgICAgLy8gd2hlbiB0aGUgZG9jdW1lbnQgZW5kcyB3aXRoIGEgbmV3LWxpbmUgY2hhcmFjdGVyLiBUaGlzIHJlc3VsdHMgaW4gdGhlIG9mZnNldFxuICAgICAgLy8gbGVuZ3RoIGJlaW5nIG9mZiBieSBvbmUsIHNvIHdlIG5lZWQgdG8gc3VidHJhY3Qgb25lIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAgICBJU19GSVJFRk9YICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudDIgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIuZW5kc1dpdGgoJ1xcblxcbicpKSkge1xuICAgICAgICBvZmZzZXQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKElTX0FORFJPSUQgJiYgIXRleHROb2RlICYmICFleGFjdE1hdGNoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSA/IHBhcmVudE5vZGUgOiBwYXJlbnROb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGVdJyk7XG4gICAgICBpZiAobm9kZSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBfc2xhdGVOb2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH0gPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBET01FZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBfc2xhdGVOb2RlKSk7XG4gICAgICAgIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1sZWFmXScpKSB7XG4gICAgICAgICAgX29mZnNldCA9IG5lYXJlc3RPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHN1cHByZXNzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHBvaW50IGZyb20gRE9NIHBvaW50OiBcIi5jb25jYXQoZG9tUG9pbnQpKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcbiAgICB2YXIgc2xhdGVOb2RlID0gRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldFxuICAgIH07XG4gIH0sXG4gIHRvU2xhdGVSYW5nZTogKGVkaXRvciwgZG9tUmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2ZvY3VzTm9kZSR0ZXh0Q29udGVuO1xuICAgIHZhciB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBlbCA9IGlzRE9NU2VsZWN0aW9uKGRvbVJhbmdlKSA/IGRvbVJhbmdlLmFuY2hvck5vZGUgOiBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICB2YXIgYW5jaG9yTm9kZTtcbiAgICB2YXIgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1c05vZGU7XG4gICAgdmFyIGZvY3VzT2Zmc2V0O1xuICAgIHZhciBpc0NvbGxhcHNlZDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChpc0RPTVNlbGVjdGlvbihkb21SYW5nZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZXRpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzU0ODYjaXNzdWUtMTgyMDcyMDIyMylcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZG9tUmFuZ2UucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7IC8vIEZvY3VzIG5vZGUgd29ya3MgZmluZVxuICAgICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdChkb21SYW5nZS5yYW5nZUNvdW50IC0gMSk7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBhcmUgaW4gdGhlIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9mIGEgdGFibGUgaW4gZmlyZWZveFxuICAgICAgICAgIGlmIChmb2N1c05vZGUgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGxhc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEhUTUxFbGVtZW50LCBiZWNvdXNlIEVsZW1lbnQgaXMgYSBzbGF0ZSBlbGVtZW50XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMYXN0Q2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlUm93ID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZVJvdyA9IGxhc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGZhaWwgYXMgXCJUaGUgSFRNTEVsZW1lbnQgaW50ZXJmYWNlIHJlcHJlc2VudHMgYW55IEhUTUwgZWxlbWVudC5cIlxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZSA9IGdldExhc3RDaGlsZHJlbihmaXJzdE5vZGVSb3cuY2hpbGRyZW5bZmlyc3RSYW5nZS5zdGFydE9mZnNldF0pO1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGxhc3ROb2RlUm93LmNoaWxkcmVuW2xhc3RSYW5nZS5zdGFydE9mZnNldF0pO1xuICAgICAgICAgICAgLy8gWmVybywgYXMgd2UgYWxsd2F5cyB0YWtlIHRoZSByaWdodCBvbmUgYXMgdGhlIGFuY2hvciBwb2ludFxuICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKGxhc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Tm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gZmlyc3ROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3ROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE5vZGUuaW5uZXJIVE1MLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9wdGlvblxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByZWFkIG9ubHkgbW9kZSBvZiBhIGZpcmVmb3ggdGFibGVcbiAgICAgICAgICAgIC8vIFJpZ2h0IHRvIGxlZnRcbiAgICAgICAgICAgIGlmIChmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3RSYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3RSYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZmlyc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGZpcnN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLmFuY2hvck5vZGU7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogVGhlcmUncyBhIGJ1ZyBpbiBjaHJvbWUgdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICAgIC8vIGBpc0NvbGxhcHNlZGAgZm9yIGEgU2VsZWN0aW9uIHRoYXQgY29tZXMgZnJvbSBhIFNoYWRvd1Jvb3QuXG4gICAgICAgIC8vICgyMDIwLzA4LzA4KVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbiAgICAgICAgLy8gSXNDb2xsYXBzZWQgbWlnaHQgbm90IHdvcmsgaW4gZmlyZWZveCwgYnV0IHRoaXMgd2lsbFxuICAgICAgICBpZiAoSVNfQ0hST01FICYmIGhhc1NoYWRvd1Jvb3QoYW5jaG9yTm9kZSkgfHwgSVNfRklSRUZPWCkge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuYW5jaG9yTm9kZSA9PT0gZG9tUmFuZ2UuZm9jdXNOb2RlICYmIGRvbVJhbmdlLmFuY2hvck9mZnNldCA9PT0gZG9tUmFuZ2UuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5pc0NvbGxhcHNlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICBmb2N1c09mZnNldCA9IGRvbVJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5jb2xsYXBzZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZm9jdXNOb2RlID09IG51bGwgfHwgYW5jaG9yT2Zmc2V0ID09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIERPTSByYW5nZTogXCIuY29uY2F0KGRvbVJhbmdlKSk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogRmlyZWZveCBzb21ldGltZXMgaW5jbHVkZXMgYW4gZXh0cmEgXFxuIChyZW5kZXJlZCBieSBUZXh0U3RyaW5nXG4gICAgLy8gd2hlbiBpc1RyYWlsaW5nIGlzIHRydWUpIGluIHRoZSBmb2N1c09mZnNldCwgcmVzdWx0aW5nIGluIGFuIGludmFsaWRcbiAgICAvLyBTbGF0ZSBwb2ludC4gKDIwMjMvMTEvMDEpXG4gICAgaWYgKElTX0ZJUkVGT1ggJiYgKF9mb2N1c05vZGUkdGV4dENvbnRlbiA9IGZvY3VzTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2ZvY3VzTm9kZSR0ZXh0Q29udGVuICE9PSB2b2lkIDAgJiYgX2ZvY3VzTm9kZSR0ZXh0Q29udGVuLmVuZHNXaXRoKCdcXG5cXG4nKSAmJiBmb2N1c09mZnNldCA9PT0gZm9jdXNOb2RlLnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgZm9jdXNPZmZzZXQtLTtcbiAgICB9XG4gICAgdmFyIGFuY2hvciA9IERPTUVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBmb2N1c0JlZm9yZUFuY2hvciA9IGlzQmVmb3JlKGFuY2hvck5vZGUsIGZvY3VzTm9kZSkgfHwgYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGZvY3VzT2Zmc2V0IDwgYW5jaG9yT2Zmc2V0O1xuICAgIHZhciBmb2N1cyA9IGlzQ29sbGFwc2VkID8gYW5jaG9yIDogRE9NRWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3csXG4gICAgICBzZWFyY2hEaXJlY3Rpb246IGZvY3VzQmVmb3JlQW5jaG9yID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICAgIGlmICghZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgLy8gaWYgdGhlIHNlbGVjdGlvbiBpcyBhIGhhbmdpbmcgcmFuZ2UgdGhhdCBlbmRzIGluIGEgdm9pZFxuICAgIC8vIGFuZCB0aGUgRE9NIGZvY3VzIGlzIGFuIEVsZW1lbnRcbiAgICAvLyAobWVhbmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gZW5kcyBiZWZvcmUgdGhlIGVsZW1lbnQpXG4gICAgLy8gdW5oYW5nIHRoZSByYW5nZSB0byBhdm9pZCBtaXN0YWtlbmx5IGluY2x1ZGluZyB0aGUgdm9pZFxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHJhbmdlKSAmJiBSYW5nZS5pc0ZvcndhcmQocmFuZ2UpICYmIGlzRE9NRWxlbWVudChmb2N1c05vZGUpICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLmZvY3VzLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpIHtcbiAgICAgIHJhbmdlID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIHtcbiAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHRleHQgZGlmZiB3YXMgYXBwbGllZCBpbiBhIHdheSB3ZSBjYW4gcGVyZm9ybSB0aGUgcGVuZGluZyBhY3Rpb24gb24gL1xuICogcmVjb3ZlciB0aGUgcGVuZGluZyBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGlmZi5zdGFydCAhPT0gbm9kZS50ZXh0Lmxlbmd0aCB8fCBkaWZmLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dC5zbGljZShkaWZmLnN0YXJ0LCBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkgPT09IGRpZmYudGV4dDtcbiAgfVxuICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBuZXh0UGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG5leHROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBuZXh0UGF0aCk7XG4gIHJldHVybiBUZXh0LmlzVGV4dChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUudGV4dC5zdGFydHNXaXRoKGRpZmYudGV4dCk7XG59XG5mdW5jdGlvbiBhcHBseVN0cmluZ0RpZmYodGV4dCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGlmZnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGRpZmZzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlmZnMucmVkdWNlKCh0ZXh0LCBkaWZmKSA9PiB0ZXh0LnNsaWNlKDAsIGRpZmYuc3RhcnQpICsgZGlmZi50ZXh0ICsgdGV4dC5zbGljZShkaWZmLmVuZCksIHRleHQpO1xufVxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChzdHIsIGFub3RoZXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KGkpICE9PSBhbm90aGVyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHN0ciwgYW5vdGhlciwgbWF4KSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCwgbWF4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KHN0ci5sZW5ndGggLSBpIC0gMSkgIT09IGFub3RoZXIuY2hhckF0KGFub3RoZXIubGVuZ3RoIC0gaSAtIDEpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogUmVtb3ZlIHJlZHVuZGFudCBjaGFuZ2VzIGZyb20gdGhlIGRpZmYgc28gdGhhdCBpdCBzcGFucyB0aGUgbWluaW1hbCBwb3NzaWJsZSByYW5nZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIGRpZmYpIHtcbiAgdmFyIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9ID0gZGlmZjtcbiAgdmFyIHJlbW92ZWRUZXh0ID0gdGFyZ2V0VGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHByZWZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQpO1xuICB2YXIgbWF4ID0gTWF0aC5taW4ocmVtb3ZlZFRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCk7XG4gIHZhciBzdWZmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0LCBtYXgpO1xuICB2YXIgbm9ybWFsaXplZCA9IHtcbiAgICBzdGFydDogc3RhcnQgKyBwcmVmaXhMZW5ndGgsXG4gICAgZW5kOiBlbmQgLSBzdWZmaXhMZW5ndGgsXG4gICAgdGV4dDogdGV4dC5zbGljZShwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gc3VmZml4TGVuZ3RoKVxuICB9O1xuICBpZiAobm9ybWFsaXplZC5zdGFydCA9PT0gbm9ybWFsaXplZC5lbmQgJiYgbm9ybWFsaXplZC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgZGlmZiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYXBwbHlpbmcgYiBhZnRlciBhIHNwYW5uaW5nIHRoZSByYW5nZSBvZlxuICogYm90aCBjaGFuZ2VzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU3RyaW5nRGlmZnModGFyZ2V0VGV4dCwgYSwgYikge1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgdmFyIG92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCwgYi5lbmQpIC0gYi5zdGFydCk7XG4gIHZhciBhcHBsaWVkID0gYXBwbHlTdHJpbmdEaWZmKHRhcmdldFRleHQsIGEsIGIpO1xuICB2YXIgc2xpY2VFbmQgPSBNYXRoLm1heChiLnN0YXJ0ICsgYi50ZXh0Lmxlbmd0aCwgYS5zdGFydCArIGEudGV4dC5sZW5ndGggKyAoYS5zdGFydCArIGEudGV4dC5sZW5ndGggPiBiLnN0YXJ0ID8gYi50ZXh0Lmxlbmd0aCA6IDApIC0gb3ZlcmxhcCk7XG4gIHZhciB0ZXh0ID0gYXBwbGllZC5zbGljZShzdGFydCwgc2xpY2VFbmQpO1xuICB2YXIgZW5kID0gTWF0aC5tYXgoYS5lbmQsIGIuZW5kIC0gYS50ZXh0Lmxlbmd0aCArIChhLmVuZCAtIGEuc3RhcnQpKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICB0ZXh0XG4gIH0pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHNsYXRlIHJhbmdlIHRoZSB0ZXh0IGRpZmYgc3BhbnMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldFJhbmdlKHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLmVuZFxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgcG9pbnQnIGEuay5hIGEgcG9pbnQgYmFzZWQgb24gdGhlIGRvbSBzdGF0ZSBiZWZvcmUgYXBwbHlpbmdcbiAqIHRoZSBwZW5kaW5nIGRpZmZzLiBTaW5jZSB0aGUgcGVuZGluZyBkaWZmcyBtaWdodCBoYXZlIGJlZW4gaW5zZXJ0ZWQgd2l0aCBkaWZmZXJlbnRcbiAqIG1hcmtzIHdlIGhhdmUgdG8gJ3dhbGsnIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gdG8gZW5zdXJlIHdlIHN0aWxsXG4gKiBoYXZlIGEgdmFsaWQgcG9pbnQgaW5zaWRlIHRoZSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQb2ludChlZGl0b3IsIHBvaW50KSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfSA9IHBvaW50O1xuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVhZiA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIGlmICghVGV4dC5pc1RleHQobGVhZikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcGFyZW50QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICBhdDogcGF0aFxuICB9KTtcbiAgaWYgKCFwYXJlbnRCbG9jaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPiBsZWFmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5leHQoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pO1xuICAgIGlmICghZW50cnkgfHwgIVBhdGguaXNEZXNjZW5kYW50KGVudHJ5WzFdLCBwYXJlbnRCbG9ja1sxXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvZmZzZXQgLT0gbGVhZi50ZXh0Lmxlbmd0aDtcbiAgICBsZWFmID0gZW50cnlbMF07XG4gICAgcGF0aCA9IGVudHJ5WzFdO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgc2VsZWN0aW9uJyB0byBlbnN1cmUgaXQncyB2YWxpZCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgYW5jaG9yID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IpO1xuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cbiAgdmFyIGZvY3VzID0gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCByYW5nZS5mb2N1cyk7XG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcG9pbnQsIG9wKSB7XG4gIHZhciBwZW5kaW5nRGlmZnMgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKTtcbiAgdmFyIHRleHREaWZmID0gcGVuZGluZ0RpZmZzID09PSBudWxsIHx8IHBlbmRpbmdEaWZmcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0RpZmZzLmZpbmQoX3JlZiA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMocGF0aCwgcG9pbnQucGF0aCk7XG4gIH0pO1xuICBpZiAoIXRleHREaWZmIHx8IHBvaW50Lm9mZnNldCA8PSB0ZXh0RGlmZi5kaWZmLnN0YXJ0KSB7XG4gICAgcmV0dXJuIFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gIH1cbiAgdmFyIHtcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBpbnNpZGUgdGhlIGRpZmYgPT4gdHJhbnNmb3JtIHRoZSBwb2ludCBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgLy8gdGhlIGRpZmYgd2lsbCBiZSBhcHBsaWVkIHRvIGFuZCBhZGQgdGhlIG9mZnNldCBpbnNpZGUgdGhlIGRpZmYuXG4gIGlmIChwb2ludC5vZmZzZXQgPD0gZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgX2FuY2hvciA9IHtcbiAgICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9O1xuICAgIHZhciBfdHJhbnNmb3JtZWQgPSBQb2ludC50cmFuc2Zvcm0oX2FuY2hvciwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgaWYgKCFfdHJhbnNmb3JtZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogX3RyYW5zZm9ybWVkLnBhdGgsXG4gICAgICBvZmZzZXQ6IF90cmFuc2Zvcm1lZC5vZmZzZXQgKyBwb2ludC5vZmZzZXQgLSBkaWZmLnN0YXJ0XG4gICAgfTtcbiAgfVxuICAvLyBQb2ludCByZWZlcmVuY2VzIGxvY2F0aW9uIGFmdGVyIHRoZSBkaWZmXG4gIHZhciBhbmNob3IgPSB7XG4gICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICBvZmZzZXQ6IHBvaW50Lm9mZnNldCAtIGRpZmYudGV4dC5sZW5ndGggKyBkaWZmLmVuZCAtIGRpZmYuc3RhcnRcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKGFuY2hvciwgb3AsIHtcbiAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICB9KTtcbiAgaWYgKCF0cmFuc2Zvcm1lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcC50eXBlID09PSAnc3BsaXRfbm9kZScgJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcG9pbnQucGF0aCkgJiYgYW5jaG9yLm9mZnNldCA8IG9wLnBvc2l0aW9uICYmIGRpZmYuc3RhcnQgPCBvcC5wb3NpdGlvbikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IHRyYW5zZm9ybWVkLnBhdGgsXG4gICAgb2Zmc2V0OiB0cmFuc2Zvcm1lZC5vZmZzZXQgKyBkaWZmLnRleHQubGVuZ3RoIC0gZGlmZi5lbmQgKyBkaWZmLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3ApIHtcbiAgdmFyIGFuY2hvciA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvciwgb3ApO1xuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXM6IGFuY2hvclxuICAgIH07XG4gIH1cbiAgdmFyIGZvY3VzID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMsIG9wKTtcbiAgaWYgKCFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApIHtcbiAgdmFyIHtcbiAgICBwYXRoLFxuICAgIGRpZmYsXG4gICAgaWRcbiAgfSA9IHRleHREaWZmO1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5vZmZzZXQgPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogb3AudGV4dC5sZW5ndGggKyBkaWZmLmVuZCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPD0gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3AucG9zaXRpb24gPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucG9zaXRpb24gPiBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogTWF0aC5taW4ob3AucG9zaXRpb24sIGRpZmYuZW5kKSxcbiAgICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0IC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgKyBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgIH07XG4gICAgICB9XG4gIH1cbiAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gIGlmICghbmV3UGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGlmZixcbiAgICBwYXRoOiBuZXdQYXRoLFxuICAgIGlkXG4gIH07XG59XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBzaW5nbGUtbGluZSBkZWxldGlvblxuICovXG52YXIgZG9SZWN0c0ludGVyc2VjdCA9IChyZWN0LCBjb21wYXJlUmVjdCkgPT4ge1xuICB2YXIgbWlkZGxlID0gKGNvbXBhcmVSZWN0LnRvcCArIGNvbXBhcmVSZWN0LmJvdHRvbSkgLyAyO1xuICByZXR1cm4gcmVjdC50b3AgPD0gbWlkZGxlICYmIHJlY3QuYm90dG9tID49IG1pZGRsZTtcbn07XG52YXIgYXJlUmFuZ2VzU2FtZUxpbmUgPSAoZWRpdG9yLCByYW5nZTEsIHJhbmdlMikgPT4ge1xuICB2YXIgcmVjdDEgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciByZWN0MiA9IERPTUVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGRvUmVjdHNJbnRlcnNlY3QocmVjdDEsIHJlY3QyKSAmJiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QyLCByZWN0MSk7XG59O1xuLyoqXG4gKiBBIGhlbHBlciB1dGlsaXR5IHRoYXQgcmV0dXJucyB0aGUgZW5kIHBvcnRpb24gb2YgYSBgUmFuZ2VgXG4gKiB3aGljaCBpcyBsb2NhdGVkIG9uIGEgc2luZ2xlIGxpbmUuXG4gKlxuICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7UmFuZ2V9IHBhcmVudFJhbmdlIFRoZSBwYXJlbnQgcmFuZ2UgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7UmFuZ2V9IEEgdmFsaWQgcG9ydGlvbiBvZiB0aGUgcGFyZW50UmFuZ2Ugd2hpY2ggaXMgb25lIGEgc2luZ2xlIGxpbmVcbiAqL1xudmFyIGZpbmRDdXJyZW50TGluZVJhbmdlID0gKGVkaXRvciwgcGFyZW50UmFuZ2UpID0+IHtcbiAgdmFyIHBhcmVudFJhbmdlQm91bmRhcnkgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBSYW5nZS5lbmQocGFyZW50UmFuZ2UpKTtcbiAgdmFyIHBvc2l0aW9ucyA9IEFycmF5LmZyb20oRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICBhdDogcGFyZW50UmFuZ2VcbiAgfSkpO1xuICB2YXIgbGVmdCA9IDA7XG4gIHZhciByaWdodCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHJpZ2h0IC8gMik7XG4gIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG4gIHdoaWxlIChtaWRkbGUgIT09IHBvc2l0aW9ucy5sZW5ndGggJiYgbWlkZGxlICE9PSBsZWZ0KSB7XG4gICAgaWYgKGFyZVJhbmdlc1NhbWVMaW5lKGVkaXRvciwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW21pZGRsZV0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBtaWRkbGU7XG4gICAgfVxuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW2xlZnRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyoqXG4gKiBgd2l0aERPTWAgYWRkcyBET00gc3BlY2lmaWMgYmVoYXZpb3JzIHRvIHRoZSBlZGl0b3IuXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcbiAqIHRoaXMgcGx1Z2luLlxuICpcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXG4gKi9cbnZhciB3aXRoRE9NID0gZnVuY3Rpb24gd2l0aERPTShlZGl0b3IpIHtcbiAgdmFyIGNsaXBib2FyZEZvcm1hdEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gtc2xhdGUtZnJhZ21lbnQnO1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseSxcbiAgICBvbkNoYW5nZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBhZGRNYXJrLFxuICAgIHJlbW92ZU1hcmtcbiAgfSA9IGU7XG4gIC8vIFRoZSBXZWFrTWFwIHdoaWNoIG1hcHMgYSBrZXkgdG8gYSBzcGVjaWZpYyBIVE1MRWxlbWVudCBtdXN0IGJlIHNjb3BlZCB0byB0aGUgZWRpdG9yIGluc3RhbmNlIHRvXG4gIC8vIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlZGl0b3JzIGluIHRoZSBET00gdGhhdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZS5cbiAgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULnNldChlLCBuZXcgV2Vha01hcCgpKTtcbiAgZS5hZGRNYXJrID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GLCBfRURJVE9SX1RPX1BFTkRJTkdfREk7XG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRigpO1xuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICBhZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9O1xuICBlLnJlbW92ZU1hcmsgPSBrZXkgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkyO1xuICAgIGlmICghRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlKSAmJiAoX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMiAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIubGVuZ3RoKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcGVuZGluZyBkaWZmcyBvcmlnaW5hdGluZyBmcm9tIGNoYW5nZXMgYmVmb3JlIHRoZSBhZGRNYXJrXG4gICAgICAvLyBhcmUgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRpbmdcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZSwgbnVsbCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICByZW1vdmVNYXJrKGtleSk7XG4gIH07XG4gIGUuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAodW5pdCAhPT0gJ2xpbmUnKSB7XG4gICAgICByZXR1cm4gZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gICAgfVxuICAgIGlmIChlLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlLnNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBwYXJlbnRCbG9ja0VudHJ5ID0gRWRpdG9yLmFib3ZlKGUsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZSwgbiksXG4gICAgICAgIGF0OiBlLnNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAocGFyZW50QmxvY2tFbnRyeSkge1xuICAgICAgICB2YXIgWywgcGFyZW50QmxvY2tQYXRoXSA9IHBhcmVudEJsb2NrRW50cnk7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZSwgcGFyZW50QmxvY2tQYXRoLCBlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICB2YXIgY3VycmVudExpbmVSYW5nZSA9IGZpbmRDdXJyZW50TGluZVJhbmdlKGUsIHBhcmVudEVsZW1lbnRSYW5nZSk7XG4gICAgICAgIGlmICghUmFuZ2UuaXNDb2xsYXBzZWQoY3VycmVudExpbmVSYW5nZSkpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlLCB7XG4gICAgICAgICAgICBhdDogY3VycmVudExpbmVSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGlzIGF0dGVtcHRzIHRvIHJlc2V0IHRoZSBOT0RFX1RPX0tFWSBlbnRyeSB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBhcyBhcHBseSgpIGNoYW5nZXMgdGhlIG9iamVjdCByZWZlcmVuY2UgYW5kIGhlbmNlIGludmFsaWRhdGVzIHRoZSBOT0RFX1RPX0tFWSBlbnRyeVxuICBlLmFwcGx5ID0gb3AgPT4ge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIHBhdGhSZWZNYXRjaGVzID0gW107XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKTtcbiAgICBpZiAocGVuZGluZ0RpZmZzICE9PSBudWxsICYmIHBlbmRpbmdEaWZmcyAhPT0gdm9pZCAwICYmIHBlbmRpbmdEaWZmcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHBlbmRpbmdEaWZmcy5tYXAodGV4dERpZmYgPT4gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGUsIHRyYW5zZm9ybWVkKTtcbiAgICB9XG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGUpO1xuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uKSB7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uc2V0KGUsIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nU2VsZWN0aW9uLCBvcCkpO1xuICAgIH1cbiAgICB2YXIgcGVuZGluZ0FjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZSk7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gIT09IG51bGwgJiYgcGVuZGluZ0FjdGlvbiAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb24uYXQpIHtcbiAgICAgIHZhciBhdCA9IFBvaW50LmlzUG9pbnQocGVuZGluZ0FjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nQWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nQWN0aW9uLmF0KSA/IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCkgOiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlLCBhdCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGVuZGluZ0FjdGlvbiksIHt9LCB7XG4gICAgICAgIGF0XG4gICAgICB9KSA6IG51bGwpO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgb3AucGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG4gICAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyBtYW51YWxseSBzZXQsIGRvbid0IHJlc3RvcmUgdGhlIHVzZXIgc2VsZWN0aW9uIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5kZWxldGUoZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLnBhdGgpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhvcC5wYXRoKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBwcmV2UGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihQYXRoLnBhcmVudChvcC5wYXRoKSwgUGF0aC5wYXJlbnQob3AubmV3UGF0aCkpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIGNvbW1vblBhdGgpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZFBhdGg7XG4gICAgICAgICAgaWYgKFBhdGguaXNCZWZvcmUob3AucGF0aCwgb3AubmV3UGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLnBhdGgpKSk7XG4gICAgICAgICAgICBjaGFuZ2VkUGF0aCA9IG9wLm5ld1BhdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIFBhdGgucGFyZW50KG9wLm5ld1BhdGgpKSk7XG4gICAgICAgICAgICBjaGFuZ2VkUGF0aCA9IG9wLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZE5vZGVLZXkgPSBET01FZGl0b3IuZmluZEtleShlLCBjaGFuZ2VkTm9kZSk7XG4gICAgICAgICAgdmFyIGNoYW5nZWRQYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZSwgUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICBwYXRoUmVmTWF0Y2hlcy5wdXNoKFtjaGFuZ2VkUGF0aFJlZiwgY2hhbmdlZE5vZGVLZXldKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseShvcCk7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRklYTUU6IFJlbmFtZSB0byBzb21ldGhpbmcgbGlrZSBJU19ET01fRURJVE9SX0RFU1lOQ0VEXG4gICAgICAgICAgLy8gdG8gYmV0dGVyIHJlZmxlY3QgcmVhbGl0eSwgc2VlICM1NzkyXG4gICAgICAgICAgSVNfTk9ERV9NQVBfRElSVFkuc2V0KGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIFtwYXRoLCBrZXldIG9mIG1hdGNoZXMpIHtcbiAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlLCBwYXRoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBbcGF0aFJlZiwgX2tleV0gb2YgcGF0aFJlZk1hdGNoZXMpIHtcbiAgICAgIGlmIChwYXRoUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIFtfbm9kZV0gPSBFZGl0b3Iubm9kZShlLCBwYXRoUmVmLmN1cnJlbnQpO1xuICAgICAgICBOT0RFX1RPX0tFWS5zZXQoX25vZGUsIF9rZXkpO1xuICAgICAgfVxuICAgICAgcGF0aFJlZi51bnJlZigpO1xuICAgIH1cbiAgfTtcbiAgZS5zZXRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGU7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgdmFyIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgfSk7XG4gICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogZW5kLnBhdGhcbiAgICB9KTtcbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2U2NC1lbmNvZGVkIGNvcHkgb2YgdGhlXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIEhUTUwsIHRvIGRlY29kZSBvbiBmdXR1cmUgcGFzdGVzLlxuICAgIHZhciBkb21SYW5nZSA9IERPTUVkaXRvci50b0RPTVJhbmdlKGUsIHNlbGVjdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgIHZhciBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzWzBdO1xuICAgIC8vIE1ha2Ugc3VyZSBhdHRhY2ggaXMgbm9uLWVtcHR5LCBzaW5jZSBlbXB0eSBub2RlcyB3aWxsIG5vdCBnZXQgY29waWVkLlxuICAgIGNvbnRlbnRzLmNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnRleHRDb250ZW50ICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICBhdHRhY2ggPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIENPTVBBVDogSWYgdGhlIGVuZCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIGVuZCBvZiB0aGVcbiAgICAvLyByYW5nZSBmcm9tIHRoZSB2b2lkIG5vZGUncyBzcGFjZXIgc3BhbiwgdG8gdGhlIGVuZCBvZiB0aGUgdm9pZCBub2RlJ3NcbiAgICAvLyBjb250ZW50LCBzaW5jZSB0aGUgc3BhY2VyIGlzIGJlZm9yZSB2b2lkJ3MgY29udGVudCBpbiB0aGUgRE9NLlxuICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICB2YXIgW3ZvaWROb2RlXSA9IGVuZFZvaWQ7XG4gICAgICB2YXIgciA9IGRvbVJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHZhciBkb21Ob2RlID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBJZiB0aGUgc3RhcnQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBhdHRhY2ggdGhlIGVuY29kZWRcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgdm9pZCBub2RlJ3MgY29udGVudCBub2RlIGluc3RlYWQgb2YgdGhlIHNwYWNlciwgYmVjYXVzZVxuICAgIC8vIGF0dGFjaGluZyBpdCB0byBlbXB0eSBgPGRpdj4vPHNwYW4+YCBub2RlcyB3aWxsIGVuZCB1cCBoYXZpbmcgaXQgZXJhc2VkIGJ5XG4gICAgLy8gbW9zdCBicm93c2Vycy4gKDIwMTgvMDQvMjcpXG4gICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgYXR0YWNoID0gY29udGVudHMucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtc3BhY2VyXScpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cbiAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLmZvckVhY2goencgPT4ge1xuICAgICAgdmFyIGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICduJztcbiAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB9KTtcbiAgICAvLyBTZXQgYSBgZGF0YS1zbGF0ZS1mcmFnbWVudGAgYXR0cmlidXRlIG9uIGEgbm9uLWVtcHR5IG5vZGUsIHNvIGl0IHNob3dzIHVwXG4gICAgLy8gaW4gdGhlIEhUTUwsIGFuZCBjYW4gYmUgdXNlZCBmb3IgaW50cmEtU2xhdGUgcGFzdGluZy4gSWYgaXQncyBhIHRleHRcbiAgICAvLyBub2RlLCB3cmFwIGl0IGluIGEgYDxzcGFuPmAgc28gd2UgaGF2ZSBzb21ldGhpbmcgdG8gc2V0IGFuIGF0dHJpYnV0ZSBvbi5cbiAgICBpZiAoaXNET01UZXh0KGF0dGFjaCkpIHtcbiAgICAgIHZhciBzcGFuID0gYXR0YWNoLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgd2UgZG9uJ3QgYWRkIHRoZSBgd2hpdGUtc3BhY2VgIHN0eWxlXG4gICAgICAvLyB0aGVuIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyB3aWxsIGJlIGlnbm9yZWQuICgyMDE3LzA5LzIxKVxuICAgICAgc3Bhbi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKGF0dGFjaCk7XG4gICAgICBjb250ZW50cy5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGF0dGFjaCA9IHNwYW47XG4gICAgfVxuICAgIHZhciBmcmFnbWVudCA9IGUuZ2V0RnJhZ21lbnQoKTtcbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZnJhZ21lbnQpO1xuICAgIHZhciBlbmNvZGVkID0gd2luZG93LmJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTtcbiAgICBkYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9cIi5jb25jYXQoY2xpcGJvYXJkRm9ybWF0S2V5KSwgZW5jb2RlZCk7XG4gICAgLy8gQWRkIHRoZSBjb250ZW50IHRvIGEgPGRpdj4gc28gdGhhdCB3ZSBjYW4gZ2V0IGl0cyBpbm5lciBIVE1MLlxuICAgIHZhciBkaXYgPSBjb250ZW50cy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ3RydWUnKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGRpdi5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGdldFBsYWluVGV4dChkaXYpKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgZS5pbnNlcnREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKCFlLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSkge1xuICAgICAgZS5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG4gIGUuaW5zZXJ0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tpbmcgY29waWVkIGZyYWdtZW50IGZyb20gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBvciBkYXRhLXNsYXRlLWZyYWdtZW50XG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cuYXRvYihmcmFnbWVudCkpO1xuICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgICBlLmluc2VydEZyYWdtZW50KHBhcnNlZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBlLmluc2VydFRleHREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbiAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZSwge1xuICAgICAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5pbnNlcnRUZXh0KGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBlLm9uQ2hhbmdlID0gb3B0aW9ucyA9PiB7XG4gICAgdmFyIG9uQ29udGV4dENoYW5nZSA9IEVESVRPUl9UT19PTl9DSEFOR0UuZ2V0KGUpO1xuICAgIGlmIChvbkNvbnRleHRDaGFuZ2UpIHtcbiAgICAgIG9uQ29udGV4dENoYW5nZShvcHRpb25zKTtcbiAgICB9XG4gICAgb25DaGFuZ2Uob3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBlO1xufTtcbnZhciBnZXRNYXRjaGVzID0gKGUsIHBhdGgpID0+IHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZSwge1xuICAgIGF0OiBwYXRoXG4gIH0pKSB7XG4gICAgdmFyIGtleSA9IERPTUVkaXRvci5maW5kS2V5KGUsIG4pO1xuICAgIG1hdGNoZXMucHVzaChbcCwga2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG52YXIgVFJJUExFX0NMSUNLID0gMztcblxuLyoqXG4gKiBIb3RrZXkgbWFwcGluZ3MgZm9yIGVhY2ggcGxhdGZvcm0uXG4gKi9cbnZhciBIT1RLRVlTID0ge1xuICBib2xkOiAnbW9kK2InLFxuICBjb21wb3NlOiBbJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd1cCcsICdiYWNrc3BhY2UnLCAnZW50ZXInXSxcbiAgbW92ZUJhY2t3YXJkOiAnbGVmdCcsXG4gIG1vdmVGb3J3YXJkOiAncmlnaHQnLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnY3RybCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnY3RybCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiAnc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUZvcndhcmQ6ICdzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kQmFja3dhcmQ6ICdzaGlmdCtsZWZ0JyxcbiAgZXh0ZW5kRm9yd2FyZDogJ3NoaWZ0K3JpZ2h0JyxcbiAgaXRhbGljOiAnbW9kK2knLFxuICBpbnNlcnRTb2Z0QnJlYWs6ICdzaGlmdCtlbnRlcicsXG4gIHNwbGl0QmxvY2s6ICdlbnRlcicsXG4gIHVuZG86ICdtb2Qreidcbn07XG52YXIgQVBQTEVfSE9US0VZUyA9IHtcbiAgbW92ZUxpbmVCYWNrd2FyZDogJ29wdCt1cCcsXG4gIG1vdmVMaW5lRm9yd2FyZDogJ29wdCtkb3duJyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ29wdCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnb3B0K3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6IFsnY3RybCtiYWNrc3BhY2UnLCAnY3RybCtoJ10sXG4gIGRlbGV0ZUZvcndhcmQ6IFsnY3RybCtkZWxldGUnLCAnY3RybCtkJ10sXG4gIGRlbGV0ZUxpbmVCYWNrd2FyZDogJ2NtZCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlTGluZUZvcndhcmQ6IFsnY21kK3NoaWZ0PytkZWxldGUnLCAnY3RybCtrJ10sXG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ29wdCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdvcHQrc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZExpbmVCYWNrd2FyZDogJ29wdCtzaGlmdCt1cCcsXG4gIGV4dGVuZExpbmVGb3J3YXJkOiAnb3B0K3NoaWZ0K2Rvd24nLFxuICByZWRvOiAnY21kK3NoaWZ0K3onLFxuICB0cmFuc3Bvc2VDaGFyYWN0ZXI6ICdjdHJsK3QnXG59O1xudmFyIFdJTkRPV1NfSE9US0VZUyA9IHtcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnY3RybCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdjdHJsK3NoaWZ0PytkZWxldGUnLFxuICByZWRvOiBbJ2N0cmwreScsICdjdHJsK3NoaWZ0K3onXVxufTtcbi8qKlxuICogQ3JlYXRlIGEgcGxhdGZvcm0tYXdhcmUgaG90a2V5IGNoZWNrZXIuXG4gKi9cbnZhciBjcmVhdGUgPSBrZXkgPT4ge1xuICB2YXIgZ2VuZXJpYyA9IEhPVEtFWVNba2V5XTtcbiAgdmFyIGFwcGxlID0gQVBQTEVfSE9US0VZU1trZXldO1xuICB2YXIgd2luZG93cyA9IFdJTkRPV1NfSE9US0VZU1trZXldO1xuICB2YXIgaXNHZW5lcmljID0gZ2VuZXJpYyAmJiBpc0hvdGtleShnZW5lcmljKTtcbiAgdmFyIGlzQXBwbGUgPSBhcHBsZSAmJiBpc0hvdGtleShhcHBsZSk7XG4gIHZhciBpc1dpbmRvd3MgPSB3aW5kb3dzICYmIGlzSG90a2V5KHdpbmRvd3MpO1xuICByZXR1cm4gZXZlbnQgPT4ge1xuICAgIGlmIChpc0dlbmVyaWMgJiYgaXNHZW5lcmljKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKElTX0FQUExFICYmIGlzQXBwbGUgJiYgaXNBcHBsZShldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghSVNfQVBQTEUgJiYgaXNXaW5kb3dzICYmIGlzV2luZG93cyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG4vKipcbiAqIEhvdGtleXMuXG4gKi9cbnZhciBob3RrZXlzID0ge1xuICBpc0JvbGQ6IGNyZWF0ZSgnYm9sZCcpLFxuICBpc0NvbXBvc2U6IGNyZWF0ZSgnY29tcG9zZScpLFxuICBpc01vdmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlQmFja3dhcmQnKSxcbiAgaXNNb3ZlRm9yd2FyZDogY3JlYXRlKCdtb3ZlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlRm9yd2FyZDogY3JlYXRlKCdkZWxldGVGb3J3YXJkJyksXG4gIGlzRGVsZXRlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUZvcndhcmQnKSxcbiAgaXNJdGFsaWM6IGNyZWF0ZSgnaXRhbGljJyksXG4gIGlzTW92ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlTGluZUJhY2t3YXJkJyksXG4gIGlzTW92ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVMaW5lRm9yd2FyZCcpLFxuICBpc01vdmVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRCYWNrd2FyZCcpLFxuICBpc01vdmVXb3JkRm9yd2FyZDogY3JlYXRlKCdtb3ZlV29yZEZvcndhcmQnKSxcbiAgaXNSZWRvOiBjcmVhdGUoJ3JlZG8nKSxcbiAgaXNTb2Z0QnJlYWs6IGNyZWF0ZSgnaW5zZXJ0U29mdEJyZWFrJyksXG4gIGlzU3BsaXRCbG9jazogY3JlYXRlKCdzcGxpdEJsb2NrJyksXG4gIGlzVHJhbnNwb3NlQ2hhcmFjdGVyOiBjcmVhdGUoJ3RyYW5zcG9zZUNoYXJhY3RlcicpLFxuICBpc1VuZG86IGNyZWF0ZSgndW5kbycpXG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcbnZhciBzaGFsbG93Q29tcGFyZSA9IChvYmoxLCBvYmoyKSA9PiBPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhvYmoxKS5ldmVyeShrZXkgPT4gb2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9iajFba2V5XSA9PT0gb2JqMltrZXldKTtcbnZhciBpc0RlY29yYXRpb25GbGFnc0VxdWFsID0gKHJhbmdlLCBvdGhlcikgPT4ge1xuICB2YXIgcmFuZ2VPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkKTtcbiAgdmFyIG90aGVyT3duUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3RoZXIsIF9leGNsdWRlZDIpO1xuICByZXR1cm4gcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSAmJiBzaGFsbG93Q29tcGFyZShyYW5nZU93blByb3BzLCBvdGhlck93blByb3BzKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxuICpcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cbiAqL1xudmFyIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcbiAgICBpZiAoIVJhbmdlLmVxdWFscyhyYW5nZSwgb3RoZXIpIHx8ICFpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cbiAqXG4gKiBQRVJGOiB0aGlzIHJlcXVpcmVzIHRoZSB0d28gbGlzdHMgdG8gYWxzbyBoYXZlIHRoZSByYW5nZXMgaW5zaWRlIHRoZW0gaW4gdGhlXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXG4gKi9cbnZhciBpc1RleHREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG4gICAgLy8gY29tcGFyZSBvbmx5IG9mZnNldHMgYmVjYXVzZSBwYXRocyBkb2Vzbid0IG1hdHRlciBmb3IgdGV4dFxuICAgIGlmIChyYW5nZS5hbmNob3Iub2Zmc2V0ICE9PSBvdGhlci5hbmNob3Iub2Zmc2V0IHx8IHJhbmdlLmZvY3VzLm9mZnNldCAhPT0gb3RoZXIuZm9jdXMub2Zmc2V0IHx8ICFpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgeyBDQU5fVVNFX0RPTSwgRE9NRWRpdG9yLCBET01FbGVtZW50LCBET01Ob2RlLCBET01SYW5nZSwgRE9NU2VsZWN0aW9uLCBET01TdGF0aWNSYW5nZSwgRE9NVGV4dCwgRURJVE9SX1RPX0VMRU1FTlQsIEVESVRPUl9UT19GT1JDRV9SRU5ERVIsIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCwgRURJVE9SX1RPX09OX0NIQU5HRSwgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLCBFRElUT1JfVE9fUEVORElOR19ESUZGUywgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLCBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04sIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULCBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0gsIEVESVRPUl9UT19VU0VSX01BUktTLCBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04sIEVESVRPUl9UT19XSU5ET1csIEVMRU1FTlRfVE9fTk9ERSwgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JULCBob3RrZXlzIGFzIEhvdGtleXMsIElTX0FORFJPSUQsIElTX0NIUk9NRSwgSVNfQ09NUE9TSU5HLCBJU19GSVJFRk9YLCBJU19GSVJFRk9YX0xFR0FDWSwgSVNfRk9DVVNFRCwgSVNfSU9TLCBJU19OT0RFX01BUF9ESVJUWSwgSVNfUkVBRF9PTkxZLCBJU19VQ19NT0JJTEUsIElTX1dFQktJVCwgSVNfV0VDSEFUQlJPV1NFUiwgS2V5LCBNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCwgTk9ERV9UT19FTEVNRU5ULCBOT0RFX1RPX0lOREVYLCBOT0RFX1RPX0tFWSwgTk9ERV9UT19QQVJFTlQsIFBMQUNFSE9MREVSX1NZTUJPTCwgVFJJUExFX0NMSUNLLCBhcHBseVN0cmluZ0RpZmYsIGdldEFjdGl2ZUVsZW1lbnQsIGdldERlZmF1bHRWaWV3LCBnZXRTZWxlY3Rpb24sIGhhc1NoYWRvd1Jvb3QsIGlzQWZ0ZXIsIGlzQmVmb3JlLCBpc0RPTUVsZW1lbnQsIGlzRE9NTm9kZSwgaXNET01TZWxlY3Rpb24sIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwsIGlzUGxhaW5UZXh0T25seVBhc3RlLCBpc1RleHREZWNvcmF0aW9uc0VxdWFsLCBpc1RyYWNrZWRNdXRhdGlvbiwgbWVyZ2VTdHJpbmdEaWZmcywgbm9ybWFsaXplRE9NUG9pbnQsIG5vcm1hbGl6ZVBvaW50LCBub3JtYWxpemVSYW5nZSwgbm9ybWFsaXplU3RyaW5nRGlmZiwgdGFyZ2V0UmFuZ2UsIHZlcmlmeURpZmZTdGF0ZSwgd2l0aERPTSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-dom/dist/index.es.js\n");

/***/ })

};
;